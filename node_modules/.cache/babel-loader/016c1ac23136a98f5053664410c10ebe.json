{"ast":null,"code":"'use strict';\n/* @flow */\n\n/**\n * This is the internal implementation of quantiles: when you know\n * that the order is sorted, you don't need to re-sort it, and the computations\n * are faster.\n *\n * @param {Array<number>} x sample of one or more data points\n * @param {number} p desired quantile: a number between 0 to 1, inclusive\n * @returns {number} quantile value\n * @throws {Error} if p ix outside of the range from 0 to 1\n * @throws {Error} if x is empty\n * @example\n * quantileSorted([3, 6, 7, 8, 8, 9, 10, 13, 15, 16, 20], 0.5); // => 9\n */\n\nfunction quantileSorted(x\n/*: Array<number> */\n, p\n/*: number */\n)\n/*:number*/\n{\n  var idx = x.length * p;\n\n  if (x.length === 0) {\n    throw new Error('quantile requires at least one data point.');\n  } else if (p < 0 || p > 1) {\n    throw new Error('quantiles must be between 0 and 1');\n  } else if (p === 1) {\n    // If p is 1, directly return the last element\n    return x[x.length - 1];\n  } else if (p === 0) {\n    // If p is 0, directly return the first element\n    return x[0];\n  } else if (idx % 1 !== 0) {\n    // If p is not integer, return the next element in array\n    return x[Math.ceil(idx) - 1];\n  } else if (x.length % 2 === 0) {\n    // If the list has even-length, we'll take the average of this number\n    // and the next value, if there is one\n    return (x[idx - 1] + x[idx]) / 2;\n  } else {\n    // Finally, in the simple case of an integer value\n    // with an odd-length list, return the x value at the index.\n    return x[idx];\n  }\n}\n\nmodule.exports = quantileSorted;","map":{"version":3,"sources":["/home/amax/Autoro/cabana/node_modules/simple-statistics/src/quantile_sorted.js"],"names":["quantileSorted","x","p","idx","length","Error","Math","ceil","module","exports"],"mappings":"AAAA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,SAASA,cAAT,CAAwBC;AAAE;AAA1B,EAAgDC;AAAE;AAAlD;AAAgE;AAAY;AACxE,MAAIC,GAAG,GAAGF,CAAC,CAACG,MAAF,GAAWF,CAArB;;AACA,MAAID,CAAC,CAACG,MAAF,KAAa,CAAjB,EAAoB;AAChB,UAAM,IAAIC,KAAJ,CAAU,4CAAV,CAAN;AACH,GAFD,MAEO,IAAIH,CAAC,GAAG,CAAJ,IAASA,CAAC,GAAG,CAAjB,EAAoB;AACvB,UAAM,IAAIG,KAAJ,CAAU,mCAAV,CAAN;AACH,GAFM,MAEA,IAAIH,CAAC,KAAK,CAAV,EAAa;AAChB;AACA,WAAOD,CAAC,CAACA,CAAC,CAACG,MAAF,GAAW,CAAZ,CAAR;AACH,GAHM,MAGA,IAAIF,CAAC,KAAK,CAAV,EAAa;AAChB;AACA,WAAOD,CAAC,CAAC,CAAD,CAAR;AACH,GAHM,MAGA,IAAIE,GAAG,GAAG,CAAN,KAAY,CAAhB,EAAmB;AACtB;AACA,WAAOF,CAAC,CAACK,IAAI,CAACC,IAAL,CAAUJ,GAAV,IAAiB,CAAlB,CAAR;AACH,GAHM,MAGA,IAAIF,CAAC,CAACG,MAAF,GAAW,CAAX,KAAiB,CAArB,EAAwB;AAC3B;AACA;AACA,WAAO,CAACH,CAAC,CAACE,GAAG,GAAG,CAAP,CAAD,GAAaF,CAAC,CAACE,GAAD,CAAf,IAAwB,CAA/B;AACH,GAJM,MAIA;AACH;AACA;AACA,WAAOF,CAAC,CAACE,GAAD,CAAR;AACH;AACJ;;AAEDK,MAAM,CAACC,OAAP,GAAiBT,cAAjB","sourcesContent":["'use strict';\n/* @flow */\n\n/**\n * This is the internal implementation of quantiles: when you know\n * that the order is sorted, you don't need to re-sort it, and the computations\n * are faster.\n *\n * @param {Array<number>} x sample of one or more data points\n * @param {number} p desired quantile: a number between 0 to 1, inclusive\n * @returns {number} quantile value\n * @throws {Error} if p ix outside of the range from 0 to 1\n * @throws {Error} if x is empty\n * @example\n * quantileSorted([3, 6, 7, 8, 8, 9, 10, 13, 15, 16, 20], 0.5); // => 9\n */\nfunction quantileSorted(x /*: Array<number> */, p /*: number */)/*:number*/ {\n    var idx = x.length * p;\n    if (x.length === 0) {\n        throw new Error('quantile requires at least one data point.');\n    } else if (p < 0 || p > 1) {\n        throw new Error('quantiles must be between 0 and 1');\n    } else if (p === 1) {\n        // If p is 1, directly return the last element\n        return x[x.length - 1];\n    } else if (p === 0) {\n        // If p is 0, directly return the first element\n        return x[0];\n    } else if (idx % 1 !== 0) {\n        // If p is not integer, return the next element in array\n        return x[Math.ceil(idx) - 1];\n    } else if (x.length % 2 === 0) {\n        // If the list has even-length, we'll take the average of this number\n        // and the next value, if there is one\n        return (x[idx - 1] + x[idx]) / 2;\n    } else {\n        // Finally, in the simple case of an integer value\n        // with an odd-length list, return the x value at the index.\n        return x[idx];\n    }\n}\n\nmodule.exports = quantileSorted;\n"]},"metadata":{},"sourceType":"script"}