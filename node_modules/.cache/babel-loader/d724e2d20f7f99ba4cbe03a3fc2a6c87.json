{"ast":null,"code":"const Module = require('./libbz2/bzip2');\n\nconst Event = require('weakmap-event');\n\nconst {\n  partial\n} = require('ap');\n\nvar initPromise = null;\nvar instance = null;\nvar fnPtr = null;\nvar inBuffSize = 1024 * 1024;\nvar outBuffSize = inBuffSize * 32;\nconst DataEvent = Event();\nconst stateStore = {};\nmodule.exports = {\n  sendNextChunk,\n  flush,\n  init,\n  start,\n  finish,\n  onData: DataEvent.listen\n};\n\nfunction sendNextChunk(ref, chunk) {\n  ref.buffers.push(chunk);\n\n  while (ref.currentBuffer || ref.buffers.length) {\n    if (!ref.currentBuffer || ref.currentBuffer.byteLength < 1) {\n      if (!ref.buffers.length) {\n        break;\n      }\n\n      ref.currentBuffer = ref.buffers.shift();\n    }\n\n    let inSize = ref.currentBuffer.byteLength > inBuffSize ? inBuffSize : ref.currentBuffer.byteLength;\n    instance.HEAPU8.set(ref.currentBuffer.slice(0, inSize), ref.inBuff); // console.log('Working on this chunk...', ref.currentBuffer.byteLength);\n\n    ref.isFinished = !!instance._decompress(ref.ref, ref.inBuff, inSize, ref.outBuff, outBuffSize);\n\n    if (ref.isFinished) {// console.log('FINISHED');\n    }\n\n    if (inSize === ref.currentBuffer.byteLength) {\n      ref.currentBuffer = null;\n    } else {\n      ref.currentBuffer = ref.currentBuffer.slice(inSize);\n    }\n  }\n}\n\nfunction flush(ref) {\n  while (!ref.isFinished) {\n    ref.isFinished = !!instance._decompress(ref.ref, 0, 0, ref.outBuff, outBuffSize);\n  } // console.log('Finished decompress');\n\n}\n\nasync function init() {\n  if (initPromise) {\n    return initPromise;\n  }\n\n  initPromise = new Promise(function (resolve, reject) {\n    const moduleInstance = Module({\n      onRuntimeInitialized: onInit // memory growth is enabled, so whatever...\n      // TOTAL_MEMORY: 1024 * 1024 * 1024\n\n    });\n\n    function onInit() {\n      // console.log('onRuntimeInitialized');\n      // should print garbage\n      fnPtr = moduleInstance.addFunction(callback, 'viii'); // console.log('Registered a function', fnPtr);\n\n      moduleInstance._registerCallback(fnPtr);\n\n      instance = moduleInstance;\n      resolve({\n        instance\n      });\n    }\n  });\n  return initPromise;\n}\n\nfunction callback(refNum, size, done) {\n  const ref = stateStore[refNum];\n  var buffer = ref.outBuff; // console.log('Callback', size, done);\n\n  if (size > 0) {\n    const resultView = new Uint8Array(instance.HEAPU8.buffer, buffer, size);\n    const result = new Uint8Array(resultView);\n    DataEvent.broadcast(ref, result);\n  }\n\n  if (done) {\n    ref.isFinished = !!done; // console.log('FINISHED');\n  }\n}\n\nasync function start() {\n  // console.log('start preinit');\n  await init(); // console.log('start postinit');\n\n  var inBuff = instance._malloc(inBuffSize);\n\n  var outBuff = instance._malloc(outBuffSize);\n\n  var ref = instance._start(); // console.log('This is my ref', ref);\n\n\n  stateStore[ref] = {\n    ref,\n    inBuff,\n    outBuff,\n    buffers: []\n  };\n  stateStore[ref].onData = partial(DataEvent.listen, stateStore[ref]);\n  return stateStore[ref];\n}\n\nasync function finish(ref) {\n  // console.log('finish preinit');\n  await init(); // console.log('finish postinit');\n\n  instance._finish(ref.ref); // console.log('finish postfinished', ref.inBuff);\n\n\n  instance._free(ref.inBuff); // console.log('free');\n\n\n  instance._free(ref.outBuff); // console.log('free');\n\n\n  delete stateStore[ref.ref];\n}","map":{"version":3,"sources":["/home/amax/Autoro/cabana/node_modules/wasm-bz2/index.js"],"names":["Module","require","Event","partial","initPromise","instance","fnPtr","inBuffSize","outBuffSize","DataEvent","stateStore","module","exports","sendNextChunk","flush","init","start","finish","onData","listen","ref","chunk","buffers","push","currentBuffer","length","byteLength","shift","inSize","HEAPU8","set","slice","inBuff","isFinished","_decompress","outBuff","Promise","resolve","reject","moduleInstance","onRuntimeInitialized","onInit","addFunction","callback","_registerCallback","refNum","size","done","buffer","resultView","Uint8Array","result","broadcast","_malloc","_start","_finish","_free"],"mappings":"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","sourcesContent":["const Module = require('./libbz2/bzip2');\nconst Event = require('weakmap-event');\nconst { partial } = require('ap');\n\nvar initPromise = null;\nvar instance = null;\nvar fnPtr = null;\nvar inBuffSize = 1024 * 1024;\nvar outBuffSize = inBuffSize * 32;\n\nconst DataEvent = Event();\n\nconst stateStore = {};\n\nmodule.exports = {\n  sendNextChunk,\n  flush,\n  init,\n  start,\n  finish,\n  onData: DataEvent.listen\n};\n\nfunction sendNextChunk (ref, chunk) {\n  ref.buffers.push(chunk);\n\n  while (ref.currentBuffer || ref.buffers.length) {\n    if (!ref.currentBuffer || ref.currentBuffer.byteLength < 1) {\n      if (!ref.buffers.length) {\n        break;\n      }\n      ref.currentBuffer = ref.buffers.shift();\n    }\n    let inSize = ref.currentBuffer.byteLength > inBuffSize ? inBuffSize : ref.currentBuffer.byteLength;\n    instance.HEAPU8.set(ref.currentBuffer.slice(0, inSize), ref.inBuff);\n\n    // console.log('Working on this chunk...', ref.currentBuffer.byteLength);\n    ref.isFinished = !!instance._decompress(ref.ref, ref.inBuff, inSize, ref.outBuff, outBuffSize);\n    if (ref.isFinished) {\n      // console.log('FINISHED');\n    }\n    if (inSize === ref.currentBuffer.byteLength) {\n      ref.currentBuffer = null;\n    } else {\n      ref.currentBuffer = ref.currentBuffer.slice(inSize);\n    }\n  }\n}\n\nfunction flush (ref) {\n  while (!ref.isFinished) {\n    ref.isFinished = !!instance._decompress(ref.ref, 0, 0, ref.outBuff, outBuffSize);\n  }\n  // console.log('Finished decompress');\n}\n\nasync function init () {\n  if (initPromise) {\n    return initPromise;\n  }\n  initPromise = new Promise(function (resolve, reject) {\n    const moduleInstance = Module({\n      onRuntimeInitialized: onInit\n      // memory growth is enabled, so whatever...\n      // TOTAL_MEMORY: 1024 * 1024 * 1024\n    });\n\n    function onInit () {\n      // console.log('onRuntimeInitialized');\n      // should print garbage\n      fnPtr = moduleInstance.addFunction(callback, 'viii');\n      // console.log('Registered a function', fnPtr);\n\n      moduleInstance._registerCallback(fnPtr);\n\n      instance = moduleInstance;\n      resolve({ instance });\n    }\n  });\n\n  return initPromise;\n}\n\nfunction callback (refNum, size, done) {\n  const ref = stateStore[refNum];\n  var buffer = ref.outBuff;\n  // console.log('Callback', size, done);\n  if (size > 0) {\n    const resultView = new Uint8Array(instance.HEAPU8.buffer, buffer, size);\n    const result = new Uint8Array(resultView);\n    DataEvent.broadcast(ref, result);\n  }\n  if (done) {\n    ref.isFinished = !!done;\n    // console.log('FINISHED');\n  }\n}\n\nasync function start () {\n  // console.log('start preinit');\n  await init();\n  // console.log('start postinit');\n  var inBuff = instance._malloc(inBuffSize);\n  var outBuff = instance._malloc(outBuffSize);\n  var ref = instance._start();\n  // console.log('This is my ref', ref);\n\n  stateStore[ref] = {\n    ref,\n    inBuff,\n    outBuff,\n    buffers: []\n  };\n  stateStore[ref].onData = partial(DataEvent.listen, stateStore[ref]);\n  return stateStore[ref];\n}\n\nasync function finish (ref) {\n  // console.log('finish preinit');\n  await init();\n  // console.log('finish postinit');\n  instance._finish(ref.ref);\n  // console.log('finish postfinished', ref.inBuff);\n  instance._free(ref.inBuff);\n  // console.log('free');\n  instance._free(ref.outBuff);\n  // console.log('free');\n\n  delete stateStore[ref.ref];\n}\n"]},"metadata":{},"sourceType":"script"}