{"ast":null,"code":"const carFingerprintToDbc = require('./car_fingerprint_to_dbc.json');\n\nfunction findMaxByteStateChangeCount(messages) {\n  return Object.values(messages).map(m => m.byteStateChangeCounts).reduce((counts, countArr) => counts.concat(countArr), []) // flatten arrays\n  .reduce((count1, count2) => count1 > count2 ? count1 : count2, 0); // find max\n}\n\nfunction addCanMessage(canMessage, dbc, canStartTime, messages, prevMsgEntries, byteStateChangeCountsByMessage) {\n  const {\n    address,\n    busTime,\n    data,\n    bus\n  } = canMessage;\n  const id = `${bus}:${address.toString(16)}`;\n  if (messages[id] === undefined) messages[id] = createMessageSpec(dbc, address, id, bus);\n  const prevMsgEntry = messages[id].entries.length > 0 ? messages[id].entries[messages[id].entries.length - 1] : prevMsgEntries[id] || null;\n\n  if (byteStateChangeCountsByMessage[id] && messages[id].byteStateChangeCounts.every(c => c === 0)) {\n    messages[id].byteStateChangeCounts = byteStateChangeCountsByMessage[id];\n  }\n\n  const {\n    msgEntry,\n    byteStateChangeCounts\n  } = parseMessage(dbc, busTime, address, data, canStartTime, prevMsgEntry);\n  messages[id].byteStateChangeCounts = byteStateChangeCounts.map((count, idx) => messages[id].byteStateChangeCounts[idx] + count);\n  messages[id].entries.push(msgEntry);\n  return msgEntry;\n}\n\nfunction createMessageSpec(dbc, address, id, bus) {\n  const frame = dbc.getMessageFrame(address);\n  const size = frame ? frame.size : 8;\n  return {\n    address,\n    id,\n    bus,\n    entries: [],\n    frame,\n    byteColors: Array(size).fill(0),\n    byteStateChangeCounts: Array(size).fill(0)\n  };\n}\n\nfunction determineByteStateChangeTimes(hexData, time, msgSize, lastParsedMessage) {\n  const byteStateChangeCounts = Array(msgSize).fill(0);\n  let byteStateChangeTimes;\n\n  if (!lastParsedMessage) {\n    byteStateChangeTimes = Array(msgSize).fill(time);\n  } else {\n    // debugger;\n    byteStateChangeTimes = lastParsedMessage.byteStateChangeTimes;\n\n    for (let i = 0; i < byteStateChangeTimes.length; i++) {\n      const currentData = hexData.substr(i * 2, 2);\n      const prevData = lastParsedMessage.hexData.substr(i * 2, 2);\n\n      if (currentData !== prevData) {\n        byteStateChangeTimes[i] = time;\n        byteStateChangeCounts[i] = 1;\n      }\n    }\n  }\n\n  return {\n    byteStateChangeTimes,\n    byteStateChangeCounts\n  };\n}\n\nfunction createMessageEntry(dbc, address, time, relTime, data, byteStateChangeTimes) {\n  return {\n    signals: dbc.getSignalValues(address, data),\n    address,\n    data,\n    time,\n    relTime,\n    hexData: Buffer.from(data).toString('hex'),\n    byteStateChangeTimes,\n    updated: Date.now()\n  };\n}\n\nfunction reparseMessage(dbc, msg, lastParsedMessage) {\n  const msgSpec = dbc.getMessageFrame(msg.address);\n  const msgSize = msgSpec ? msgSpec.size : 8;\n  const {\n    byteStateChangeTimes,\n    byteStateChangeCounts\n  } = determineByteStateChangeTimes(msg.hexData, msg.relTime, msgSize, lastParsedMessage);\n  const msgEntry = { ...msg,\n    signals: dbc.getSignalValues(msg.address, msg.data),\n    byteStateChangeTimes,\n    updated: Date.now()\n  };\n  return {\n    msgEntry,\n    byteStateChangeCounts\n  };\n}\n\nfunction parseMessage(dbc, time, address, data, timeStart, lastParsedMessage) {\n  let hexData;\n\n  if (typeof data === 'string') {\n    hexData = data;\n    data = Buffer.from(data, 'hex');\n  } else {\n    hexData = Buffer.from(data).toString('hex');\n  }\n\n  const msgSpec = dbc.getMessageFrame(address);\n  const msgSize = msgSpec ? msgSpec.size : Math.max(8, data.length);\n  const relTime = time - timeStart;\n  const {\n    byteStateChangeTimes,\n    byteStateChangeCounts\n  } = determineByteStateChangeTimes(hexData, relTime, msgSize, lastParsedMessage);\n  const msgEntry = createMessageEntry(dbc, address, time, relTime, data, byteStateChangeTimes);\n  return {\n    msgEntry,\n    byteStateChangeCounts\n  };\n}\n\nconst BIG_ENDIAN_START_BITS = [];\n\nfor (let i = 0; i < 8 * 64; i += 8) {\n  for (let j = 7; j > -1; j--) {\n    BIG_ENDIAN_START_BITS.push(i + j);\n  }\n}\n\nfunction bigEndianBitIndex(matrixBitIndex) {\n  return BIG_ENDIAN_START_BITS.indexOf(matrixBitIndex);\n}\n\nfunction matrixBitNumber(bigEndianIndex) {\n  return BIG_ENDIAN_START_BITS[bigEndianIndex];\n}\n\nfunction setMessageByteColors(message, maxByteStateChangeCount) {\n  message.byteColors = message.byteStateChangeCounts.map(count => isNaN(count) ? 0 : Math.min(255, 75 + 180 * (count / maxByteStateChangeCount))).map(red => `rgb(${Math.round(red)},0,0)`);\n  return message;\n}\n\nfunction maxMessageSize(message) {\n  let initial = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 8;\n  let max = initial;\n\n  for (const entry of message.entries) {\n    const data = Buffer.from(entry.hexData, 'hex');\n\n    if (data.length > max) {\n      max = data.length;\n    }\n  }\n\n  return max;\n}\n\nfunction findDbcForCar(fingerprint) {\n  if (fingerprint in carFingerprintToDbc) {\n    return carFingerprintToDbc[fingerprint];\n  }\n\n  return null;\n}\n\nexport default {\n  bigEndianBitIndex,\n  addCanMessage,\n  createMessageSpec,\n  matrixBitNumber,\n  parseMessage,\n  reparseMessage,\n  findMaxByteStateChangeCount,\n  setMessageByteColors,\n  createMessageEntry,\n  maxMessageSize,\n  findDbcForCar\n};","map":{"version":3,"sources":["/home/amax/Autoro/cabana/src/utils/dbc.js"],"names":["carFingerprintToDbc","require","findMaxByteStateChangeCount","messages","Object","values","map","m","byteStateChangeCounts","reduce","counts","countArr","concat","count1","count2","addCanMessage","canMessage","dbc","canStartTime","prevMsgEntries","byteStateChangeCountsByMessage","address","busTime","data","bus","id","toString","undefined","createMessageSpec","prevMsgEntry","entries","length","every","c","msgEntry","parseMessage","count","idx","push","frame","getMessageFrame","size","byteColors","Array","fill","determineByteStateChangeTimes","hexData","time","msgSize","lastParsedMessage","byteStateChangeTimes","i","currentData","substr","prevData","createMessageEntry","relTime","signals","getSignalValues","Buffer","from","updated","Date","now","reparseMessage","msg","msgSpec","timeStart","Math","max","BIG_ENDIAN_START_BITS","j","bigEndianBitIndex","matrixBitIndex","indexOf","matrixBitNumber","bigEndianIndex","setMessageByteColors","message","maxByteStateChangeCount","isNaN","min","red","round","maxMessageSize","initial","entry","findDbcForCar","fingerprint"],"mappings":"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","sourcesContent":["const carFingerprintToDbc = require('./car_fingerprint_to_dbc.json');\n\nfunction findMaxByteStateChangeCount(messages) {\n  return Object.values(messages)\n    .map((m) => m.byteStateChangeCounts)\n    .reduce((counts, countArr) => counts.concat(countArr), []) // flatten arrays\n    .reduce((count1, count2) => (count1 > count2 ? count1 : count2), 0); // find max\n}\n\nfunction addCanMessage(\n  canMessage,\n  dbc,\n  canStartTime,\n  messages,\n  prevMsgEntries,\n  byteStateChangeCountsByMessage\n) {\n  const {\n    address, busTime, data, bus\n  } = canMessage;\n  const id = `${bus}:${address.toString(16)}`;\n\n  if (messages[id] === undefined) messages[id] = createMessageSpec(dbc, address, id, bus);\n\n  const prevMsgEntry = messages[id].entries.length > 0\n    ? messages[id].entries[messages[id].entries.length - 1]\n    : prevMsgEntries[id] || null;\n\n  if (\n    byteStateChangeCountsByMessage[id]\n    && messages[id].byteStateChangeCounts.every((c) => c === 0)\n  ) {\n    messages[id].byteStateChangeCounts = byteStateChangeCountsByMessage[id];\n  }\n\n  const { msgEntry, byteStateChangeCounts } = parseMessage(\n    dbc,\n    busTime,\n    address,\n    data,\n    canStartTime,\n    prevMsgEntry\n  );\n\n  messages[id].byteStateChangeCounts = byteStateChangeCounts.map(\n    (count, idx) => messages[id].byteStateChangeCounts[idx] + count\n  );\n\n  messages[id].entries.push(msgEntry);\n\n  return msgEntry;\n}\n\nfunction createMessageSpec(dbc, address, id, bus) {\n  const frame = dbc.getMessageFrame(address);\n  const size = frame ? frame.size : 8;\n\n  return {\n    address,\n    id,\n    bus,\n    entries: [],\n    frame,\n    byteColors: Array(size).fill(0),\n    byteStateChangeCounts: Array(size).fill(0)\n  };\n}\n\nfunction determineByteStateChangeTimes(\n  hexData,\n  time,\n  msgSize,\n  lastParsedMessage\n) {\n  const byteStateChangeCounts = Array(msgSize).fill(0);\n  let byteStateChangeTimes;\n\n  if (!lastParsedMessage) {\n    byteStateChangeTimes = Array(msgSize).fill(time);\n  } else {\n    // debugger;\n    byteStateChangeTimes = lastParsedMessage.byteStateChangeTimes;\n\n    for (let i = 0; i < byteStateChangeTimes.length; i++) {\n      const currentData = hexData.substr(i * 2, 2);\n      const prevData = lastParsedMessage.hexData.substr(i * 2, 2);\n\n      if (currentData !== prevData) {\n        byteStateChangeTimes[i] = time;\n        byteStateChangeCounts[i] = 1;\n      }\n    }\n  }\n\n  return { byteStateChangeTimes, byteStateChangeCounts };\n}\n\nfunction createMessageEntry(\n  dbc,\n  address,\n  time,\n  relTime,\n  data,\n  byteStateChangeTimes\n) {\n  return {\n    signals: dbc.getSignalValues(address, data),\n    address,\n    data,\n    time,\n    relTime,\n    hexData: Buffer.from(data).toString('hex'),\n    byteStateChangeTimes,\n    updated: Date.now()\n  };\n}\n\nfunction reparseMessage(dbc, msg, lastParsedMessage) {\n  const msgSpec = dbc.getMessageFrame(msg.address);\n  const msgSize = msgSpec ? msgSpec.size : 8;\n\n  const {\n    byteStateChangeTimes,\n    byteStateChangeCounts\n  } = determineByteStateChangeTimes(\n    msg.hexData,\n    msg.relTime,\n    msgSize,\n    lastParsedMessage\n  );\n\n  const msgEntry = {\n    ...msg,\n    signals: dbc.getSignalValues(msg.address, msg.data),\n    byteStateChangeTimes,\n    updated: Date.now()\n  };\n\n  return { msgEntry, byteStateChangeCounts };\n}\n\nfunction parseMessage(dbc, time, address, data, timeStart, lastParsedMessage) {\n  let hexData;\n  if (typeof data === 'string') {\n    hexData = data;\n    data = Buffer.from(data, 'hex');\n  } else {\n    hexData = Buffer.from(data).toString('hex');\n  }\n  const msgSpec = dbc.getMessageFrame(address);\n  const msgSize = msgSpec ? msgSpec.size : Math.max(8, data.length);\n  const relTime = time - timeStart;\n\n  const {\n    byteStateChangeTimes,\n    byteStateChangeCounts\n  } = determineByteStateChangeTimes(\n    hexData,\n    relTime,\n    msgSize,\n    lastParsedMessage\n  );\n  const msgEntry = createMessageEntry(\n    dbc,\n    address,\n    time,\n    relTime,\n    data,\n    byteStateChangeTimes\n  );\n\n  return { msgEntry, byteStateChangeCounts };\n}\n\nconst BIG_ENDIAN_START_BITS = [];\nfor (let i = 0; i < 8 * 64; i += 8) {\n  for (let j = 7; j > -1; j--) {\n    BIG_ENDIAN_START_BITS.push(i + j);\n  }\n}\n\nfunction bigEndianBitIndex(matrixBitIndex) {\n  return BIG_ENDIAN_START_BITS.indexOf(matrixBitIndex);\n}\n\nfunction matrixBitNumber(bigEndianIndex) {\n  return BIG_ENDIAN_START_BITS[bigEndianIndex];\n}\n\nfunction setMessageByteColors(message, maxByteStateChangeCount) {\n  message.byteColors = message.byteStateChangeCounts\n    .map((count) => (isNaN(count)\n      ? 0\n      : Math.min(255, 75 + 180 * (count / maxByteStateChangeCount))))\n    .map((red) => `rgb(${Math.round(red)},0,0)`);\n\n  return message;\n}\n\nfunction maxMessageSize(message, initial = 8) {\n  let max = initial;\n  for (const entry of message.entries) {\n    const data = Buffer.from(entry.hexData, 'hex');\n    if (data.length > max) {\n      max = data.length;\n    }\n  }\n  return max;\n}\n\nfunction findDbcForCar(fingerprint) {\n  if (fingerprint in carFingerprintToDbc) {\n    return carFingerprintToDbc[fingerprint];\n  }\n  return null;\n}\n\nexport default {\n  bigEndianBitIndex,\n  addCanMessage,\n  createMessageSpec,\n  matrixBitNumber,\n  parseMessage,\n  reparseMessage,\n  findMaxByteStateChangeCount,\n  setMessageByteColors,\n  createMessageEntry,\n  maxMessageSize,\n  findDbcForCar,\n};\n"]},"metadata":{},"sourceType":"module"}