{"ast":null,"code":"var _jsxFileName = \"/home/amax/Autoro/cabana/src/CanExplorer.js\";\nimport React, { Component } from 'react';\nimport Moment from 'moment';\nimport PropTypes from 'prop-types';\nimport cx from 'classnames';\nimport { createWriteStream } from 'streamsaver';\nimport Panda from '@commaai/pandajs';\nimport CommaAuth, { storage as CommaAuthStorage, config as AuthConfig } from '@commaai/my-comma-auth';\nimport { raw as RawDataApi, drives as DrivesApi } from '@commaai/comma-api';\nimport { timeout, interval } from 'thyming';\nimport { USE_UNLOGGER, PART_SEGMENT_LENGTH, STREAMING_WINDOW, GITHUB_AUTH_TOKEN_KEY } from './config';\nimport * as GithubAuth from './api/github-auth';\nimport DBC from './models/can/dbc';\nimport Meta from './components/Meta';\nimport Explorer from './components/Explorer';\nimport OnboardingModal from './components/Modals/OnboardingModal';\nimport SaveDbcModal from './components/SaveDbcModal';\nimport LoadDbcModal from './components/LoadDbcModal';\nimport debounce from './utils/debounce';\nimport EditMessageModal from './components/EditMessageModal';\nimport { persistDbc, fetchPersistedDbc, unpersistGithubAuthToken } from './api/localstorage';\nimport OpenDbc from './api/OpenDbc';\nimport UnloggerClient from './api/unlogger';\nimport { hash } from './utils/string';\nimport { modifyQueryParameters } from './utils/url';\nimport DbcUtils from './utils/dbc';\nconst NEW_DBC = 'New_DBC';\n\nconst RLogDownloader = require('./workers/rlog-downloader.worker');\n\nconst LogCSVDownloader = require('./workers/dbc-csv-downloader.worker');\n\nconst MessageParser = require('./workers/message-parser.worker');\n\nconst CanStreamerWorker = require('./workers/CanStreamerWorker.worker');\n\nconst dataCache = {};\nexport default class CanExplorer extends Component {\n  constructor(props) {\n    super(props);\n    this.partChangeDebounced = debounce(() => {\n      this.loadMessagesFromCache();\n      this.spawnWorker();\n    }, 500);\n    this.state = {\n      messages: {},\n      thumbnails: [],\n      selectedMessages: [],\n      route: null,\n      canFrameOffset: 0,\n      routeInitTime: 0,\n      firstFrameTime: 0,\n      carFingerprint: null,\n      firstCanTime: null,\n      lastBusTime: null,\n      selectedMessage: null,\n      currentParts: [0, 0],\n      currentPart: 0,\n      currentWorkers: {},\n      loadingParts: [],\n      loadedParts: [],\n      showOnboarding: false,\n      showLoadDbc: false,\n      showSaveDbc: false,\n      showEditMessageModal: false,\n      editMessageModalMessage: null,\n      dbc: props.dbc ? props.dbc : new DBC(),\n      dbcText: props.dbc ? props.dbc.text() : new DBC().text(),\n      dbcFilename: props.dbcFilename ? props.dbcFilename : NEW_DBC,\n      dbcLastSaved: null,\n      seekTime: props.seekTime || 0,\n      seekIndex: 0,\n      maxByteStateChangeCount: 0,\n      partsLoaded: 0,\n      spawnWorkerHash: null,\n      attemptingPandaConnection: false,\n      pandaNoDeviceSelected: false,\n      live: false,\n      isGithubAuthenticated: props.githubAuthToken !== null && props.githubAuthToken !== undefined,\n      shareUrl: null,\n      logUrls: null,\n      share: null\n    };\n    this.openDbcClient = new OpenDbc(props.githubAuthToken);\n\n    if (USE_UNLOGGER) {\n      this.unloggerClient = new UnloggerClient();\n    }\n\n    this.showOnboarding = this.showOnboarding.bind(this);\n    this.hideOnboarding = this.hideOnboarding.bind(this);\n    this.showLoadDbc = this.showLoadDbc.bind(this);\n    this.hideLoadDbc = this.hideLoadDbc.bind(this);\n    this.showSaveDbc = this.showSaveDbc.bind(this);\n    this.hideSaveDbc = this.hideSaveDbc.bind(this);\n    this.showEditMessageModal = this.showEditMessageModal.bind(this);\n    this.hideEditMessageModal = this.hideEditMessageModal.bind(this);\n    this.onDbcSelected = this.onDbcSelected.bind(this);\n    this.onDbcSaved = this.onDbcSaved.bind(this);\n    this.onConfirmedSignalChange = this.onConfirmedSignalChange.bind(this);\n    this.onPartChange = this.onPartChange.bind(this);\n    this.onMessageFrameEdited = this.onMessageFrameEdited.bind(this);\n    this.onSeek = this.onSeek.bind(this);\n    this.onUserSeek = this.onUserSeek.bind(this);\n    this.onMessageSelected = this.onMessageSelected.bind(this);\n    this.onMessageUnselected = this.onMessageUnselected.bind(this);\n    this.initCanData = this.initCanData.bind(this);\n    this.updateSelectedMessages = this.updateSelectedMessages.bind(this);\n    this.handlePandaConnect = this.handlePandaConnect.bind(this);\n    this.processStreamedCanMessages = this.processStreamedCanMessages.bind(this);\n    this.onStreamedCanMessagesProcessed = this.onStreamedCanMessagesProcessed.bind(this);\n    this.showingModal = this.showingModal.bind(this);\n    this.lastMessageEntriesById = this.lastMessageEntriesById.bind(this);\n    this.githubSignOut = this.githubSignOut.bind(this);\n    this.downloadLogAsCSV = this.downloadLogAsCSV.bind(this);\n    this.pandaReader = new Panda();\n    this.pandaReader.onMessage(this.processStreamedCanMessages);\n  }\n\n  componentDidMount() {\n    this.dataCacheTimer = interval(() => {\n      const {\n        currentParts\n      } = this.state;\n      let {\n        loadedParts\n      } = this.state;\n\n      if (this.loadMessagesFromCacheRunning || loadedParts.length < 4) {\n        return;\n      }\n\n      loadedParts.forEach(part => {\n        if (part >= currentParts[0] && part <= currentParts[1]) {\n          return;\n        }\n\n        if (Date.now() - dataCache[part].lastUsed > 3 * 60 * 1000) {\n          console.log('Decaching part', part);\n          loadedParts = loadedParts.filter(p => p !== part);\n          this.setState({\n            loadedParts\n          }, () => {\n            delete dataCache[part];\n          });\n        }\n      });\n    }, 10000);\n    const {\n      dongleId,\n      name\n    } = this.props;\n\n    if (CommaAuth.isAuthenticated() && !name) {\n      this.showOnboarding();\n    } else if (this.props.max && this.props.url && !this.props.exp && !this.props.sig) {\n      // legacy share? maybe dead code\n      const {\n        max,\n        url\n      } = this.props;\n      const startTime = Moment(name, 'YYYY-MM-DD--H-m-s');\n      const route = {\n        fullname: `${dongleId}|${name}`,\n        proclog: max,\n        url,\n        start_time: startTime\n      };\n      this.setState({\n        route,\n        currentParts: [0, Math.min(max, PART_SEGMENT_LENGTH - 1)]\n      }, this.initCanData);\n    } else if (dongleId && name) {\n      const routeName = `${dongleId}|${name}`;\n      let routePromise;\n      let logUrlsPromise;\n\n      if (this.props.url) {\n        routePromise = Promise.resolve({\n          maxqcamera: null,\n          url: this.props.url\n        });\n      } else {\n        routePromise = DrivesApi.getRouteInfo(routeName);\n      }\n\n      if (this.props.sig && this.props.exp) {\n        logUrlsPromise = RawDataApi.getRouteFiles(routeName, false, {\n          sig: this.props.sig,\n          exp: this.props.exp\n        });\n      } else {\n        logUrlsPromise = RawDataApi.getRouteFiles(routeName);\n      }\n\n      Promise.all([routePromise, logUrlsPromise]).then(initData => {\n        const [route, logFiles] = initData;\n        const logUrls = logFiles['logs'];\n        const newState = {\n          route: {\n            fullname: routeName,\n            proclog: logUrls.length - 1,\n            start_time: Moment(name, 'YYYY-MM-DD--H-m-s'),\n            url: route.url.replace('chffrprivate.blob.core.windows.net', 'chffrprivate.azureedge.net'),\n            maxqcamera: route.maxqcamera ? route.maxqcamera : logUrls.length - 1\n          },\n          currentParts: [0, Math.min(logUrls.length - 1, PART_SEGMENT_LENGTH - 1)],\n          logUrls\n        };\n        this.setState(newState, this.initCanData);\n\n        if (!this.props.sig || !this.props.exp) {\n          DrivesApi.getShareSignature(routeName).then(shareSignature => this.setState({\n            share: {\n              exp: shareSignature.exp,\n              sig: shareSignature.sig\n            },\n            shareUrl: modifyQueryParameters({\n              add: {\n                exp: shareSignature.exp,\n                sig: shareSignature.sig,\n                max: logUrls.length - 1,\n                url: route.url.replace('chffrprivate.blob.core.windows.net', 'chffrprivate.azureedge.net')\n              },\n              remove: [GITHUB_AUTH_TOKEN_KEY]\n            })\n          }));\n        } else {\n          this.setState({\n            share: {\n              exp: this.props.exp,\n              sig: this.props.sig\n            }\n          });\n        }\n      }).catch(err => {\n        console.log(err);\n        CommaAuthStorage.logOut().then(() => {\n          CommaAuthStorage.isAuthed = false;\n          this.showOnboarding();\n        });\n      });\n    } else {\n      this.showOnboarding();\n    }\n  }\n\n  componentWillUnmount() {\n    if (this.dataCacheTimer) {\n      this.dataCacheTimer();\n    }\n  }\n\n  initCanData() {\n    this.spawnWorker(this.state.currentParts);\n  }\n\n  onDbcSelected(dbcFilename, dbc) {\n    const {\n      route\n    } = this.state;\n    this.hideLoadDbc();\n    dbc.lastUpdated = Date.now();\n    this.persistDbc({\n      dbcFilename,\n      dbc\n    });\n\n    if (route) {\n      this.setState({\n        dbc,\n        dbcFilename,\n        dbcText: dbc.text(),\n        partsLoaded: 0,\n        selectedMessage: null,\n        messages: {}\n      }, () => {\n        this.loadMessagesFromCache();\n      });\n    } else {\n      this.setState({\n        dbc,\n        dbcFilename,\n        dbcText: dbc.text(),\n        messages: {}\n      });\n    }\n  }\n\n  onDbcSaved(dbcFilename) {\n    const dbcLastSaved = Moment();\n    this.setState({\n      dbcLastSaved,\n      dbcFilename\n    });\n    this.hideSaveDbc();\n  } // async downloadDbcFile() {\n  //   const blob = new Blob([this.props.dbc.text()], {type: \"text/plain;charset=utf-8\"});\n  //   const filename = this.state.dbcFilename.replace(/\\.dbc/g, '') + '.dbc';\n  //   FileSaver.saveAs(blob, filename, true);\n  // }\n\n\n  downloadLogAsCSV() {\n    console.log('downloadLogAsCSV:start');\n    const {\n      dbcFilename\n    } = this.state;\n    const fileStream = createWriteStream(`${dbcFilename.replace(/\\.dbc/g, '-')}${+new Date()}.csv`);\n    const writer = fileStream.getWriter();\n    const encoder = new TextEncoder();\n\n    if (this.state.live) {\n      return this.downloadLiveLogAsCSV(dataHandler);\n    }\n\n    return this.downloadRawLogAsCSV(dataHandler);\n\n    function dataHandler(e) {\n      const {\n        logData,\n        shouldClose,\n        progress\n      } = e.data;\n\n      if (shouldClose) {\n        console.log('downloadLogAsCSV:close');\n        writer.close();\n        return;\n      }\n\n      console.log('CSV export progress:', progress);\n      const uint8array = encoder.encode(`${logData}\\n`);\n      writer.write(uint8array);\n    }\n  }\n\n  downloadRawLogAsCSV(handler) {\n    return this.downloadLiveLogAsCSV(handler);\n  }\n\n  downloadLiveLogAsCSV(handler) {\n    // Trigger processing of in-memory data in worker\n    // this method *could* just fetch the data needed for the worked, but\n    // eventually this might be in it's own worker instead of the shared one\n    const {\n      firstCanTime,\n      canFrameOffset\n    } = this.state;\n    const worker = new LogCSVDownloader();\n    worker.onmessage = handler;\n    worker.postMessage({\n      data: Object.keys(this.state.messages).map(sourceId => {\n        const source = this.state.messages[sourceId];\n        return {\n          id: source.id,\n          bus: source.bus,\n          address: source.address,\n          entries: source.entries.slice()\n        };\n      }),\n      canStartTime: firstCanTime - canFrameOffset\n    });\n  }\n\n  mergeThumbnails(newThumbnails) {\n    const {\n      thumbnails\n    } = this.state;\n\n    if (!newThumbnails || !newThumbnails.length) {\n      return thumbnails;\n    }\n\n    if (!thumbnails.length) {\n      return newThumbnails;\n    }\n\n    let oldIndex = 0;\n    let newIndex = 0; // is old immediately after new?\n\n    if (newThumbnails[0].monoTime > thumbnails[thumbnails.length - 1]) {\n      return thumbnails.concat(newThumbnails);\n    } // is new immediately after old?\n\n\n    if (newThumbnails[newThumbnails.length - 1] < thumbnails[0]) {\n      return newThumbnails.concat(thumbnails);\n    }\n\n    let result = [];\n\n    while (oldIndex < thumbnails.length && newIndex < newThumbnails.length) {\n      if (thumbnails[oldIndex].monoTime < newThumbnails[newIndex].monoTime) {\n        result.push(thumbnails[oldIndex]);\n        oldIndex += 1;\n      } else {\n        result.push(newThumbnails[newIndex]);\n        newIndex += 1;\n      }\n    }\n\n    if (oldIndex < thumbnails.length) {\n      result = result.concat(thumbnails.slice(oldIndex));\n    } else if (newIndex < newThumbnails.length) {\n      result = result.concat(newThumbnails.slice(newIndex));\n    }\n\n    return result;\n  }\n\n  cancelWorker(workerHash) {\n    // actually don't...\n    return;\n  }\n\n  spawnWorker(options) {\n    let {\n      currentParts,\n      currentWorkers,\n      loadingParts\n    } = this.state;\n    console.log('Checking worker for', currentParts);\n\n    if (loadingParts.length > 1) {\n      // only 2 workers at a time pls\n      return;\n    }\n\n    const [minPart, maxPart] = currentParts; // updated worker list (post canceling, and this time a copy)\n\n    currentWorkers = { ...this.state.currentWorkers\n    };\n    const {\n      loadedParts,\n      currentPart\n    } = this.state;\n    let part = -1;\n    const allWorkerParts = loadingParts.concat(loadedParts);\n\n    for (let partOffset = 0; partOffset <= maxPart - minPart; ++partOffset) {\n      let tempPart = currentPart + partOffset;\n\n      if (tempPart > maxPart) {\n        tempPart = minPart + (tempPart - minPart) % (maxPart - minPart + 1);\n      }\n\n      if (allWorkerParts.indexOf(tempPart) === -1) {\n        part = tempPart;\n        break;\n      }\n    }\n\n    if (part === -1) {\n      return;\n    }\n\n    console.log('Starting worker for part', part); // options is object of {part, prevMsgEntries, spawnWorkerHash, prepend}\n\n    options = options || {};\n    let {\n      prevMsgEntries\n    } = options;\n    const prepend = false;\n    const {\n      dbc,\n      route,\n      firstCanTime,\n      canFrameOffset\n    } = this.state;\n    let {\n      maxByteStateChangeCount\n    } = this.state;\n\n    if (!prevMsgEntries) {\n      // we have previous messages loaded\n      const {\n        messages\n      } = this.state;\n      prevMsgEntries = {};\n      Object.keys(messages).forEach(key => {\n        const {\n          entries\n        } = messages[key];\n        prevMsgEntries[key] = entries[entries.length - 1];\n      });\n    } // var worker = new CanFetcher();\n\n\n    const worker = new RLogDownloader();\n    const spawnWorkerHash = hash(Math.random().toString(16));\n    currentWorkers[spawnWorkerHash] = {\n      part,\n      worker\n    };\n    loadingParts = [part, ...loadingParts];\n    this.setState({\n      currentWorkers,\n      loadingParts\n    });\n\n    worker.onmessage = e => {\n      if (this.state.currentWorkers[spawnWorkerHash] === undefined) {\n        console.log('Worker was canceled');\n        return;\n      }\n\n      maxByteStateChangeCount = e.data.maxByteStateChangeCount;\n      const {\n        newMessages,\n        newThumbnails,\n        isFinished,\n        routeInitTime,\n        firstFrameTime,\n        carParams\n      } = e.data;\n\n      if (maxByteStateChangeCount > this.state.maxByteStateChangeCount) {\n        this.setState({\n          maxByteStateChangeCount\n        });\n      } else {\n        maxByteStateChangeCount = this.state.maxByteStateChangeCount;\n      }\n\n      if (routeInitTime !== this.state.routeInitTime) {\n        this.setState({\n          routeInitTime\n        });\n      }\n\n      if (firstFrameTime && firstFrameTime !== this.state.firstFrameTime) {\n        this.setState({\n          firstFrameTime\n        });\n      }\n\n      if (carParams && carParams.CarFingerprint !== this.state.carFingerprint) {\n        this.setState({\n          carFingerprint: carParams.CarFingerprint\n        });\n\n        if (this.state.dbcFilename === NEW_DBC) {\n          const dbcFilename = DbcUtils.findDbcForCar(carParams.CarFingerprint);\n\n          if (dbcFilename) {\n            this.openDbcClient.getDbcContents(dbcFilename + '.dbc', 'commaai/opendbc').then(dbcText => {\n              this.onDbcSelected(dbcFilename, new DBC(dbcText));\n            });\n          }\n        }\n      }\n\n      if (newMessages) {\n        this.addMessagesToDataCache(part, newMessages, newThumbnails);\n      } // const messages = this.addAndRehydrateMessages(\n      //   newMessages,\n      //   maxByteStateChangeCount\n      // );\n      // const prevMsgEntries = {};\n      // Object.keys(newMessages).forEach((key) => {\n      //   prevMsgEntries[key] = newMessages[key].entries[newMessages[key].entries.length - 1];\n      // });\n      // const thumbnails = this.mergeThumbnails(newThumbnails);\n\n\n      if (isFinished) {\n        const loadingParts = this.state.loadingParts.filter(p => p !== part);\n        const loadedParts = [part, ...this.state.loadedParts];\n        this.setState({\n          partsLoaded: this.state.partsLoaded + 1,\n          loadingParts,\n          loadedParts\n        }, () => {\n          this.spawnWorker({\n            prevMsgEntries,\n            spawnWorkerHash,\n            prepend\n          });\n\n          if (window.dataCallback) {\n            window.dataCallback();\n            window.dataCallback = null;\n          }\n        });\n      }\n    };\n\n    worker.postMessage({\n      // old stuff for reverse compatibility for easier testing\n      base: route.url,\n      num: part,\n      // so that we don't try to read metadata about it...\n      isLegacyShare: this.props.isLegacyShare,\n      logUrls: this.state.logUrls,\n      // data that is used\n      dbcText: dbc.text(),\n      route: route.fullname,\n      part,\n      canStartTime: firstCanTime != null ? firstCanTime - canFrameOffset : null,\n      prevMsgEntries,\n      maxByteStateChangeCount\n    });\n  }\n\n  addAndRehydrateMessages(newMessages, options) {\n    // Adds new message entries to messages state\n    // and \"rehydrates\" ES6 classes (message frame)\n    // lost from JSON serialization in webworker data cloning.\n    // handles merging the data in correct order\n    options = options || {};\n    const messages = { ...this.state.messages\n    };\n    Object.keys(newMessages).forEach(key => {\n      // add message\n      if (options.replace !== true && key in messages) {\n        // should merge here instead of concat\n        // assumes messages are always sequential\n        const msgEntries = messages[key].entries;\n        const newMsgEntries = newMessages[key].entries;\n        const msgLength = msgEntries.length;\n        const newMsgLength = newMsgEntries.length;\n        const entryLength = msgLength + newMsgLength;\n        messages[key] = { ...messages[key],\n          entries: Array(entryLength)\n        };\n        let msgIndex = 0;\n        let newMsgIndex = 0;\n\n        for (let i = 0; i < entryLength; ++i) {\n          if (newMsgIndex >= newMsgLength) {\n            messages[key].entries[i] = msgEntries[msgIndex++];\n          } else if (msgIndex >= msgLength) {\n            messages[key].entries[i] = newMsgEntries[newMsgIndex++];\n          } else if (msgEntries[msgIndex].relTime <= newMsgEntries[newMsgIndex].relTime) {\n            messages[key].entries[i] = msgEntries[msgIndex++];\n          } else if (msgEntries[msgIndex].relTime >= newMsgEntries[newMsgIndex].relTime) {\n            messages[key].entries[i] = newMsgEntries[newMsgIndex++];\n          }\n        }\n\n        messages[key].byteStateChangeCounts = newMessages[key].byteStateChangeCounts;\n      } else {\n        messages[key] = newMessages[key];\n        messages[key].frame = this.state.dbc.getMessageFrame(messages[key].address);\n      }\n    });\n    const maxByteStateChangeCount = DbcUtils.findMaxByteStateChangeCount(messages);\n    this.setState({\n      maxByteStateChangeCount\n    });\n    Object.keys(messages).forEach(key => {\n      // console.log(key);\n      messages[key] = DbcUtils.setMessageByteColors(messages[key], maxByteStateChangeCount);\n    });\n    return messages;\n  }\n\n  async addMessagesToDataCache(part, newMessages, newThumbnails) {\n    const {\n      dbc,\n      currentParts\n    } = this.state;\n    const entry = await this.getParseSegment(part);\n\n    if (!entry) {\n      // first chunk of data returned from this segment\n      Object.keys(newMessages).forEach(key => {\n        newMessages[key] = this.parseMessageEntry(newMessages[key], dbc);\n      });\n      dataCache[part] = {\n        messages: newMessages,\n        thumbnails: newThumbnails,\n        lastUpdated: Date.now(),\n        lastUsed: Date.now()\n      };\n\n      if (part >= currentParts[0] && part <= currentParts[1]) {\n        this.setState({\n          messages: this.addAndRehydrateMessages(newMessages)\n        });\n      }\n\n      return;\n    }\n\n    entry.lastUsed = Date.now(); // data is always append only, and always per segment\n\n    Object.keys(newMessages).forEach(key => {\n      let msgs = newMessages[key];\n\n      if (!dataCache[part].messages[key]) {\n        msgs = this.parseMessageEntry(msgs, dbc);\n        dataCache[part].messages[key] = msgs;\n      } else {\n        let {\n          entries\n        } = dataCache[part].messages[key];\n        const lastEntry = entries.length ? entries[entries.length - 1] : null;\n        msgs = this.parseMessageEntry(msgs, dbc, lastEntry);\n        entries = entries.concat(msgs.entries);\n        dataCache[part].messages[key].entries = entries;\n      }\n\n      newMessages[key] = msgs;\n    });\n    dataCache[part].thumbnails = dataCache[part].thumbnails.concat(newThumbnails);\n\n    if (part >= currentParts[0] && part <= currentParts[1]) {\n      this.setState({\n        messages: this.addAndRehydrateMessages(newMessages)\n      });\n    }\n  }\n\n  async loadMessagesFromCache() {\n    // create a new messages object for state\n    if (this.loadMessagesFromCacheRunning) {\n      if (!this.loadMessagesFromCacheTimer) {\n        this.loadMessagesFromCacheTimer = timeout(() => this.loadMessagesFromCache(), 10);\n      }\n\n      return;\n    }\n\n    this.loadMessagesFromCacheRunning = true;\n\n    if (this.loadMessagesFromCacheTimer) {\n      this.loadMessagesFromCacheTimer();\n      this.loadMessagesFromCacheTimer = null;\n    }\n\n    const {\n      currentParts,\n      dbc\n    } = this.state;\n    const {\n      lastUpdated\n    } = dbc;\n    const [minPart, maxPart] = currentParts;\n    const messages = {};\n    let thumbnails = [];\n    let isCanceled = false;\n    let start = performance.now();\n    const promises = [];\n\n    for (let i = minPart, l = maxPart; i <= l; ++i) {\n      promises.push(this.getParseSegment(i));\n    }\n\n    await promises.reduce(async (prev, p) => {\n      await prev;\n\n      if (isCanceled) {\n        return;\n      }\n\n      const cacheEntry = await p;\n\n      if (this.state.dbc.lastUpdated !== lastUpdated) {\n        if (!isCanceled) {\n          isCanceled = true;\n          this.loadMessagesFromCacheRunning = false;\n          console.log('Canceling!');\n          this.loadMessagesFromCache();\n        }\n\n        return;\n      }\n\n      if (cacheEntry) {\n        const newMessages = cacheEntry.messages;\n        thumbnails = thumbnails.concat(cacheEntry.thumbnails);\n        Object.keys(newMessages).forEach(key => {\n          if (!messages[key]) {\n            messages[key] = { ...newMessages[key]\n            };\n          } else {\n            const newMessageEntries = newMessages[key].entries;\n            const messageEntries = messages[key].entries;\n\n            if (newMessageEntries.length && newMessageEntries[0].relTime < messageEntries[messageEntries.length - 1].relTime) {\n              console.error('Found out of order messages', newMessageEntries[0], messageEntries[messageEntries.length - 1]);\n            }\n\n            messages[key].entries = messages[key].entries.concat(newMessages[key].entries);\n          }\n        });\n      }\n\n      console.log('Done with', performance.now() - start);\n      start = performance.now();\n    }, Promise.resolve());\n\n    if (isCanceled) {\n      return;\n    }\n\n    Object.keys(this.state.messages).forEach(key => {\n      if (!messages[key]) {\n        messages[key] = this.state.messages[key];\n        messages[key].entries = [];\n      }\n    });\n    Object.keys(messages).forEach(key => {\n      messages[key].frame = dbc.getMessageFrame(messages[key].address);\n    });\n    const maxByteStateChangeCount = DbcUtils.findMaxByteStateChangeCount(messages);\n    this.setState({\n      maxByteStateChangeCount\n    });\n    Object.keys(messages).forEach(key => {\n      // console.log(key);\n      messages[key] = DbcUtils.setMessageByteColors(messages[key], maxByteStateChangeCount);\n    });\n    console.log('Done with old messages', performance.now() - start);\n    this.setState({\n      messages,\n      thumbnails\n    });\n    this.loadMessagesFromCacheRunning = false;\n  }\n\n  async getParseSegment(part) {\n    if (!dataCache[part]) {\n      return null;\n    }\n\n    if (dataCache[part].promise) {\n      await dataCache[part].promise;\n    }\n\n    dataCache[part].promise = this.getParseSegmentInternal(part);\n    return dataCache[part].promise;\n  }\n\n  async getParseSegmentInternal(part) {\n    const start = performance.now();\n    const {\n      dbc\n    } = this.state;\n\n    if (!dbc.lastUpdated) {\n      dbc.lastUpdated = Date.now();\n    }\n\n    const {\n      lastUpdated\n    } = dbc;\n    let {\n      messages\n    } = dataCache[part];\n    let reparseMessages = {}; // if (lastUpdated > dataCache[part].lastUpdated) {\n    //   dataCache[part].lastUpdated = Date.now();\n    //   return await this.reparseMessages(messages);\n    // }\n\n    Object.keys(messages).forEach(key => {\n      if (messages[key].lastUpdated >= lastUpdated) {\n        return;\n      }\n\n      reparseMessages[key] = messages[key];\n    });\n\n    if (Object.keys(reparseMessages).length) {\n      console.log('Reparsing messages!', Object.keys(reparseMessages).length);\n      reparseMessages = await this.reparseMessages(reparseMessages);\n    }\n\n    messages = { ...messages,\n      ...reparseMessages\n    };\n    dataCache[part].messages = messages;\n    const end = performance.now();\n\n    if (end - start > 200) {\n      // warn about anything over 200ms\n      console.warn('getParseSegment took', part, end - start, Object.keys(messages).length);\n    }\n\n    return dataCache[part];\n  }\n\n  decacheMessageId(messageId) {\n    Object.keys(dataCache).forEach(part => {\n      if (dataCache[part].messages[messageId]) {\n        dataCache[part].messages[messageId].lastUpdated = 0;\n      }\n    });\n  }\n\n  async reparseMessages(_messages) {\n    const messages = _messages;\n    const {\n      dbc\n    } = this.state;\n    dbc.lastUpdated = dbc.lastUpdated || Date.now();\n    Object.keys(messages).forEach(key => {\n      messages[key].frame = dbc.getMessageFrame(messages[key].address);\n    });\n    return new Promise((resolve, reject) => {\n      const worker = new MessageParser();\n\n      worker.onmessage = e => {\n        const newMessages = e.data.messages;\n        Object.keys(newMessages).forEach(key => {\n          newMessages[key].lastUpdated = dbc.lastUpdated;\n          newMessages[key].frame = dbc.getMessageFrame(newMessages[key].address);\n        });\n        resolve(newMessages);\n      };\n\n      worker.postMessage({\n        messages,\n        dbcText: dbc.text(),\n        canStartTime: this.state.firstCanTime\n      });\n    });\n  }\n\n  parseMessageEntry(_entry, dbc, lastMsg) {\n    const entry = _entry;\n    dbc.lastUpdated = dbc.lastUpdated || Date.now();\n    entry.lastUpdated = dbc.lastUpdated;\n    entry.frame = dbc.getMessageFrame(entry.address);\n    let prevMsgEntry = lastMsg || null;\n    const byteStateChangeCounts = []; // entry.messages[id].byteStateChangeCounts = byteStateChangeCounts.map(\n    //   (count, idx) => entry.messages[id].byteStateChangeCounts[idx] + count\n    // );\n\n    entry.entries = entry.entries.map(message => {\n      if (message.hexData) {\n        prevMsgEntry = DbcUtils.reparseMessage(dbc, message, prevMsgEntry);\n      } else {\n        prevMsgEntry = DbcUtils.parseMessage(dbc, message.time, message.address, message.data, message.timeStart, prevMsgEntry);\n      }\n\n      byteStateChangeCounts.push(prevMsgEntry.byteStateChangeCounts);\n      prevMsgEntry = prevMsgEntry.msgEntry;\n      return prevMsgEntry;\n    });\n    entry.byteStateChangeCounts = byteStateChangeCounts.reduce((memo, val) => {\n      if (!memo) {\n        return val;\n      }\n\n      return memo.map((count, idx) => val[idx] + count);\n    }, null);\n    return entry;\n  }\n\n  showingModal() {\n    const {\n      showOnboarding,\n      showLoadDbc,\n      showSaveDbc,\n      showAddSignal,\n      showEditMessageModal\n    } = this.state;\n    return showOnboarding || showLoadDbc || showSaveDbc || showAddSignal || showEditMessageModal;\n  }\n\n  showOnboarding() {\n    if (!CommaAuth.isAuthenticated() && window.sessionStorage && window.location && window.location.pathname !== AuthConfig.AUTH_PATH) {\n      window.sessionStorage.setItem('onboardingPath', window.location.href);\n    }\n\n    this.setState({\n      showOnboarding: true\n    });\n  }\n\n  hideOnboarding() {\n    this.setState({\n      showOnboarding: false\n    });\n  }\n\n  showLoadDbc() {\n    this.setState({\n      showLoadDbc: true\n    });\n  }\n\n  hideLoadDbc() {\n    this.setState({\n      showLoadDbc: false\n    });\n  }\n\n  showSaveDbc() {\n    this.setState({\n      showSaveDbc: true\n    });\n  }\n\n  hideSaveDbc() {\n    this.setState({\n      showSaveDbc: false\n    });\n  }\n\n  updateMessageFrame(messageId, frame) {\n    const {\n      messages\n    } = this.state;\n    messages[messageId].frame = frame;\n    this.setState({\n      messages\n    });\n  }\n\n  persistDbc(_ref) {\n    let {\n      dbcFilename,\n      dbc\n    } = _ref;\n    const {\n      route\n    } = this.state;\n\n    if (route) {\n      persistDbc(route.fullname, {\n        dbcFilename,\n        dbc\n      });\n    } else {\n      persistDbc('live', {\n        dbcFilename,\n        dbc\n      });\n    }\n\n    this.loadMessagesFromCache();\n  }\n\n  onConfirmedSignalChange(message, signals) {\n    const {\n      dbc,\n      dbcFilename\n    } = this.state;\n    const frameSize = DbcUtils.maxMessageSize(message);\n    dbc.setSignals(message.address, { ...signals\n    }, frameSize);\n    this.persistDbc({\n      dbcFilename,\n      dbc\n    });\n    this.updateMessageFrame(message.id, dbc.getMessageFrame(message.address));\n    this.setState({\n      dbc,\n      dbcText: dbc.text()\n    }, () => {\n      this.decacheMessageId(message.id);\n      this.loadMessagesFromCache();\n    });\n  }\n\n  onPartChange(part) {\n    let {\n      currentParts,\n      currentPart,\n      canFrameOffset,\n      route\n    } = this.state;\n\n    if (canFrameOffset === -1 || part === currentPart) {\n      return;\n    } // determine new parts to load, whether to prepend or append\n\n\n    let maxPart = Math.min(route.proclog, part + 1);\n    const minPart = Math.max(0, maxPart - PART_SEGMENT_LENGTH + 1);\n\n    if (minPart === 0) {\n      maxPart = Math.min(route.proclog, 2);\n    } // update current parts\n\n\n    currentParts = [minPart, maxPart];\n    currentPart = part;\n\n    if (currentPart !== this.state.currentPart || currentParts[0] !== this.state.currentParts[0] || currentParts[1] !== this.state.currentParts[1]) {\n      // update state then load new parts\n      this.setState({\n        currentParts,\n        currentPart\n      }, this.partChangeDebounced);\n    }\n  }\n\n  showEditMessageModal(msgKey) {\n    const msg = this.state.messages[msgKey];\n    console.log(msg);\n\n    if (!msg.frame) {\n      msg.frame = this.state.dbc.createFrame(msg.address); // TODO frameSize\n    }\n\n    this.setState({\n      showEditMessageModal: true,\n      editMessageModalMessage: msgKey,\n      messages: this.state.messages,\n      dbcText: this.state.dbc.text()\n    });\n  }\n\n  hideEditMessageModal() {\n    this.setState({\n      showEditMessageModal: false\n    });\n  }\n\n  onMessageFrameEdited(messageFrame) {\n    const {\n      messages,\n      dbcFilename,\n      dbc,\n      editMessageModalMessage\n    } = this.state;\n    const message = { ...messages[editMessageModalMessage]\n    };\n    message.frame = messageFrame;\n    dbc.messages.set(messageFrame.id, messageFrame);\n    this.persistDbc({\n      dbcFilename,\n      dbc\n    });\n    messages[editMessageModalMessage] = message;\n    this.setState({\n      messages,\n      dbc,\n      dbcText: dbc.text()\n    });\n    this.hideEditMessageModal();\n  }\n\n  onSeek(seekIndex, seekTime) {\n    this.setState({\n      seekIndex,\n      seekTime\n    });\n    const {\n      currentPart\n    } = this.state;\n    const part = ~~(seekTime / 60);\n\n    if (part !== currentPart) {\n      this.onPartChange(part);\n    }\n  }\n\n  onUserSeek(seekTime) {\n    if (USE_UNLOGGER) {\n      this.unloggerClient.seek(this.props.dongleId, this.props.name, seekTime);\n    }\n\n    const msg = this.state.messages[this.state.selectedMessage];\n    let seekIndex;\n\n    if (msg) {\n      seekIndex = msg.entries.findIndex(e => e.relTime >= seekTime);\n\n      if (seekIndex === -1) {\n        seekIndex = 0;\n      }\n    } else {\n      seekIndex = 0;\n    }\n\n    this.onSeek(seekIndex, seekTime);\n  }\n\n  onMessageSelected(msgKey) {\n    let {\n      seekTime,\n      seekIndex,\n      messages\n    } = this.state;\n    const msg = messages[msgKey];\n\n    if (seekTime > 0 && msg.entries.length > 0) {\n      seekIndex = msg.entries.findIndex(e => e.relTime >= seekTime);\n\n      if (seekIndex === -1) {\n        seekIndex = 0;\n      }\n\n      seekTime = msg.entries[seekIndex].relTime;\n    }\n\n    this.setState({\n      seekTime,\n      seekIndex,\n      selectedMessage: msgKey\n    });\n  }\n\n  updateSelectedMessages(selectedMessages) {\n    this.setState({\n      selectedMessages\n    });\n  }\n\n  onMessageUnselected(msgKey) {\n    this.setState({\n      selectedMessage: null\n    });\n  }\n\n  loginWithGithub() {\n    const {\n      route\n    } = this.state;\n    return /*#__PURE__*/React.createElement(\"a\", {\n      href: GithubAuth.authorizeUrl(route && route.fullname ? route.fullname : ''),\n      className: \"button button--dark button--inline\",\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 1132,\n        columnNumber: 7\n      }\n    }, /*#__PURE__*/React.createElement(\"i\", {\n      className: \"fa fa-github\",\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 1138,\n        columnNumber: 9\n      }\n    }), /*#__PURE__*/React.createElement(\"span\", {\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 1139,\n        columnNumber: 9\n      }\n    }, \" Log in with Github\"));\n  }\n\n  lastMessageEntriesById(obj, _ref2) {\n    let [msgId, message] = _ref2;\n    obj[msgId] = message.entries[message.entries.length - 1];\n    return obj;\n  }\n\n  processStreamedCanMessages(newCanMessages) {\n    const {\n      dbcText\n    } = this.state;\n    const {\n      firstCanTime,\n      lastBusTime,\n      messages,\n      maxByteStateChangeCount\n    } = this.state; // map msg id to arrays\n\n    const prevMsgEntries = Object.entries(messages).reduce(this.lastMessageEntriesById, {});\n    const byteStateChangeCountsByMessage = Object.entries(messages).reduce((obj, _ref3) => {\n      let [msgId, msg] = _ref3;\n      obj[msgId] = msg.byteStateChangeCounts;\n      return obj;\n    }, {});\n    this.canStreamerWorker.postMessage({\n      newCanMessages,\n      prevMsgEntries,\n      firstCanTime,\n      dbcText,\n      lastBusTime,\n      byteStateChangeCountsByMessage,\n      maxByteStateChangeCount\n    });\n  }\n\n  firstEntryIndexInsideStreamingWindow(entries) {\n    const lastEntryTime = entries[entries.length - 1].relTime;\n    const windowFloor = lastEntryTime - STREAMING_WINDOW;\n\n    for (let i = 0; i < entries.length; i++) {\n      if (entries[i].relTime > windowFloor) {\n        return i;\n      }\n    }\n\n    return 0;\n  }\n\n  enforceStreamingMessageWindow(messages) {\n    const messageIds = Object.keys(messages);\n\n    for (let i = 0; i < messageIds.length; i++) {\n      const messageId = messageIds[i];\n      const message = messages[messageId];\n\n      if (message.entries.length < 2) {\n        continue;\n      }\n\n      const lastEntryTime = message.entries[message.entries.length - 1].relTime;\n      const entrySpan = lastEntryTime - message.entries[0].relTime;\n\n      if (entrySpan > STREAMING_WINDOW) {\n        const newEntryFloor = this.firstEntryIndexInsideStreamingWindow(message.entries);\n        message.entries = message.entries.slice(newEntryFloor);\n        messages[messageId] = message;\n      }\n    }\n\n    return messages;\n  }\n\n  _onStreamedCanMessagesProcessed(data) {\n    let {\n      newMessages,\n      seekTime,\n      lastBusTime,\n      firstCanTime,\n      maxByteStateChangeCount\n    } = data;\n\n    if (maxByteStateChangeCount < this.state.maxByteStateChangeCount) {\n      maxByteStateChangeCount = this.state.maxByteStateChangeCount;\n    }\n\n    let messages = this.addAndRehydrateMessages(newMessages);\n    messages = this.enforceStreamingMessageWindow(messages);\n    let {\n      seekIndex,\n      selectedMessages\n    } = this.state;\n\n    if (selectedMessages.length > 0 && messages[selectedMessages[0]] !== undefined) {\n      seekIndex = Math.max(0, messages[selectedMessages[0]].entries.length - 1);\n    }\n\n    this.setState({\n      messages,\n      seekTime,\n      seekIndex,\n      lastBusTime,\n      firstCanTime,\n      maxByteStateChangeCount\n    });\n  }\n\n  onStreamedCanMessagesProcessed(e) {\n    this._onStreamedCanMessagesProcessed(e.data);\n  }\n\n  async handlePandaConnect(e) {\n    this.setState({\n      attemptingPandaConnection: true,\n      live: true\n    });\n    const persistedDbc = fetchPersistedDbc('live');\n\n    if (persistedDbc) {\n      const {\n        dbc,\n        dbcText\n      } = persistedDbc;\n      this.setState({\n        dbc,\n        dbcText\n      });\n    }\n\n    this.canStreamerWorker = new CanStreamerWorker();\n    this.canStreamerWorker.onmessage = this.onStreamedCanMessagesProcessed; // if any errors go off during connection, mark as not trying to connect anymore...\n\n    const unlisten = this.pandaReader.onError(err => {\n      console.error(err.stack || err);\n      this.setState({\n        attemptingPandaConnection: false\n      });\n    });\n\n    try {\n      await this.pandaReader.start();\n      this.setState({\n        showOnboarding: false,\n        showLoadDbc: true\n      });\n    } catch (e) {}\n\n    this.setState({\n      attemptingPandaConnection: false\n    });\n    unlisten();\n  }\n\n  githubSignOut(e, dataArray) {\n    unpersistGithubAuthToken();\n    this.setState({\n      isGithubAuthenticated: false\n    });\n    e.preventDefault();\n  }\n\n  render() {\n    const {\n      route,\n      messages,\n      selectedMessages,\n      currentParts,\n      dbcFilename,\n      dbcLastSaved,\n      seekTime,\n      seekIndex,\n      shareUrl,\n      maxByteStateChangeCount,\n      live,\n      thumbnails,\n      selectedMessage,\n      canFrameOffset,\n      firstCanTime,\n      currentPart,\n      partsLoaded,\n      share\n    } = this.state;\n    const {\n      startTime,\n      segments\n    } = this.props;\n    return /*#__PURE__*/React.createElement(\"div\", {\n      id: \"cabana\",\n      className: cx({\n        'is-showing-modal': this.showingModal()\n      }),\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 1313,\n        columnNumber: 7\n      }\n    }, /*#__PURE__*/React.createElement(\"div\", {\n      className: \"cabana-header\",\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 1317,\n        columnNumber: 9\n      }\n    }, /*#__PURE__*/React.createElement(\"a\", {\n      className: \"cabana-header-logo\",\n      href: \"/\",\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 1318,\n        columnNumber: 11\n      }\n    }, \"Comma Cabana\"), /*#__PURE__*/React.createElement(\"div\", {\n      className: \"cabana-header-account\",\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 1321,\n        columnNumber: 11\n      }\n    }, this.state.isGithubAuthenticated ? /*#__PURE__*/React.createElement(\"div\", {\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 1323,\n        columnNumber: 15\n      }\n    }, /*#__PURE__*/React.createElement(\"p\", {\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 1324,\n        columnNumber: 17\n      }\n    }, \"GitHub Authenticated\"), /*#__PURE__*/React.createElement(\"p\", {\n      className: \"cabana-header-account-signout\",\n      onClick: this.githubSignOut,\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 1325,\n        columnNumber: 17\n      }\n    }, \"Sign out\")) : this.loginWithGithub())), /*#__PURE__*/React.createElement(\"div\", {\n      className: \"cabana-window\",\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 1337,\n        columnNumber: 9\n      }\n    }, /*#__PURE__*/React.createElement(Meta, {\n      url: this.state.route ? route.url : null,\n      messages: messages,\n      selectedMessages: selectedMessages,\n      updateSelectedMessages: this.updateSelectedMessages,\n      showEditMessageModal: this.showEditMessageModal,\n      currentParts: currentParts,\n      onMessageSelected: this.onMessageSelected,\n      onMessageUnselected: this.onMessageUnselected,\n      showLoadDbc: this.showLoadDbc,\n      showSaveDbc: this.showSaveDbc,\n      dbcFilename: dbcFilename,\n      dbcLastSaved: dbcLastSaved,\n      dongleId: this.props.dongleId,\n      name: this.props.name,\n      route: route,\n      seekTime: seekTime,\n      seekIndex: seekIndex,\n      shareUrl: shareUrl,\n      maxByteStateChangeCount: maxByteStateChangeCount,\n      live: live,\n      saveLog: debounce(this.downloadLogAsCSV, 500),\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 1338,\n        columnNumber: 11\n      }\n    }), route || live ? /*#__PURE__*/React.createElement(Explorer, {\n      url: route ? route.url : null,\n      live: live,\n      messages: messages,\n      thumbnails: thumbnails,\n      selectedMessage: selectedMessage,\n      onConfirmedSignalChange: this.onConfirmedSignalChange,\n      onSeek: this.onSeek,\n      onUserSeek: this.onUserSeek,\n      canFrameOffset: canFrameOffset,\n      firstCanTime: firstCanTime,\n      seekTime: seekTime,\n      startTime: startTime,\n      startSegments: segments,\n      seekIndex: seekIndex,\n      currentParts: currentParts,\n      selectedPart: currentPart,\n      partsLoaded: partsLoaded,\n      autoplay: this.props.autoplay,\n      showEditMessageModal: this.showEditMessageModal,\n      onPartChange: this.onPartChange,\n      routeStartTime: route ? route.start_time : Moment(),\n      videoOffset: this.state.firstFrameTime && this.state.routeInitTime ? this.state.firstFrameTime - this.state.routeInitTime : 0,\n      partsCount: route ? route.proclog : 0,\n      maxqcamera: route ? route.maxqcamera : 0,\n      route: route,\n      share: share,\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 1362,\n        columnNumber: 13\n      }\n    }) : null), this.state.showOnboarding ? /*#__PURE__*/React.createElement(OnboardingModal, {\n      handlePandaConnect: this.handlePandaConnect,\n      attemptingPandaConnection: this.state.attemptingPandaConnection,\n      routes: this.state.routes,\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 1396,\n        columnNumber: 11\n      }\n    }) : null, this.state.showLoadDbc ? /*#__PURE__*/React.createElement(LoadDbcModal, {\n      onDbcSelected: this.onDbcSelected,\n      handleClose: this.hideLoadDbc,\n      openDbcClient: this.openDbcClient,\n      loginWithGithub: this.loginWithGithub(),\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 1404,\n        columnNumber: 11\n      }\n    }) : null, this.state.showSaveDbc ? /*#__PURE__*/React.createElement(SaveDbcModal, {\n      dbc: this.state.dbc,\n      sourceDbcFilename: this.state.dbcFilename,\n      onDbcSaved: this.onDbcSaved,\n      handleClose: this.hideSaveDbc,\n      openDbcClient: this.openDbcClient,\n      hasGithubAuth: this.props.githubAuthToken !== null,\n      loginWithGithub: this.loginWithGithub(),\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 1413,\n        columnNumber: 11\n      }\n    }) : null, this.state.showEditMessageModal ? /*#__PURE__*/React.createElement(EditMessageModal, {\n      handleClose: this.hideEditMessageModal,\n      handleSave: this.onMessageFrameEdited,\n      message: this.state.messages[this.state.editMessageModalMessage],\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 1425,\n        columnNumber: 11\n      }\n    }) : null);\n  }\n\n}\nCanExplorer.propTypes = {\n  dongleId: PropTypes.string,\n  name: PropTypes.string,\n  dbc: PropTypes.instanceOf(DBC),\n  dbcFilename: PropTypes.string,\n  githubAuthToken: PropTypes.string,\n  autoplay: PropTypes.bool,\n  max: PropTypes.number,\n  url: PropTypes.string,\n  startTime: PropTypes.number,\n  segments: PropTypes.array\n};","map":{"version":3,"sources":["/home/amax/Autoro/cabana/src/CanExplorer.js"],"names":["React","Component","Moment","PropTypes","cx","createWriteStream","Panda","CommaAuth","storage","CommaAuthStorage","config","AuthConfig","raw","RawDataApi","drives","DrivesApi","timeout","interval","USE_UNLOGGER","PART_SEGMENT_LENGTH","STREAMING_WINDOW","GITHUB_AUTH_TOKEN_KEY","GithubAuth","DBC","Meta","Explorer","OnboardingModal","SaveDbcModal","LoadDbcModal","debounce","EditMessageModal","persistDbc","fetchPersistedDbc","unpersistGithubAuthToken","OpenDbc","UnloggerClient","hash","modifyQueryParameters","DbcUtils","NEW_DBC","RLogDownloader","require","LogCSVDownloader","MessageParser","CanStreamerWorker","dataCache","CanExplorer","constructor","props","partChangeDebounced","loadMessagesFromCache","spawnWorker","state","messages","thumbnails","selectedMessages","route","canFrameOffset","routeInitTime","firstFrameTime","carFingerprint","firstCanTime","lastBusTime","selectedMessage","currentParts","currentPart","currentWorkers","loadingParts","loadedParts","showOnboarding","showLoadDbc","showSaveDbc","showEditMessageModal","editMessageModalMessage","dbc","dbcText","text","dbcFilename","dbcLastSaved","seekTime","seekIndex","maxByteStateChangeCount","partsLoaded","spawnWorkerHash","attemptingPandaConnection","pandaNoDeviceSelected","live","isGithubAuthenticated","githubAuthToken","undefined","shareUrl","logUrls","share","openDbcClient","unloggerClient","bind","hideOnboarding","hideLoadDbc","hideSaveDbc","hideEditMessageModal","onDbcSelected","onDbcSaved","onConfirmedSignalChange","onPartChange","onMessageFrameEdited","onSeek","onUserSeek","onMessageSelected","onMessageUnselected","initCanData","updateSelectedMessages","handlePandaConnect","processStreamedCanMessages","onStreamedCanMessagesProcessed","showingModal","lastMessageEntriesById","githubSignOut","downloadLogAsCSV","pandaReader","onMessage","componentDidMount","dataCacheTimer","loadMessagesFromCacheRunning","length","forEach","part","Date","now","lastUsed","console","log","filter","p","setState","dongleId","name","isAuthenticated","max","url","exp","sig","startTime","fullname","proclog","start_time","Math","min","routeName","routePromise","logUrlsPromise","Promise","resolve","maxqcamera","getRouteInfo","getRouteFiles","all","then","initData","logFiles","newState","replace","getShareSignature","shareSignature","add","remove","catch","err","logOut","isAuthed","componentWillUnmount","lastUpdated","fileStream","writer","getWriter","encoder","TextEncoder","downloadLiveLogAsCSV","dataHandler","downloadRawLogAsCSV","e","logData","shouldClose","progress","data","close","uint8array","encode","write","handler","worker","onmessage","postMessage","Object","keys","map","sourceId","source","id","bus","address","entries","slice","canStartTime","mergeThumbnails","newThumbnails","oldIndex","newIndex","monoTime","concat","result","push","cancelWorker","workerHash","options","minPart","maxPart","allWorkerParts","partOffset","tempPart","indexOf","prevMsgEntries","prepend","key","random","toString","newMessages","isFinished","carParams","CarFingerprint","findDbcForCar","getDbcContents","addMessagesToDataCache","window","dataCallback","base","num","isLegacyShare","addAndRehydrateMessages","msgEntries","newMsgEntries","msgLength","newMsgLength","entryLength","Array","msgIndex","newMsgIndex","i","relTime","byteStateChangeCounts","frame","getMessageFrame","findMaxByteStateChangeCount","setMessageByteColors","entry","getParseSegment","parseMessageEntry","msgs","lastEntry","loadMessagesFromCacheTimer","isCanceled","start","performance","promises","l","reduce","prev","cacheEntry","newMessageEntries","messageEntries","error","promise","getParseSegmentInternal","reparseMessages","end","warn","decacheMessageId","messageId","_messages","reject","_entry","lastMsg","prevMsgEntry","message","hexData","reparseMessage","parseMessage","time","timeStart","msgEntry","memo","val","count","idx","showAddSignal","sessionStorage","location","pathname","AUTH_PATH","setItem","href","updateMessageFrame","signals","frameSize","maxMessageSize","setSignals","msgKey","msg","createFrame","messageFrame","set","seek","findIndex","loginWithGithub","authorizeUrl","obj","msgId","newCanMessages","byteStateChangeCountsByMessage","canStreamerWorker","firstEntryIndexInsideStreamingWindow","lastEntryTime","windowFloor","enforceStreamingMessageWindow","messageIds","entrySpan","newEntryFloor","_onStreamedCanMessagesProcessed","persistedDbc","unlisten","onError","stack","dataArray","preventDefault","render","segments","autoplay","routes","propTypes","string","instanceOf","bool","number","array"],"mappings":"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","sourcesContent":["import React, { Component } from 'react';\nimport Moment from 'moment';\nimport PropTypes from 'prop-types';\nimport cx from 'classnames';\nimport { createWriteStream } from 'streamsaver';\nimport Panda from '@commaai/pandajs';\nimport CommaAuth, { storage as CommaAuthStorage, config as AuthConfig } from '@commaai/my-comma-auth';\nimport { raw as RawDataApi, drives as DrivesApi } from '@commaai/comma-api';\nimport { timeout, interval } from 'thyming';\nimport {\n  USE_UNLOGGER,\n  PART_SEGMENT_LENGTH,\n  STREAMING_WINDOW,\n  GITHUB_AUTH_TOKEN_KEY\n} from './config';\nimport * as GithubAuth from './api/github-auth';\n\nimport DBC from './models/can/dbc';\nimport Meta from './components/Meta';\nimport Explorer from './components/Explorer';\nimport OnboardingModal from './components/Modals/OnboardingModal';\nimport SaveDbcModal from './components/SaveDbcModal';\nimport LoadDbcModal from './components/LoadDbcModal';\nimport debounce from './utils/debounce';\nimport EditMessageModal from './components/EditMessageModal';\nimport {\n  persistDbc,\n  fetchPersistedDbc,\n  unpersistGithubAuthToken\n} from './api/localstorage';\nimport OpenDbc from './api/OpenDbc';\nimport UnloggerClient from './api/unlogger';\nimport { hash } from './utils/string';\nimport { modifyQueryParameters } from './utils/url';\nimport DbcUtils from './utils/dbc';\n\nconst NEW_DBC = 'New_DBC';\n\nconst RLogDownloader = require('./workers/rlog-downloader.worker');\nconst LogCSVDownloader = require('./workers/dbc-csv-downloader.worker');\nconst MessageParser = require('./workers/message-parser.worker');\nconst CanStreamerWorker = require('./workers/CanStreamerWorker.worker');\n\nconst dataCache = {};\n\n\nexport default class CanExplorer extends Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      messages: {},\n      thumbnails: [],\n      selectedMessages: [],\n      route: null,\n      canFrameOffset: 0,\n      routeInitTime: 0,\n      firstFrameTime: 0,\n      carFingerprint: null,\n      firstCanTime: null,\n      lastBusTime: null,\n      selectedMessage: null,\n      currentParts: [0, 0],\n      currentPart: 0,\n      currentWorkers: {},\n      loadingParts: [],\n      loadedParts: [],\n      showOnboarding: false,\n      showLoadDbc: false,\n      showSaveDbc: false,\n      showEditMessageModal: false,\n      editMessageModalMessage: null,\n      dbc: props.dbc ? props.dbc : new DBC(),\n      dbcText: props.dbc ? props.dbc.text() : new DBC().text(),\n      dbcFilename: props.dbcFilename ? props.dbcFilename : NEW_DBC,\n      dbcLastSaved: null,\n      seekTime: props.seekTime || 0,\n      seekIndex: 0,\n      maxByteStateChangeCount: 0,\n      partsLoaded: 0,\n      spawnWorkerHash: null,\n      attemptingPandaConnection: false,\n      pandaNoDeviceSelected: false,\n      live: false,\n      isGithubAuthenticated:\n        props.githubAuthToken !== null && props.githubAuthToken !== undefined,\n      shareUrl: null,\n      logUrls: null,\n      share: null,\n    };\n\n    this.openDbcClient = new OpenDbc(props.githubAuthToken);\n    if (USE_UNLOGGER) {\n      this.unloggerClient = new UnloggerClient();\n    }\n\n    this.showOnboarding = this.showOnboarding.bind(this);\n    this.hideOnboarding = this.hideOnboarding.bind(this);\n    this.showLoadDbc = this.showLoadDbc.bind(this);\n    this.hideLoadDbc = this.hideLoadDbc.bind(this);\n    this.showSaveDbc = this.showSaveDbc.bind(this);\n    this.hideSaveDbc = this.hideSaveDbc.bind(this);\n    this.showEditMessageModal = this.showEditMessageModal.bind(this);\n    this.hideEditMessageModal = this.hideEditMessageModal.bind(this);\n    this.onDbcSelected = this.onDbcSelected.bind(this);\n    this.onDbcSaved = this.onDbcSaved.bind(this);\n    this.onConfirmedSignalChange = this.onConfirmedSignalChange.bind(this);\n    this.onPartChange = this.onPartChange.bind(this);\n    this.onMessageFrameEdited = this.onMessageFrameEdited.bind(this);\n    this.onSeek = this.onSeek.bind(this);\n    this.onUserSeek = this.onUserSeek.bind(this);\n    this.onMessageSelected = this.onMessageSelected.bind(this);\n    this.onMessageUnselected = this.onMessageUnselected.bind(this);\n    this.initCanData = this.initCanData.bind(this);\n    this.updateSelectedMessages = this.updateSelectedMessages.bind(this);\n    this.handlePandaConnect = this.handlePandaConnect.bind(this);\n    this.processStreamedCanMessages = this.processStreamedCanMessages.bind(\n      this\n    );\n    this.onStreamedCanMessagesProcessed = this.onStreamedCanMessagesProcessed.bind(\n      this\n    );\n    this.showingModal = this.showingModal.bind(this);\n    this.lastMessageEntriesById = this.lastMessageEntriesById.bind(this);\n    this.githubSignOut = this.githubSignOut.bind(this);\n    this.downloadLogAsCSV = this.downloadLogAsCSV.bind(this);\n\n    this.pandaReader = new Panda();\n    this.pandaReader.onMessage(this.processStreamedCanMessages);\n  }\n\n  componentDidMount() {\n    this.dataCacheTimer = interval(() => {\n      const { currentParts } = this.state;\n      let { loadedParts } = this.state;\n      if (this.loadMessagesFromCacheRunning || loadedParts.length < 4) {\n        return;\n      }\n      loadedParts.forEach((part) => {\n        if (part >= currentParts[0] && part <= currentParts[1]) {\n          return;\n        }\n        if (Date.now() - dataCache[part].lastUsed > 3 * 60 * 1000) {\n          console.log('Decaching part', part);\n          loadedParts = loadedParts.filter((p) => p !== part);\n          this.setState({\n            loadedParts\n          }, () => { delete dataCache[part]; });\n        }\n      });\n    }, 10000);\n\n    const { dongleId, name } = this.props;\n    if (CommaAuth.isAuthenticated() && !name) {\n      this.showOnboarding();\n    } else if (\n      this.props.max\n      && this.props.url\n      && !this.props.exp\n      && !this.props.sig\n    ) {\n      // legacy share? maybe dead code\n      const { max, url } = this.props;\n      const startTime = Moment(name, 'YYYY-MM-DD--H-m-s');\n\n      const route = {\n        fullname: `${dongleId}|${name}`,\n        proclog: max,\n        url,\n        start_time: startTime\n      };\n      this.setState(\n        {\n          route,\n          currentParts: [0, Math.min(max, PART_SEGMENT_LENGTH - 1)]\n        },\n        this.initCanData\n      );\n    } else if (dongleId && name) {\n      const routeName = `${dongleId}|${name}`;\n      let routePromise;\n      let logUrlsPromise;\n\n      if (this.props.url) {\n        routePromise = Promise.resolve({\n          maxqcamera: null,\n          url: this.props.url,\n        });\n      } else {\n        routePromise = DrivesApi.getRouteInfo(routeName);\n      }\n\n      if (this.props.sig && this.props.exp) {\n        logUrlsPromise = RawDataApi.getRouteFiles(routeName, false, {\n          sig: this.props.sig,\n          exp: this.props.exp\n        });\n      } else {\n        logUrlsPromise = RawDataApi.getRouteFiles(routeName);\n      }\n      Promise.all([routePromise, logUrlsPromise])\n        .then((initData) => {\n          const [route, logFiles] = initData;\n          const logUrls = logFiles['logs'];\n          const newState = {\n            route: {\n              fullname: routeName,\n              proclog: logUrls.length - 1,\n              start_time: Moment(name, 'YYYY-MM-DD--H-m-s'),\n              url: route.url.replace('chffrprivate.blob.core.windows.net', 'chffrprivate.azureedge.net'),\n              maxqcamera: route.maxqcamera ? route.maxqcamera : logUrls.length - 1,\n            },\n            currentParts: [\n              0,\n              Math.min(logUrls.length - 1, PART_SEGMENT_LENGTH - 1)\n            ],\n            logUrls\n          };\n          this.setState(newState, this.initCanData);\n\n          if (!this.props.sig || !this.props.exp) {\n            DrivesApi.getShareSignature(routeName).then((shareSignature) => this.setState({\n              share: {\n                exp: shareSignature.exp,\n                sig: shareSignature.sig,\n              },\n              shareUrl: modifyQueryParameters({\n                add: {\n                  exp: shareSignature.exp,\n                  sig: shareSignature.sig,\n                  max: logUrls.length - 1,\n                  url: route.url.replace('chffrprivate.blob.core.windows.net', 'chffrprivate.azureedge.net'),\n                },\n                remove: [GITHUB_AUTH_TOKEN_KEY]\n              })\n            }));\n          } else {\n            this.setState({\n              share: {\n                exp: this.props.exp,\n                sig: this.props.sig,\n              },\n            });\n          }\n        })\n        .catch((err) => {\n          console.log(err);\n          CommaAuthStorage.logOut().then(() => {\n            CommaAuthStorage.isAuthed = false;\n            this.showOnboarding();\n          });\n        });\n    } else {\n      this.showOnboarding();\n    }\n  }\n\n  componentWillUnmount() {\n    if (this.dataCacheTimer) {\n      this.dataCacheTimer();\n    }\n  }\n\n  initCanData() {\n    this.spawnWorker(this.state.currentParts);\n  }\n\n  onDbcSelected(dbcFilename, dbc) {\n    const { route } = this.state;\n    this.hideLoadDbc();\n    dbc.lastUpdated = Date.now();\n    this.persistDbc({ dbcFilename, dbc });\n\n    if (route) {\n      this.setState(\n        {\n          dbc,\n          dbcFilename,\n          dbcText: dbc.text(),\n          partsLoaded: 0,\n          selectedMessage: null,\n          messages: {}\n        },\n        () => {\n          this.loadMessagesFromCache();\n        }\n      );\n    } else {\n      this.setState({\n        dbc,\n        dbcFilename,\n        dbcText: dbc.text(),\n        messages: {}\n      });\n    }\n  }\n\n  onDbcSaved(dbcFilename) {\n    const dbcLastSaved = Moment();\n    this.setState({ dbcLastSaved, dbcFilename });\n    this.hideSaveDbc();\n  }\n\n  // async downloadDbcFile() {\n  //   const blob = new Blob([this.props.dbc.text()], {type: \"text/plain;charset=utf-8\"});\n  //   const filename = this.state.dbcFilename.replace(/\\.dbc/g, '') + '.dbc';\n  //   FileSaver.saveAs(blob, filename, true);\n  // }\n\n  downloadLogAsCSV() {\n    console.log('downloadLogAsCSV:start');\n    const { dbcFilename } = this.state;\n    const fileStream = createWriteStream(\n      `${dbcFilename.replace(/\\.dbc/g, '-')}${+new Date()}.csv`\n    );\n    const writer = fileStream.getWriter();\n    const encoder = new TextEncoder();\n\n    if (this.state.live) {\n      return this.downloadLiveLogAsCSV(dataHandler);\n    }\n    return this.downloadRawLogAsCSV(dataHandler);\n\n    function dataHandler(e) {\n      const { logData, shouldClose, progress } = e.data;\n      if (shouldClose) {\n        console.log('downloadLogAsCSV:close');\n        writer.close();\n        return;\n      }\n      console.log('CSV export progress:', progress);\n      const uint8array = encoder.encode(`${logData}\\n`);\n      writer.write(uint8array);\n    }\n  }\n\n  downloadRawLogAsCSV(handler) {\n    return this.downloadLiveLogAsCSV(handler);\n  }\n\n  downloadLiveLogAsCSV(handler) {\n    // Trigger processing of in-memory data in worker\n    // this method *could* just fetch the data needed for the worked, but\n    // eventually this might be in it's own worker instead of the shared one\n    const { firstCanTime, canFrameOffset } = this.state;\n    const worker = new LogCSVDownloader();\n\n    worker.onmessage = handler;\n\n    worker.postMessage({\n      data: Object.keys(this.state.messages).map((sourceId) => {\n        const source = this.state.messages[sourceId];\n        return {\n          id: source.id,\n          bus: source.bus,\n          address: source.address,\n          entries: source.entries.slice()\n        };\n      }),\n      canStartTime: firstCanTime - canFrameOffset\n    });\n  }\n\n  mergeThumbnails(newThumbnails) {\n    const { thumbnails } = this.state;\n    if (!newThumbnails || !newThumbnails.length) {\n      return thumbnails;\n    }\n    if (!thumbnails.length) {\n      return newThumbnails;\n    }\n\n    let oldIndex = 0;\n    let newIndex = 0;\n\n    // is old immediately after new?\n    if (newThumbnails[0].monoTime > thumbnails[thumbnails.length - 1]) {\n      return thumbnails.concat(newThumbnails);\n    }\n    // is new immediately after old?\n    if (newThumbnails[newThumbnails.length - 1] < thumbnails[0]) {\n      return newThumbnails.concat(thumbnails);\n    }\n    let result = [];\n    while (oldIndex < thumbnails.length && newIndex < newThumbnails.length) {\n      if (thumbnails[oldIndex].monoTime < newThumbnails[newIndex].monoTime) {\n        result.push(thumbnails[oldIndex]);\n        oldIndex += 1;\n      } else {\n        result.push(newThumbnails[newIndex]);\n        newIndex += 1;\n      }\n    }\n    if (oldIndex < thumbnails.length) {\n      result = result.concat(thumbnails.slice(oldIndex));\n    } else if (newIndex < newThumbnails.length) {\n      result = result.concat(newThumbnails.slice(newIndex));\n    }\n\n    return result;\n  }\n\n  cancelWorker(workerHash) {\n    // actually don't...\n    return;\n  }\n\n  spawnWorker(options) {\n    let { currentParts, currentWorkers, loadingParts } = this.state;\n    console.log('Checking worker for', currentParts);\n    if (loadingParts.length > 1) {\n      // only 2 workers at a time pls\n      return;\n    }\n    const [minPart, maxPart] = currentParts;\n\n    // updated worker list (post canceling, and this time a copy)\n    currentWorkers = { ...this.state.currentWorkers };\n\n    const { loadedParts, currentPart } = this.state;\n\n    let part = -1;\n    const allWorkerParts = loadingParts.concat(loadedParts);\n\n    for (let partOffset = 0; partOffset <= maxPart - minPart; ++partOffset) {\n      let tempPart = currentPart + partOffset;\n      if (tempPart > maxPart) {\n        tempPart = minPart + ((tempPart - minPart) % (maxPart - minPart + 1));\n      }\n      if (allWorkerParts.indexOf(tempPart) === -1) {\n        part = tempPart;\n        break;\n      }\n    }\n    if (part === -1) {\n      return;\n    }\n\n    console.log('Starting worker for part', part);\n    // options is object of {part, prevMsgEntries, spawnWorkerHash, prepend}\n    options = options || {};\n    let { prevMsgEntries } = options;\n    const prepend = false;\n\n    const {\n      dbc,\n      route,\n      firstCanTime,\n      canFrameOffset\n    } = this.state;\n    let { maxByteStateChangeCount } = this.state;\n\n    if (!prevMsgEntries) {\n      // we have previous messages loaded\n      const { messages } = this.state;\n      prevMsgEntries = {};\n      Object.keys(messages).forEach((key) => {\n        const { entries } = messages[key];\n        prevMsgEntries[key] = entries[entries.length - 1];\n      });\n    }\n\n    // var worker = new CanFetcher();\n    const worker = new RLogDownloader();\n\n    const spawnWorkerHash = hash(Math.random().toString(16));\n    currentWorkers[spawnWorkerHash] = {\n      part,\n      worker\n    };\n\n    loadingParts = [part, ...loadingParts];\n\n    this.setState({\n      currentWorkers,\n      loadingParts\n    });\n\n    worker.onmessage = (e) => {\n      if (this.state.currentWorkers[spawnWorkerHash] === undefined) {\n        console.log('Worker was canceled');\n        return;\n      }\n\n      maxByteStateChangeCount = e.data.maxByteStateChangeCount;\n      const {\n        newMessages,\n        newThumbnails,\n        isFinished,\n        routeInitTime,\n        firstFrameTime,\n        carParams,\n      } = e.data;\n      if (maxByteStateChangeCount > this.state.maxByteStateChangeCount) {\n        this.setState({ maxByteStateChangeCount });\n      } else {\n        maxByteStateChangeCount = this.state.maxByteStateChangeCount;\n      }\n      if (routeInitTime !== this.state.routeInitTime) {\n        this.setState({ routeInitTime });\n      }\n      if (firstFrameTime && firstFrameTime !== this.state.firstFrameTime) {\n        this.setState({ firstFrameTime });\n      }\n      if (carParams && carParams.CarFingerprint !== this.state.carFingerprint) {\n        this.setState({ carFingerprint: carParams.CarFingerprint });\n\n        if (this.state.dbcFilename === NEW_DBC) {\n          const dbcFilename = DbcUtils.findDbcForCar(carParams.CarFingerprint);\n          if (dbcFilename) {\n            this.openDbcClient.getDbcContents(dbcFilename + '.dbc', 'commaai/opendbc').then((dbcText) => {\n              this.onDbcSelected(dbcFilename, new DBC(dbcText));\n            });\n          }\n        }\n      }\n\n      if (newMessages) {\n        this.addMessagesToDataCache(part, newMessages, newThumbnails);\n      }\n\n      // const messages = this.addAndRehydrateMessages(\n      //   newMessages,\n      //   maxByteStateChangeCount\n      // );\n      // const prevMsgEntries = {};\n      // Object.keys(newMessages).forEach((key) => {\n      //   prevMsgEntries[key] = newMessages[key].entries[newMessages[key].entries.length - 1];\n      // });\n\n      // const thumbnails = this.mergeThumbnails(newThumbnails);\n\n      if (isFinished) {\n        const loadingParts = this.state.loadingParts.filter((p) => p !== part);\n        const loadedParts = [part, ...this.state.loadedParts];\n\n        this.setState(\n          {\n            partsLoaded: this.state.partsLoaded + 1,\n            loadingParts,\n            loadedParts\n          },\n          () => {\n            this.spawnWorker({\n              prevMsgEntries,\n              spawnWorkerHash,\n              prepend\n            });\n            if (window.dataCallback) {\n              window.dataCallback();\n              window.dataCallback = null;\n            }\n          }\n        );\n      }\n    };\n\n    worker.postMessage({\n      // old stuff for reverse compatibility for easier testing\n      base: route.url,\n      num: part,\n\n      // so that we don't try to read metadata about it...\n      isLegacyShare: this.props.isLegacyShare,\n      logUrls: this.state.logUrls,\n\n      // data that is used\n      dbcText: dbc.text(),\n      route: route.fullname,\n      part,\n      canStartTime: firstCanTime != null ? firstCanTime - canFrameOffset : null,\n      prevMsgEntries,\n      maxByteStateChangeCount\n    });\n  }\n\n  addAndRehydrateMessages(newMessages, options) {\n    // Adds new message entries to messages state\n    // and \"rehydrates\" ES6 classes (message frame)\n    // lost from JSON serialization in webworker data cloning.\n    // handles merging the data in correct order\n    options = options || {};\n\n    const messages = { ...this.state.messages };\n\n    Object.keys(newMessages).forEach((key) => {\n      // add message\n      if (options.replace !== true && key in messages) {\n        // should merge here instead of concat\n        // assumes messages are always sequential\n        const msgEntries = messages[key].entries;\n        const newMsgEntries = newMessages[key].entries;\n        const msgLength = msgEntries.length;\n        const newMsgLength = newMsgEntries.length;\n        const entryLength = msgLength + newMsgLength;\n        messages[key] = {\n          ...messages[key],\n          entries: Array(entryLength)\n        };\n\n        let msgIndex = 0;\n        let newMsgIndex = 0;\n\n        for (let i = 0; i < entryLength; ++i) {\n          if (newMsgIndex >= newMsgLength) {\n            messages[key].entries[i] = msgEntries[msgIndex++];\n          } else if (msgIndex >= msgLength) {\n            messages[key].entries[i] = newMsgEntries[newMsgIndex++];\n          } else if (\n            msgEntries[msgIndex].relTime <= newMsgEntries[newMsgIndex].relTime\n          ) {\n            messages[key].entries[i] = msgEntries[msgIndex++];\n          } else if (\n            msgEntries[msgIndex].relTime >= newMsgEntries[newMsgIndex].relTime\n          ) {\n            messages[key].entries[i] = newMsgEntries[newMsgIndex++];\n          }\n        }\n        messages[key].byteStateChangeCounts = newMessages[key].byteStateChangeCounts;\n      } else {\n        messages[key] = newMessages[key];\n        messages[key].frame = this.state.dbc.getMessageFrame(\n          messages[key].address\n        );\n      }\n    });\n\n    const maxByteStateChangeCount = DbcUtils.findMaxByteStateChangeCount(\n      messages\n    );\n    this.setState({\n      maxByteStateChangeCount\n    });\n\n    Object.keys(messages).forEach((key) => {\n      // console.log(key);\n      messages[key] = DbcUtils.setMessageByteColors(\n        messages[key],\n        maxByteStateChangeCount\n      );\n    });\n\n    return messages;\n  }\n\n  async addMessagesToDataCache(part, newMessages, newThumbnails) {\n    const { dbc, currentParts } = this.state;\n    const entry = await this.getParseSegment(part);\n    if (!entry) {\n      // first chunk of data returned from this segment\n      Object.keys(newMessages).forEach((key) => {\n        newMessages[key] = this.parseMessageEntry(newMessages[key], dbc);\n      });\n      dataCache[part] = {\n        messages: newMessages,\n        thumbnails: newThumbnails,\n        lastUpdated: Date.now(),\n        lastUsed: Date.now()\n      };\n      if (part >= currentParts[0] && part <= currentParts[1]) {\n        this.setState({\n          messages: this.addAndRehydrateMessages(newMessages)\n        });\n      }\n      return;\n    }\n\n    entry.lastUsed = Date.now();\n\n    // data is always append only, and always per segment\n    Object.keys(newMessages).forEach((key) => {\n      let msgs = newMessages[key];\n      if (!dataCache[part].messages[key]) {\n        msgs = this.parseMessageEntry(msgs, dbc);\n        dataCache[part].messages[key] = msgs;\n      } else {\n        let { entries } = dataCache[part].messages[key];\n        const lastEntry = entries.length ? entries[entries.length - 1] : null;\n        msgs = this.parseMessageEntry(msgs, dbc, lastEntry);\n        entries = entries.concat(msgs.entries);\n        dataCache[part].messages[key].entries = entries;\n      }\n      newMessages[key] = msgs;\n    });\n    dataCache[part].thumbnails = dataCache[part].thumbnails.concat(newThumbnails);\n\n    if (part >= currentParts[0] && part <= currentParts[1]) {\n      this.setState({\n        messages: this.addAndRehydrateMessages(newMessages)\n      });\n    }\n  }\n\n  async loadMessagesFromCache() {\n    // create a new messages object for state\n    if (this.loadMessagesFromCacheRunning) {\n      if (!this.loadMessagesFromCacheTimer) {\n        this.loadMessagesFromCacheTimer = timeout(() => this.loadMessagesFromCache(), 10);\n      }\n      return;\n    }\n    this.loadMessagesFromCacheRunning = true;\n    if (this.loadMessagesFromCacheTimer) {\n      this.loadMessagesFromCacheTimer();\n      this.loadMessagesFromCacheTimer = null;\n    }\n    const { currentParts, dbc } = this.state;\n    const { lastUpdated } = dbc;\n    const [minPart, maxPart] = currentParts;\n    const messages = {};\n    let thumbnails = [];\n    let isCanceled = false;\n\n    let start = performance.now();\n\n    const promises = [];\n\n    for (let i = minPart, l = maxPart; i <= l; ++i) {\n      promises.push(this.getParseSegment(i));\n    }\n    await promises.reduce(async (prev, p) => {\n      await prev;\n      if (isCanceled) {\n        return;\n      }\n      const cacheEntry = await p;\n      if (this.state.dbc.lastUpdated !== lastUpdated) {\n        if (!isCanceled) {\n          isCanceled = true;\n          this.loadMessagesFromCacheRunning = false;\n          console.log('Canceling!');\n          this.loadMessagesFromCache();\n        }\n        return;\n      }\n      if (cacheEntry) {\n        const newMessages = cacheEntry.messages;\n        thumbnails = thumbnails.concat(cacheEntry.thumbnails);\n        Object.keys(newMessages).forEach((key) => {\n          if (!messages[key]) {\n            messages[key] = { ...newMessages[key] };\n          } else {\n            const newMessageEntries = newMessages[key].entries;\n            const messageEntries = messages[key].entries;\n            if (newMessageEntries.length\n              && newMessageEntries[0].relTime < messageEntries[messageEntries.length - 1].relTime) {\n              console.error('Found out of order messages', newMessageEntries[0], messageEntries[messageEntries.length - 1]);\n            }\n            messages[key].entries = messages[key].entries.concat(newMessages[key].entries);\n          }\n        });\n      }\n      console.log('Done with', performance.now() - start);\n      start = performance.now();\n    }, Promise.resolve());\n\n    if (isCanceled) {\n      return;\n    }\n\n    Object.keys(this.state.messages).forEach((key) => {\n      if (!messages[key]) {\n        messages[key] = this.state.messages[key];\n        messages[key].entries = [];\n      }\n    });\n\n    Object.keys(messages).forEach((key) => {\n      messages[key].frame = dbc.getMessageFrame(\n        messages[key].address\n      );\n    });\n\n    const maxByteStateChangeCount = DbcUtils.findMaxByteStateChangeCount(\n      messages\n    );\n\n    this.setState({\n      maxByteStateChangeCount\n    });\n\n    Object.keys(messages).forEach((key) => {\n      // console.log(key);\n      messages[key] = DbcUtils.setMessageByteColors(\n        messages[key],\n        maxByteStateChangeCount\n      );\n    });\n\n    console.log('Done with old messages', performance.now() - start);\n\n    this.setState({ messages, thumbnails });\n\n    this.loadMessagesFromCacheRunning = false;\n  }\n\n  async getParseSegment(part) {\n    if (!dataCache[part]) {\n      return null;\n    }\n    if (dataCache[part].promise) {\n      await dataCache[part].promise;\n    }\n    dataCache[part].promise = this.getParseSegmentInternal(part);\n\n    return dataCache[part].promise;\n  }\n\n  async getParseSegmentInternal(part) {\n    const start = performance.now();\n    const { dbc } = this.state;\n    if (!dbc.lastUpdated) {\n      dbc.lastUpdated = Date.now();\n    }\n    const { lastUpdated } = dbc;\n    let { messages } = dataCache[part];\n\n    let reparseMessages = {};\n\n    // if (lastUpdated > dataCache[part].lastUpdated) {\n    //   dataCache[part].lastUpdated = Date.now();\n    //   return await this.reparseMessages(messages);\n    // }\n\n    Object.keys(messages).forEach((key) => {\n      if (messages[key].lastUpdated >= lastUpdated) {\n        return;\n      }\n      reparseMessages[key] = messages[key];\n    });\n\n    if (Object.keys(reparseMessages).length) {\n      console.log('Reparsing messages!', Object.keys(reparseMessages).length);\n      reparseMessages = await this.reparseMessages(reparseMessages);\n    }\n\n    messages = {\n      ...messages,\n      ...reparseMessages\n    };\n\n    dataCache[part].messages = messages;\n\n    const end = performance.now();\n    if (end - start > 200) {\n      // warn about anything over 200ms\n      console.warn('getParseSegment took', part, end - start, Object.keys(messages).length);\n    }\n\n    return dataCache[part];\n  }\n\n  decacheMessageId(messageId) {\n    Object.keys(dataCache).forEach((part) => {\n      if (dataCache[part].messages[messageId]) {\n        dataCache[part].messages[messageId].lastUpdated = 0;\n      }\n    });\n  }\n\n  async reparseMessages(_messages) {\n    const messages = _messages;\n    const { dbc } = this.state;\n    dbc.lastUpdated = dbc.lastUpdated || Date.now();\n\n    Object.keys(messages).forEach((key) => {\n      messages[key].frame = dbc.getMessageFrame(messages[key].address);\n    });\n\n    return new Promise((resolve, reject) => {\n      const worker = new MessageParser();\n      worker.onmessage = (e) => {\n        const newMessages = e.data.messages;\n        Object.keys(newMessages).forEach((key) => {\n          newMessages[key].lastUpdated = dbc.lastUpdated;\n          newMessages[key].frame = dbc.getMessageFrame(newMessages[key].address);\n        });\n        resolve(newMessages);\n      };\n\n      worker.postMessage({\n        messages,\n        dbcText: dbc.text(),\n        canStartTime: this.state.firstCanTime\n      });\n    });\n  }\n\n  parseMessageEntry(_entry, dbc, lastMsg) {\n    const entry = _entry;\n    dbc.lastUpdated = dbc.lastUpdated || Date.now();\n    entry.lastUpdated = dbc.lastUpdated;\n    entry.frame = dbc.getMessageFrame(\n      entry.address\n    );\n\n    let prevMsgEntry = lastMsg || null;\n    const byteStateChangeCounts = [];\n    // entry.messages[id].byteStateChangeCounts = byteStateChangeCounts.map(\n    //   (count, idx) => entry.messages[id].byteStateChangeCounts[idx] + count\n    // );\n    entry.entries = entry.entries.map((message) => {\n      if (message.hexData) {\n        prevMsgEntry = DbcUtils.reparseMessage(dbc, message, prevMsgEntry);\n      } else {\n        prevMsgEntry = DbcUtils.parseMessage(\n          dbc,\n          message.time,\n          message.address,\n          message.data,\n          message.timeStart,\n          prevMsgEntry\n        );\n      }\n      byteStateChangeCounts.push(prevMsgEntry.byteStateChangeCounts);\n      prevMsgEntry = prevMsgEntry.msgEntry;\n      return prevMsgEntry;\n    });\n    entry.byteStateChangeCounts = byteStateChangeCounts.reduce((memo, val) => {\n      if (!memo) {\n        return val;\n      }\n      return memo.map((count, idx) => val[idx] + count);\n    }, null);\n\n    return entry;\n  }\n\n  showingModal() {\n    const {\n      showOnboarding,\n      showLoadDbc,\n      showSaveDbc,\n      showAddSignal,\n      showEditMessageModal\n    } = this.state;\n    return (\n      showOnboarding\n      || showLoadDbc\n      || showSaveDbc\n      || showAddSignal\n      || showEditMessageModal\n    );\n  }\n\n  showOnboarding() {\n    if (!CommaAuth.isAuthenticated() && window.sessionStorage && window.location &&\n      window.location.pathname !== AuthConfig.AUTH_PATH)\n    {\n      window.sessionStorage.setItem('onboardingPath', window.location.href);\n    }\n    this.setState({ showOnboarding: true });\n  }\n\n  hideOnboarding() {\n    this.setState({ showOnboarding: false });\n  }\n\n  showLoadDbc() {\n    this.setState({ showLoadDbc: true });\n  }\n\n  hideLoadDbc() {\n    this.setState({ showLoadDbc: false });\n  }\n\n  showSaveDbc() {\n    this.setState({ showSaveDbc: true });\n  }\n\n  hideSaveDbc() {\n    this.setState({ showSaveDbc: false });\n  }\n\n  updateMessageFrame(messageId, frame) {\n    const { messages } = this.state;\n\n    messages[messageId].frame = frame;\n    this.setState({ messages });\n  }\n\n  persistDbc({ dbcFilename, dbc }) {\n    const { route } = this.state;\n    if (route) {\n      persistDbc(route.fullname, { dbcFilename, dbc });\n    } else {\n      persistDbc('live', { dbcFilename, dbc });\n    }\n\n    this.loadMessagesFromCache();\n  }\n\n  onConfirmedSignalChange(message, signals) {\n    const { dbc, dbcFilename } = this.state;\n    const frameSize = DbcUtils.maxMessageSize(message);\n    dbc.setSignals(message.address, { ...signals }, frameSize);\n\n    this.persistDbc({ dbcFilename, dbc });\n\n    this.updateMessageFrame(message.id, dbc.getMessageFrame(message.address));\n\n    this.setState({ dbc, dbcText: dbc.text() }, () => {\n      this.decacheMessageId(message.id);\n      this.loadMessagesFromCache();\n    });\n  }\n\n  partChangeDebounced = debounce(() => {\n    this.loadMessagesFromCache();\n\n    this.spawnWorker();\n  }, 500);\n\n  onPartChange(part) {\n    let {\n      currentParts, currentPart, canFrameOffset, route\n    } = this.state;\n    if (canFrameOffset === -1 || part === currentPart) {\n      return;\n    }\n\n    // determine new parts to load, whether to prepend or append\n    let maxPart = Math.min(route.proclog, part + 1);\n    const minPart = Math.max(0, maxPart - PART_SEGMENT_LENGTH + 1);\n    if (minPart === 0) {\n      maxPart = Math.min(route.proclog, 2);\n    }\n\n    // update current parts\n    currentParts = [minPart, maxPart];\n    currentPart = part;\n\n    if (\n      currentPart !== this.state.currentPart\n      || currentParts[0] !== this.state.currentParts[0]\n      || currentParts[1] !== this.state.currentParts[1]\n    ) {\n      // update state then load new parts\n      this.setState({ currentParts, currentPart }, this.partChangeDebounced);\n    }\n  }\n\n  showEditMessageModal(msgKey) {\n    const msg = this.state.messages[msgKey];\n    console.log(msg);\n    if (!msg.frame) {\n      msg.frame = this.state.dbc.createFrame(msg.address);  // TODO frameSize\n    }\n\n    this.setState({\n      showEditMessageModal: true,\n      editMessageModalMessage: msgKey,\n      messages: this.state.messages,\n      dbcText: this.state.dbc.text()\n    });\n  }\n\n  hideEditMessageModal() {\n    this.setState({ showEditMessageModal: false });\n  }\n\n  onMessageFrameEdited(messageFrame) {\n    const {\n      messages, dbcFilename, dbc, editMessageModalMessage\n    } = this.state;\n\n    const message = { ...messages[editMessageModalMessage] };\n    message.frame = messageFrame;\n    dbc.messages.set(messageFrame.id, messageFrame);\n    this.persistDbc({ dbcFilename, dbc });\n\n    messages[editMessageModalMessage] = message;\n    this.setState({ messages, dbc, dbcText: dbc.text() });\n    this.hideEditMessageModal();\n  }\n\n  onSeek(seekIndex, seekTime) {\n    this.setState({ seekIndex, seekTime });\n\n    const { currentPart } = this.state;\n    const part = ~~(seekTime / 60);\n    if (part !== currentPart) {\n      this.onPartChange(part);\n    }\n  }\n\n  onUserSeek(seekTime) {\n    if (USE_UNLOGGER) {\n      this.unloggerClient.seek(this.props.dongleId, this.props.name, seekTime);\n    }\n\n    const msg = this.state.messages[this.state.selectedMessage];\n    let seekIndex;\n    if (msg) {\n      seekIndex = msg.entries.findIndex((e) => e.relTime >= seekTime);\n      if (seekIndex === -1) {\n        seekIndex = 0;\n      }\n    } else {\n      seekIndex = 0;\n    }\n\n    this.onSeek(seekIndex, seekTime);\n  }\n\n  onMessageSelected(msgKey) {\n    let { seekTime, seekIndex, messages } = this.state;\n    const msg = messages[msgKey];\n\n    if (seekTime > 0 && msg.entries.length > 0) {\n      seekIndex = msg.entries.findIndex((e) => e.relTime >= seekTime);\n      if (seekIndex === -1) {\n        seekIndex = 0;\n      }\n\n      seekTime = msg.entries[seekIndex].relTime;\n    }\n\n    this.setState({ seekTime, seekIndex, selectedMessage: msgKey });\n  }\n\n  updateSelectedMessages(selectedMessages) {\n    this.setState({ selectedMessages });\n  }\n\n  onMessageUnselected(msgKey) {\n    this.setState({ selectedMessage: null });\n  }\n\n  loginWithGithub() {\n    const { route } = this.state;\n    return (\n      <a\n        href={GithubAuth.authorizeUrl(\n          route && route.fullname ? route.fullname : ''\n        )}\n        className=\"button button--dark button--inline\"\n      >\n        <i className=\"fa fa-github\" />\n        <span> Log in with Github</span>\n      </a>\n    );\n  }\n\n  lastMessageEntriesById(obj, [msgId, message]) {\n    obj[msgId] = message.entries[message.entries.length - 1];\n    return obj;\n  }\n\n  processStreamedCanMessages(newCanMessages) {\n    const { dbcText } = this.state;\n    const {\n      firstCanTime,\n      lastBusTime,\n      messages,\n      maxByteStateChangeCount\n    } = this.state;\n    // map msg id to arrays\n    const prevMsgEntries = Object.entries(messages).reduce(\n      this.lastMessageEntriesById,\n      {}\n    );\n\n    const byteStateChangeCountsByMessage = Object.entries(messages).reduce(\n      (obj, [msgId, msg]) => {\n        obj[msgId] = msg.byteStateChangeCounts;\n        return obj;\n      },\n      {}\n    );\n\n    this.canStreamerWorker.postMessage({\n      newCanMessages,\n      prevMsgEntries,\n      firstCanTime,\n      dbcText,\n      lastBusTime,\n      byteStateChangeCountsByMessage,\n      maxByteStateChangeCount\n    });\n  }\n\n  firstEntryIndexInsideStreamingWindow(entries) {\n    const lastEntryTime = entries[entries.length - 1].relTime;\n    const windowFloor = lastEntryTime - STREAMING_WINDOW;\n\n    for (let i = 0; i < entries.length; i++) {\n      if (entries[i].relTime > windowFloor) {\n        return i;\n      }\n    }\n\n    return 0;\n  }\n\n  enforceStreamingMessageWindow(messages) {\n    const messageIds = Object.keys(messages);\n    for (let i = 0; i < messageIds.length; i++) {\n      const messageId = messageIds[i];\n      const message = messages[messageId];\n      if (message.entries.length < 2) {\n        continue;\n      }\n\n      const lastEntryTime = message.entries[message.entries.length - 1].relTime;\n      const entrySpan = lastEntryTime - message.entries[0].relTime;\n      if (entrySpan > STREAMING_WINDOW) {\n        const newEntryFloor = this.firstEntryIndexInsideStreamingWindow(\n          message.entries\n        );\n        message.entries = message.entries.slice(newEntryFloor);\n        messages[messageId] = message;\n      }\n    }\n\n    return messages;\n  }\n\n  _onStreamedCanMessagesProcessed(data) {\n    let {\n      newMessages,\n      seekTime,\n      lastBusTime,\n      firstCanTime,\n      maxByteStateChangeCount\n    } = data;\n\n    if (maxByteStateChangeCount < this.state.maxByteStateChangeCount) {\n      maxByteStateChangeCount = this.state.maxByteStateChangeCount;\n    }\n\n    let messages = this.addAndRehydrateMessages(newMessages);\n    messages = this.enforceStreamingMessageWindow(messages);\n    let { seekIndex, selectedMessages } = this.state;\n    if (\n      selectedMessages.length > 0\n      && messages[selectedMessages[0]] !== undefined\n    ) {\n      seekIndex = Math.max(0, messages[selectedMessages[0]].entries.length - 1);\n    }\n    this.setState({\n      messages,\n      seekTime,\n      seekIndex,\n      lastBusTime,\n      firstCanTime,\n      maxByteStateChangeCount\n    });\n  }\n\n  onStreamedCanMessagesProcessed(e) {\n    this._onStreamedCanMessagesProcessed(e.data);\n  }\n\n  async handlePandaConnect(e) {\n    this.setState({ attemptingPandaConnection: true, live: true });\n\n    const persistedDbc = fetchPersistedDbc('live');\n    if (persistedDbc) {\n      const { dbc, dbcText } = persistedDbc;\n      this.setState({ dbc, dbcText });\n    }\n    this.canStreamerWorker = new CanStreamerWorker();\n    this.canStreamerWorker.onmessage = this.onStreamedCanMessagesProcessed;\n\n    // if any errors go off during connection, mark as not trying to connect anymore...\n    const unlisten = this.pandaReader.onError((err) => {\n      console.error(err.stack || err);\n      this.setState({ attemptingPandaConnection: false });\n    });\n    try {\n      await this.pandaReader.start();\n      this.setState({\n        showOnboarding: false,\n        showLoadDbc: true\n      });\n    } catch (e) {}\n    this.setState({ attemptingPandaConnection: false });\n    unlisten();\n  }\n\n  githubSignOut(e, dataArray) {\n    unpersistGithubAuthToken();\n    this.setState({ isGithubAuthenticated: false });\n\n    e.preventDefault();\n  }\n\n  render() {\n    const {\n      route,\n      messages,\n      selectedMessages,\n      currentParts,\n      dbcFilename,\n      dbcLastSaved,\n      seekTime,\n      seekIndex,\n      shareUrl,\n      maxByteStateChangeCount,\n      live,\n      thumbnails,\n      selectedMessage,\n      canFrameOffset,\n      firstCanTime,\n      currentPart,\n      partsLoaded,\n      share,\n    } = this.state;\n\n    const { startTime, segments } = this.props;\n\n    return (\n      <div\n        id=\"cabana\"\n        className={cx({ 'is-showing-modal': this.showingModal() })}\n      >\n        <div className=\"cabana-header\">\n          <a className=\"cabana-header-logo\" href=\"/\">\n            Comma Cabana\n          </a>\n          <div className=\"cabana-header-account\">\n            {this.state.isGithubAuthenticated ? (\n              <div>\n                <p>GitHub Authenticated</p>\n                <p\n                  className=\"cabana-header-account-signout\"\n                  onClick={this.githubSignOut}\n                >\n                  Sign out\n                </p>\n              </div>\n            ) : (\n              this.loginWithGithub()\n            )}\n          </div>\n        </div>\n        <div className=\"cabana-window\">\n          <Meta\n            url={this.state.route ? route.url : null}\n            messages={messages}\n            selectedMessages={selectedMessages}\n            updateSelectedMessages={this.updateSelectedMessages}\n            showEditMessageModal={this.showEditMessageModal}\n            currentParts={currentParts}\n            onMessageSelected={this.onMessageSelected}\n            onMessageUnselected={this.onMessageUnselected}\n            showLoadDbc={this.showLoadDbc}\n            showSaveDbc={this.showSaveDbc}\n            dbcFilename={dbcFilename}\n            dbcLastSaved={dbcLastSaved}\n            dongleId={this.props.dongleId}\n            name={this.props.name}\n            route={route}\n            seekTime={seekTime}\n            seekIndex={seekIndex}\n            shareUrl={shareUrl}\n            maxByteStateChangeCount={maxByteStateChangeCount}\n            live={live}\n            saveLog={debounce(this.downloadLogAsCSV, 500)}\n          />\n          {route || live ? (\n            <Explorer\n              url={route ? route.url : null}\n              live={live}\n              messages={messages}\n              thumbnails={thumbnails}\n              selectedMessage={selectedMessage}\n              onConfirmedSignalChange={this.onConfirmedSignalChange}\n              onSeek={this.onSeek}\n              onUserSeek={this.onUserSeek}\n              canFrameOffset={canFrameOffset}\n              firstCanTime={firstCanTime}\n              seekTime={seekTime}\n              startTime={startTime}\n              startSegments={segments}\n              seekIndex={seekIndex}\n              currentParts={currentParts}\n              selectedPart={currentPart}\n              partsLoaded={partsLoaded}\n              autoplay={this.props.autoplay}\n              showEditMessageModal={this.showEditMessageModal}\n              onPartChange={this.onPartChange}\n              routeStartTime={\n                route ? route.start_time : Moment()\n              }\n              videoOffset={ (this.state.firstFrameTime && this.state.routeInitTime) ? this.state.firstFrameTime - this.state.routeInitTime : 0 }\n              partsCount={route ? route.proclog : 0}\n              maxqcamera={route ? route.maxqcamera : 0}\n              route={route}\n              share={share}\n            />\n          ) : null}\n        </div>\n\n        {this.state.showOnboarding ? (\n          <OnboardingModal\n            handlePandaConnect={this.handlePandaConnect}\n            attemptingPandaConnection={this.state.attemptingPandaConnection}\n            routes={this.state.routes}\n          />\n        ) : null}\n\n        {this.state.showLoadDbc ? (\n          <LoadDbcModal\n            onDbcSelected={this.onDbcSelected}\n            handleClose={this.hideLoadDbc}\n            openDbcClient={this.openDbcClient}\n            loginWithGithub={this.loginWithGithub()}\n          />\n        ) : null}\n\n        {this.state.showSaveDbc ? (\n          <SaveDbcModal\n            dbc={this.state.dbc}\n            sourceDbcFilename={this.state.dbcFilename}\n            onDbcSaved={this.onDbcSaved}\n            handleClose={this.hideSaveDbc}\n            openDbcClient={this.openDbcClient}\n            hasGithubAuth={this.props.githubAuthToken !== null}\n            loginWithGithub={this.loginWithGithub()}\n          />\n        ) : null}\n\n        {this.state.showEditMessageModal ? (\n          <EditMessageModal\n            handleClose={this.hideEditMessageModal}\n            handleSave={this.onMessageFrameEdited}\n            message={this.state.messages[this.state.editMessageModalMessage]}\n          />\n        ) : null}\n      </div>\n    );\n  }\n}\n\nCanExplorer.propTypes = {\n  dongleId: PropTypes.string,\n  name: PropTypes.string,\n  dbc: PropTypes.instanceOf(DBC),\n  dbcFilename: PropTypes.string,\n  githubAuthToken: PropTypes.string,\n  autoplay: PropTypes.bool,\n  max: PropTypes.number,\n  url: PropTypes.string,\n  startTime: PropTypes.number,\n  segments: PropTypes.array\n};\n"]},"metadata":{},"sourceType":"module"}