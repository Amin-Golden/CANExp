{"ast":null,"code":"var _jsxFileName = \"/home/amax/Autoro/cabana/src/components/AddSignals.js\";\nimport React, { Component } from 'react';\nimport PropTypes from 'prop-types';\nimport { StyleSheet } from 'aphrodite/no-important';\nimport css from '../utils/css';\nimport SignalLegend from './SignalLegend';\nimport Signal from '../models/can/signal';\nimport { shade } from '../utils/color';\nimport DbcUtils from '../utils/dbc';\n/*\nAddSignals component draws an 8x8 matrix\nrepresenting the bytes in a CAN message, alongside\na signal legend. Dragging on the matrix\neither extends or creates a signal, which is\nconfigurable in the legend.\n*/\n\nconst Styles = StyleSheet.create({\n  bit: {\n    margin: 0,\n    padding: 9,\n    userSelect: 'none',\n    cursor: 'pointer',\n    textAlign: 'center',\n    position: 'relative'\n  },\n  bitSelectedStyle: {\n    backgroundColor: 'rgba(0,119,158,0.5)'\n  },\n  byteIndex: {\n    backgroundColor: '#ededed'\n  },\n  bitSignificance: {\n    fontSize: 12,\n    display: 'block',\n    position: 'absolute',\n    bottom: 0,\n    left: 0,\n    right: 0,\n    margin: '0 auto'\n  },\n  highlightedSignalTitle: {\n    backgroundColor: 'rgba(0,0,0,0.2)'\n  }\n});\nexport default class AddSignals extends Component {\n  constructor(props) {\n    super(props);\n\n    this.updateSignalStyles = () => {\n      const signalStyles = this.calcSignalStyles(this.state.signals);\n      this.setState({\n        signalStyles\n      });\n      this.matrixMouseMove();\n    };\n\n    this.onSignalHover = signal => {\n      if (!signal) return;\n      this.setState({\n        highlightedSignal: signal.name\n      }, this.updateSignalStyles);\n    };\n\n    this.onBitHover = (bitIdx, signal) => {\n      let {\n        dragStartBit,\n        signals,\n        dragSignal\n      } = this.state;\n\n      if (dragStartBit !== null) {\n        if (dragSignal !== null) {\n          signals = this.copySignals(signals);\n          dragSignal = Object.assign(Object.create(dragSignal), dragSignal);\n\n          if (dragStartBit === dragSignal.startBit && dragSignal.size > 1) {\n            if (!dragSignal.isLittleEndian) {\n              // should not be able to drag the msb past the lsb\n              const hoveredBigEndian = DbcUtils.bigEndianBitIndex(bitIdx);\n              const lsbBigEndian = dragSignal.lsbBitNumber();\n\n              if (hoveredBigEndian > lsbBigEndian) {\n                return;\n              }\n            } else {\n              // should not be able to drag the lsb past the msb\n              if (bitIdx > dragSignal.msbBitIndex()) {\n                return;\n              }\n            }\n\n            const diff = bitIdx - dragStartBit;\n\n            if (dragSignal.isLittleEndian) {\n              dragSignal.size -= diff;\n            } else if (dragSignal.bitDescription(bitIdx) === null) {\n              dragSignal.size += Math.abs(diff);\n            } else {\n              dragSignal.size -= Math.abs(diff);\n            }\n\n            dragSignal.startBit += diff;\n            signals[dragSignal.name] = dragSignal;\n            dragStartBit = dragSignal.startBit;\n          } else if (dragSignal.size === 1) {\n            // 1-bit signals can be dragged in either direction\n            if (Math.floor(bitIdx / 8) === Math.floor(dragStartBit / 8)) {\n              if (bitIdx > dragStartBit) {\n                if (dragSignal.isLittleEndian) {\n                  dragSignal.size = bitIdx - dragSignal.startBit;\n                } else {\n                  dragSignal.startBit = bitIdx;\n                  dragSignal.size = bitIdx - dragStartBit + 1;\n                  dragStartBit = bitIdx;\n                }\n              } else if (dragSignal.isLittleEndian) {\n                dragSignal.startBit = bitIdx;\n                dragSignal.size = dragStartBit - bitIdx + 1;\n                dragStartBit = bitIdx;\n              } else {\n                dragSignal.size = dragStartBit - bitIdx + 1;\n                dragStartBit = bitIdx;\n              }\n            }\n\n            signals[dragSignal.name] = dragSignal;\n          } else if (dragSignal.isLittleEndian && dragStartBit === dragSignal.msbBitIndex()) {\n            if (bitIdx < dragSignal.startBit) {\n              // should not be able to drag the MSB past the LSB\n              return;\n            }\n\n            const diff = bitIdx - dragStartBit;\n\n            if (dragSignal.bitDescription(bitIdx) === null) {\n              dragSignal.size += Math.abs(diff);\n            } else {\n              dragSignal.size -= Math.abs(diff);\n            }\n\n            signals[dragSignal.name] = dragSignal;\n            dragStartBit = dragSignal.msbBitIndex();\n          } else if (!dragSignal.isLittleEndian && dragStartBit === dragSignal.lsbBitIndex()) {\n            const diff = bitIdx - dragStartBit;\n\n            if (dragSignal.bitDescription(bitIdx) === null) {\n              dragSignal.size += Math.abs(diff);\n            } else {\n              dragSignal.size -= Math.abs(diff);\n            }\n\n            signals[dragSignal.name] = dragSignal;\n            dragStartBit = dragSignal.lsbBitIndex();\n          }\n\n          this.setState({\n            signals,\n            dragSignal,\n            dragCurrentBit: bitIdx,\n            dragStartBit\n          });\n        } else {\n          this.setState({\n            dragCurrentBit: bitIdx\n          });\n        }\n      }\n\n      if (signal) {\n        this.onSignalHover(signal);\n      }\n    };\n\n    this.onSignalHoverEnd = signal => {\n      if (!signal) return;\n      this.setState({\n        highlightedSignal: null\n      }, this.updateSignalStyles);\n    };\n\n    this.resetDragState = () => {\n      this.setState({\n        dragStartBit: null,\n        dragSignal: null,\n        dragCurrentBit: null\n      });\n    };\n\n    this.matrixMouseMove = ev => {\n      if (this.state.highlightedSignal && this.highlightedSignalTooltipRef.current) {\n        const tt = this.highlightedSignalTooltipRef.current;\n        const signal = this.state.signals[this.state.highlightedSignal];\n        tt.innerHTML = signal.name;\n\n        if (ev) {\n          tt.style.left = ev.clientX + 15 + 'px';\n          tt.style.top = ev.clientY + 5 + 'px';\n        }\n      }\n    };\n\n    this.onTentativeSignalChange = signal => {\n      // Tentative signal changes are not propagated up\n      // but their effects are displayed in the bitmatrix\n      const {\n        signals\n      } = this.state;\n      signals[signal.name] = signal;\n      this.setState({\n        signals\n      });\n    };\n\n    this.onSignalChange = signal => {\n      const {\n        signals\n      } = this.state;\n\n      if (signal.name in signals && signals[signal.name].uid !== signal.uid) {\n        return false;\n      }\n\n      for (const signalName in signals) {\n        if (signals[signalName].uid === signal.uid) {\n          delete signals[signalName];\n        }\n      }\n\n      signals[signal.name] = signal;\n      this.setState({\n        signals\n      }, this.propagateUpSignalChange);\n      return true;\n    };\n\n    this.onSignalRemove = signal => {\n      const {\n        signals\n      } = this.state;\n      delete signals[signal.name];\n      this.setState({\n        signals\n      }, this.propagateUpSignalChange);\n    };\n\n    this.onSignalPlotChange = (shouldPlot, signalUid) => {\n      const {\n        message\n      } = this.props;\n      this.props.onSignalPlotChange(shouldPlot, message.id, signalUid);\n    };\n\n    let _signals = {};\n\n    if (props.message && props.message.frame && props.message.frame.signals) {\n      _signals = this.copySignals(props.message.frame.signals);\n    }\n\n    this.highlightedSignalTooltipRef = React.createRef();\n    this.state = {\n      bits: [],\n      signals: _signals,\n      signalStyles: this.calcSignalStyles(_signals),\n      highlightedSignal: null,\n      dragStartBit: null,\n      dragSignal: null,\n      dragCurrentBit: null,\n      maxMessageBytes: 8\n    };\n  }\n\n  copySignals(signals) {\n    return Object.entries(signals).reduce((signalsCopy, _ref) => {\n      let [signalName, signal] = _ref;\n      signalsCopy[signalName] = Object.assign(Object.create(signal), signal);\n      return signalsCopy;\n    }, {});\n  }\n\n  componentDidMount() {\n    this.componentDidUpdate({}, {});\n  }\n\n  componentDidUpdate(prevProps) {\n    if (!prevProps.message || prevProps.message.address !== this.props.message.address || prevProps.selectedMessageKey !== this.props.selectedMessageKey) {\n      const signals = this.props.message.frame ? this.props.message.frame.signals : {};\n      this.setState({\n        signals: this.copySignals(signals),\n        maxMessageBytes: DbcUtils.maxMessageSize(this.props.message)\n      }, this.updateSignalStyles);\n    }\n  }\n\n  shouldComponentUpdate(nextProps, nextState) {\n    return nextProps.selectedMessageKey !== this.props.selectedMessageKey || nextProps.message.address !== this.props.message.address || nextProps.message.hexData !== this.props.message.hexData || nextProps.messageIndex !== this.props.messageIndex || JSON.stringify(nextProps.plottedSignalUids) !== JSON.stringify(this.props.plottedSignalUids) || JSON.stringify(this.state) !== JSON.stringify(nextState);\n  }\n\n  signalColorStyle(signal) {\n    const colors = signal.getColors(this.props.selectedMessageKey);\n    let colorRgbStr;\n    let backgroundColor;\n\n    if (this.state && this.state.highlightedSignal === signal.name) {\n      // when signal highlighted,\n      // darkened background and lightened text.\n      const darkenedColors = shade(colors, -0.5);\n      const lightenedColors = shade(colors, 0.9);\n      colorRgbStr = `rgb(${lightenedColors.join(',')})`;\n      backgroundColor = `rgba(${darkenedColors.join(',')},0.5)`;\n    } else {\n      const colorsCommaSep = colors.join(',');\n      colorRgbStr = `rgb(${colorsCommaSep})`;\n      backgroundColor = `rgba(${colorsCommaSep},0.2)`;\n    }\n\n    const style = StyleSheet.create({\n      signal: {\n        color: colorRgbStr,\n        backgroundColor\n      }\n    }).signal;\n    return style;\n  }\n\n  calcSignalStyles(signals) {\n    const signalStyles = {};\n    Object.values(signals).forEach(signal => {\n      signalStyles[signal.name] = this.signalColorStyle(signal);\n    });\n    return signalStyles;\n  }\n\n  signalForBit(bitIdx) {\n    // bitIdx in [0,64)\n    // returns instance of Signal\n    return Object.values(this.state.signals).filter(signal => signal.bitDescription(bitIdx) !== null)[0];\n  }\n\n  signalBitIndex(bitIdx, signal) {\n    // todo does this work for both big and little endian?\n    let {\n      startBit\n    } = signal;\n\n    if (!signal.isLittleEndian) {\n      startBit = DbcUtils.bigEndianBitIndex(startBit);\n    }\n\n    return bitIdx - startBit;\n  }\n\n  nextNewSignalName() {\n    const existingNames = Object.keys(this.state.signals);\n    let signalNum = 1;\n    let signalName;\n\n    do {\n      signalName = `NEW_SIGNAL_${signalNum}`;\n      signalNum++;\n    } while (existingNames.indexOf(signalName) !== -1);\n\n    return signalName;\n  }\n\n  onBitMouseDown(dragStartBit, dragSignal) {\n    this.setState({\n      dragStartBit,\n      dragSignal: dragSignal || null\n    });\n  }\n\n  createSignal(_ref2) {\n    let {\n      startBit,\n      size,\n      isLittleEndian\n    } = _ref2;\n    const signal = new Signal({\n      name: this.nextNewSignalName(),\n      startBit,\n      size,\n      isLittleEndian\n    });\n    let {\n      signals\n    } = this.state;\n    signals = { ...signals\n    };\n    signals[signal.name] = signal;\n    this.setState({\n      signals\n    }, this.propagateUpSignalChange);\n  }\n\n  createSignalIfNotExtendingOne(dragStartBit, dragEndBit) {\n    if (this.state.dragSignal === null) {\n      // check for overlapping bits\n      for (let i = dragStartBit; i <= dragEndBit; i++) {\n        if (this.signalForBit(i) !== undefined) {\n          // Don't create signal if a signal is already defined in the selected range.\n          return;\n        }\n      }\n\n      const isDragAcrossSingleByte = Math.floor(dragEndBit / 8) === Math.floor(dragStartBit / 8);\n      const isDragDirectionUp = !isDragAcrossSingleByte && dragEndBit < dragStartBit;\n      let isLittleEndian;\n\n      if (isDragAcrossSingleByte || !isDragDirectionUp) {\n        isLittleEndian = dragStartBit % 8 < 4;\n      } else {\n        isLittleEndian = dragStartBit % 8 >= 4;\n      }\n\n      let size;\n      let startBit = dragStartBit;\n\n      if (isDragAcrossSingleByte) {\n        size = Math.abs(dragEndBit - dragStartBit) + 1;\n      } else if (isLittleEndian) {\n        if (dragEndBit > dragStartBit) {\n          startBit = dragStartBit;\n          size = dragEndBit - dragStartBit + 1;\n        } else {\n          startBit = dragEndBit;\n          size = dragStartBit - dragEndBit + 1;\n        }\n      } else {\n        if (dragEndBit < dragStartBit) {\n          startBit = dragEndBit;\n        }\n\n        size = Math.abs(DbcUtils.bigEndianBitIndex(dragEndBit) - DbcUtils.bigEndianBitIndex(dragStartBit)) + 1;\n      }\n\n      this.createSignal({\n        startBit,\n        size,\n        isLittleEndian\n      });\n    }\n  }\n\n  onBitMouseUp(dragEndBit, signal) {\n    if (this.state.dragStartBit !== null) {\n      const {\n        dragStartBit\n      } = this.state;\n\n      if (dragEndBit !== dragStartBit) {\n        // one-bit signal requires double click\n        // see onBitDoubleClick\n        this.createSignalIfNotExtendingOne(dragStartBit, dragEndBit);\n      }\n\n      this.propagateUpSignalChange();\n      this.resetDragState();\n    }\n  }\n\n  byteValueHex(byteIdx) {\n    const {\n      entries\n    } = this.props.message;\n\n    if (this.props.messageIndex < entries.length) {\n      const entry = entries[this.props.messageIndex];\n      return entry.hexData.substr(byteIdx * 2, 2);\n    }\n\n    return '--';\n  }\n\n  bitValue(byteIdx, byteBitIdx) {\n    const {\n      entries\n    } = this.props.message;\n\n    if (this.props.messageIndex < entries.length) {\n      const entry = entries[this.props.messageIndex];\n      const data = Buffer.from(entry.hexData, 'hex');\n\n      if (byteIdx >= data.length) {\n        return '-';\n      }\n\n      const byte = data.readInt8(byteIdx);\n      return byte >> byteBitIdx & 1;\n    }\n\n    return '-';\n  }\n\n  bitIsContainedInSelection(bitIdx) {\n    let isLittleEndian = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    const {\n      dragStartBit,\n      dragCurrentBit\n    } = this.state;\n\n    if (isLittleEndian || dragStartBit % 8 < 4) {\n      return dragStartBit !== null && dragCurrentBit !== null && bitIdx >= dragStartBit && bitIdx <= dragCurrentBit;\n    }\n\n    const bigEndianStartBit = DbcUtils.bigEndianBitIndex(dragStartBit);\n    const bigEndianCurrentBit = DbcUtils.bigEndianBitIndex(dragCurrentBit);\n    const bigEndianBitIdx = DbcUtils.bigEndianBitIndex(bitIdx);\n    return dragStartBit !== null && dragCurrentBit !== null && bigEndianBitIdx >= bigEndianStartBit && bigEndianBitIdx <= bigEndianCurrentBit;\n  }\n\n  onBitDoubleClick(startBit, signal) {\n    if (signal === undefined) {\n      this.createSignal({\n        startBit,\n        size: 1,\n        isLittleEndian: false\n      });\n    }\n  }\n\n  renderBitMatrix() {\n    const {\n      message\n    } = this.props;\n    const rows = [];\n    let rowCount;\n\n    if (message.frame && message.frame.size) {\n      rowCount = Math.floor(message.frame.size * 8 / 8);\n    } else {\n      rowCount = this.state.maxMessageBytes;\n    }\n\n    for (let i = 0; i < rowCount; i++) {\n      const rowBits = [];\n      rowBits.push( /*#__PURE__*/React.createElement(\"td\", {\n        key: `rowIndex${i}`,\n        className: css(Styles.bit, Styles.byteIndex),\n        __self: this,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 450,\n          columnNumber: 20\n        }\n      }, i.toString()));\n\n      for (let j = 7; j >= 0; j--) {\n        const bitIdx = i * 8 + j;\n        const signal = this.signalForBit(bitIdx);\n        let bitStyle = null;\n        let bitSignificance = '';\n\n        if (signal) {\n          bitStyle = this.state.signalStyles[signal.name] || null;\n          const bitDesc = signal.bitDescription(bitIdx);\n          bitSignificance = bitDesc.isMsb ? 'msb' : bitDesc.isLsb ? 'lsb' : '';\n        } else if (this.bitIsContainedInSelection(bitIdx)) {\n          bitStyle = Styles.bitSelectedStyle;\n        }\n\n        const className = css('bit', Styles.bit, bitStyle);\n        const bitValue = this.bitValue(i, j);\n        rowBits.push( /*#__PURE__*/React.createElement(\"td\", {\n          key: j.toString(),\n          className: className,\n          onMouseEnter: () => this.onBitHover(bitIdx, signal),\n          onMouseLeave: () => this.onSignalHoverEnd(signal),\n          onMouseDown: this.onBitMouseDown.bind(this, bitIdx, signal),\n          onMouseUp: this.onBitMouseUp.bind(this, bitIdx, signal),\n          onDoubleClick: this.onBitDoubleClick.bind(this, bitIdx, signal),\n          __self: this,\n          __source: {\n            fileName: _jsxFileName,\n            lineNumber: 468,\n            columnNumber: 11\n          }\n        }, /*#__PURE__*/React.createElement(\"span\", {\n          __self: this,\n          __source: {\n            fileName: _jsxFileName,\n            lineNumber: 477,\n            columnNumber: 13\n          }\n        }, bitValue), /*#__PURE__*/React.createElement(\"span\", {\n          className: css(Styles.bitSignificance),\n          __self: this,\n          __source: {\n            fileName: _jsxFileName,\n            lineNumber: 478,\n            columnNumber: 13\n          }\n        }, bitSignificance)));\n      }\n\n      rowBits.push( /*#__PURE__*/React.createElement(\"td\", {\n        key: \"hex-repr\",\n        className: css(Styles.bit),\n        __self: this,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 485,\n          columnNumber: 20\n        }\n      }, /*#__PURE__*/React.createElement(\"b\", {\n        __self: this,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 485,\n          columnNumber: 67\n        }\n      }, this.byteValueHex(i))));\n      rows.push( /*#__PURE__*/React.createElement(\"tr\", {\n        key: i.toString(),\n        __self: this,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 486,\n          columnNumber: 17\n        }\n      }, rowBits));\n    }\n\n    return /*#__PURE__*/React.createElement(\"div\", {\n      className: \"cabana-explorer-signals-matrix\",\n      onMouseMove: this.matrixMouseMove,\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 490,\n        columnNumber: 7\n      }\n    }, this.state.highlightedSignal && /*#__PURE__*/React.createElement(\"p\", {\n      ref: this.highlightedSignalTooltipRef,\n      className: \"cabana-explorer-signals-matrix-tooltip\",\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 492,\n        columnNumber: 11\n      }\n    }), /*#__PURE__*/React.createElement(\"table\", {\n      cellSpacing: 0,\n      onMouseLeave: this.resetDragState,\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 494,\n        columnNumber: 9\n      }\n    }, /*#__PURE__*/React.createElement(\"tbody\", {\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 495,\n        columnNumber: 11\n      }\n    }, rows)));\n  }\n\n  propagateUpSignalChange() {\n    const {\n      signals\n    } = this.state;\n    this.props.onConfirmedSignalChange(this.props.message, this.copySignals(signals));\n  }\n\n  render() {\n    const {\n      selectedMessageKey\n    } = this.props;\n    return /*#__PURE__*/React.createElement(\"div\", {\n      className: \"cabana-explorer-signals-controller\",\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 572,\n        columnNumber: 7\n      }\n    }, Object.keys(this.state.signals).length === 0 ? /*#__PURE__*/React.createElement(\"p\", {\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 574,\n        columnNumber: 11\n      }\n    }, \"Double click or drag to add a signal\") : null, this.props.message.entries[this.props.messageIndex] ? /*#__PURE__*/React.createElement(\"div\", {\n      className: \"cabana-explorer-signals-time\",\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 577,\n        columnNumber: 11\n      }\n    }, /*#__PURE__*/React.createElement(\"p\", {\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 578,\n        columnNumber: 13\n      }\n    }, \"time:\", ' ', this.props.message.entries[this.props.messageIndex].relTime.toFixed(3))) : null, this.renderBitMatrix(), /*#__PURE__*/React.createElement(SignalLegend, {\n      signals: this.state.signals,\n      signalStyles: this.state.signalStyles,\n      highlightedSignal: this.state.highlightedSignal,\n      onSignalHover: this.onSignalHover,\n      onSignalHoverEnd: this.onSignalHoverEnd,\n      onTentativeSignalChange: this.onTentativeSignalChange,\n      onSignalChange: this.onSignalChange,\n      onSignalRemove: this.onSignalRemove,\n      onSignalPlotChange: this.onSignalPlotChange,\n      plottedSignalUids: this.props.plottedSignalUids,\n      selectedMessageKey: selectedMessageKey,\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 588,\n        columnNumber: 9\n      }\n    }));\n  }\n\n}\nAddSignals.propTypes = {\n  message: PropTypes.object,\n  onConfirmedSignalChange: PropTypes.func,\n  messageIndex: PropTypes.number,\n  onSignalPlotChange: PropTypes.func,\n  plottedSignalUids: PropTypes.array,\n  selectedMessageKey: PropTypes.string\n};","map":{"version":3,"sources":["/home/amax/Autoro/cabana/src/components/AddSignals.js"],"names":["React","Component","PropTypes","StyleSheet","css","SignalLegend","Signal","shade","DbcUtils","Styles","create","bit","margin","padding","userSelect","cursor","textAlign","position","bitSelectedStyle","backgroundColor","byteIndex","bitSignificance","fontSize","display","bottom","left","right","highlightedSignalTitle","AddSignals","constructor","props","updateSignalStyles","signalStyles","calcSignalStyles","state","signals","setState","matrixMouseMove","onSignalHover","signal","highlightedSignal","name","onBitHover","bitIdx","dragStartBit","dragSignal","copySignals","Object","assign","startBit","size","isLittleEndian","hoveredBigEndian","bigEndianBitIndex","lsbBigEndian","lsbBitNumber","msbBitIndex","diff","bitDescription","Math","abs","floor","lsbBitIndex","dragCurrentBit","onSignalHoverEnd","resetDragState","ev","highlightedSignalTooltipRef","current","tt","innerHTML","style","clientX","top","clientY","onTentativeSignalChange","onSignalChange","uid","signalName","propagateUpSignalChange","onSignalRemove","onSignalPlotChange","shouldPlot","signalUid","message","id","frame","createRef","bits","maxMessageBytes","entries","reduce","signalsCopy","componentDidMount","componentDidUpdate","prevProps","address","selectedMessageKey","maxMessageSize","shouldComponentUpdate","nextProps","nextState","hexData","messageIndex","JSON","stringify","plottedSignalUids","signalColorStyle","colors","getColors","colorRgbStr","darkenedColors","lightenedColors","join","colorsCommaSep","color","values","forEach","signalForBit","filter","signalBitIndex","nextNewSignalName","existingNames","keys","signalNum","indexOf","onBitMouseDown","createSignal","createSignalIfNotExtendingOne","dragEndBit","i","undefined","isDragAcrossSingleByte","isDragDirectionUp","onBitMouseUp","byteValueHex","byteIdx","length","entry","substr","bitValue","byteBitIdx","data","Buffer","from","byte","readInt8","bitIsContainedInSelection","bigEndianStartBit","bigEndianCurrentBit","bigEndianBitIdx","onBitDoubleClick","renderBitMatrix","rows","rowCount","rowBits","push","toString","j","bitStyle","bitDesc","isMsb","isLsb","className","bind","onConfirmedSignalChange","render","relTime","toFixed","propTypes","object","func","number","array","string"],"mappings":"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","sourcesContent":["import React, { Component } from 'react';\nimport PropTypes from 'prop-types';\nimport { StyleSheet } from 'aphrodite/no-important';\nimport css from '../utils/css';\n\nimport SignalLegend from './SignalLegend';\nimport Signal from '../models/can/signal';\nimport { shade } from '../utils/color';\nimport DbcUtils from '../utils/dbc';\n\n/*\nAddSignals component draws an 8x8 matrix\nrepresenting the bytes in a CAN message, alongside\na signal legend. Dragging on the matrix\neither extends or creates a signal, which is\nconfigurable in the legend.\n*/\n\nconst Styles = StyleSheet.create({\n  bit: {\n    margin: 0,\n    padding: 9,\n    userSelect: 'none',\n    cursor: 'pointer',\n    textAlign: 'center',\n    position: 'relative'\n  },\n  bitSelectedStyle: {\n    backgroundColor: 'rgba(0,119,158,0.5)'\n  },\n  byteIndex: {\n    backgroundColor: '#ededed'\n  },\n  bitSignificance: {\n    fontSize: 12,\n    display: 'block',\n    position: 'absolute',\n    bottom: 0,\n    left: 0,\n    right: 0,\n    margin: '0 auto'\n  },\n  highlightedSignalTitle: {\n    backgroundColor: 'rgba(0,0,0,0.2)'\n  }\n});\n\nexport default class AddSignals extends Component {\n  static propTypes = {\n    message: PropTypes.object,\n    onConfirmedSignalChange: PropTypes.func,\n    messageIndex: PropTypes.number,\n    onSignalPlotChange: PropTypes.func,\n    plottedSignalUids: PropTypes.array,\n    selectedMessageKey: PropTypes.string\n  };\n\n  constructor(props) {\n    super(props);\n\n    let signals = {};\n    if (props.message && props.message.frame && props.message.frame.signals) {\n      signals = this.copySignals(props.message.frame.signals);\n    }\n\n    this.highlightedSignalTooltipRef = React.createRef();\n\n    this.state = {\n      bits: [],\n      signals,\n      signalStyles: this.calcSignalStyles(signals),\n      highlightedSignal: null,\n      dragStartBit: null,\n      dragSignal: null,\n      dragCurrentBit: null,\n      maxMessageBytes: 8,\n    };\n  }\n\n  copySignals(signals) {\n    return Object.entries(signals).reduce(\n      (signalsCopy, [signalName, signal]) => {\n        signalsCopy[signalName] = Object.assign(Object.create(signal), signal);\n        return signalsCopy;\n      },\n      {}\n    );\n  }\n\n  componentDidMount() {\n    this.componentDidUpdate({}, {});\n  }\n\n  componentDidUpdate(prevProps) {\n    if (!prevProps.message || prevProps.message.address !== this.props.message.address ||\n      prevProps.selectedMessageKey !== this.props.selectedMessageKey)\n    {\n      const signals = this.props.message.frame ? this.props.message.frame.signals : {};\n\n      this.setState({\n        signals: this.copySignals(signals),\n        maxMessageBytes: DbcUtils.maxMessageSize(this.props.message)\n      }, this.updateSignalStyles);\n    }\n  }\n\n  shouldComponentUpdate(nextProps, nextState) {\n    return (\n      nextProps.selectedMessageKey !== this.props.selectedMessageKey ||\n      nextProps.message.address !== this.props.message.address ||\n      nextProps.message.hexData !== this.props.message.hexData ||\n      nextProps.messageIndex !== this.props.messageIndex ||\n      JSON.stringify(nextProps.plottedSignalUids) !== JSON.stringify(this.props.plottedSignalUids) ||\n      JSON.stringify(this.state) !== JSON.stringify(nextState)\n    );\n  }\n\n  signalColorStyle(signal) {\n    const colors = signal.getColors(this.props.selectedMessageKey);\n\n    let colorRgbStr;\n    let backgroundColor;\n    if (this.state && this.state.highlightedSignal === signal.name) {\n      // when signal highlighted,\n      // darkened background and lightened text.\n\n      const darkenedColors = shade(colors, -0.5);\n      const lightenedColors = shade(colors, 0.9);\n      colorRgbStr = `rgb(${lightenedColors.join(',')})`;\n      backgroundColor = `rgba(${darkenedColors.join(',')},0.5)`;\n    } else {\n      const colorsCommaSep = colors.join(',');\n      colorRgbStr = `rgb(${colorsCommaSep})`;\n      backgroundColor = `rgba(${colorsCommaSep},0.2)`;\n    }\n\n    const style = StyleSheet.create({\n      signal: { color: colorRgbStr, backgroundColor }\n    }).signal;\n    return style;\n  }\n\n  updateSignalStyles = () => {\n    const signalStyles = this.calcSignalStyles(this.state.signals);\n\n    this.setState({ signalStyles });\n    this.matrixMouseMove();\n  };\n\n  calcSignalStyles(signals) {\n    const signalStyles = {};\n    Object.values(signals).forEach((signal) => {\n      signalStyles[signal.name] = this.signalColorStyle(signal);\n    });\n\n    return signalStyles;\n  }\n\n  signalForBit(bitIdx) {\n    // bitIdx in [0,64)\n    // returns instance of Signal\n\n    return Object.values(this.state.signals).filter(\n      (signal) => signal.bitDescription(bitIdx) !== null\n    )[0];\n  }\n\n  onSignalHover = (signal) => {\n    if (!signal) return;\n\n    this.setState({ highlightedSignal: signal.name }, this.updateSignalStyles);\n  };\n\n  signalBitIndex(bitIdx, signal) {\n    // todo does this work for both big and little endian?\n    let { startBit } = signal;\n    if (!signal.isLittleEndian) {\n      startBit = DbcUtils.bigEndianBitIndex(startBit);\n    }\n    return bitIdx - startBit;\n  }\n\n  onBitHover = (bitIdx, signal) => {\n    let { dragStartBit, signals, dragSignal } = this.state;\n\n    if (dragStartBit !== null) {\n      if (dragSignal !== null) {\n        signals = this.copySignals(signals);\n        dragSignal = Object.assign(Object.create(dragSignal), dragSignal);\n\n        if (dragStartBit === dragSignal.startBit && dragSignal.size > 1) {\n          if (!dragSignal.isLittleEndian) {\n            // should not be able to drag the msb past the lsb\n            const hoveredBigEndian = DbcUtils.bigEndianBitIndex(bitIdx);\n            const lsbBigEndian = dragSignal.lsbBitNumber();\n\n            if (hoveredBigEndian > lsbBigEndian) {\n              return;\n            }\n          } else {\n            // should not be able to drag the lsb past the msb\n            if (bitIdx > dragSignal.msbBitIndex()) {\n              return;\n            }\n          }\n\n          const diff = bitIdx - dragStartBit;\n\n          if (dragSignal.isLittleEndian) {\n            dragSignal.size -= diff;\n          } else if (dragSignal.bitDescription(bitIdx) === null) {\n            dragSignal.size += Math.abs(diff);\n          } else {\n            dragSignal.size -= Math.abs(diff);\n          }\n\n          dragSignal.startBit += diff;\n\n          signals[dragSignal.name] = dragSignal;\n          dragStartBit = dragSignal.startBit;\n        } else if (dragSignal.size === 1) {\n          // 1-bit signals can be dragged in either direction\n          if (Math.floor(bitIdx / 8) === Math.floor(dragStartBit / 8)) {\n            if (bitIdx > dragStartBit) {\n              if (dragSignal.isLittleEndian) {\n                dragSignal.size = bitIdx - dragSignal.startBit;\n              } else {\n                dragSignal.startBit = bitIdx;\n                dragSignal.size = bitIdx - dragStartBit + 1;\n                dragStartBit = bitIdx;\n              }\n            } else if (dragSignal.isLittleEndian) {\n              dragSignal.startBit = bitIdx;\n              dragSignal.size = dragStartBit - bitIdx + 1;\n              dragStartBit = bitIdx;\n            } else {\n              dragSignal.size = dragStartBit - bitIdx + 1;\n              dragStartBit = bitIdx;\n            }\n          }\n\n          signals[dragSignal.name] = dragSignal;\n        } else if (\n          dragSignal.isLittleEndian\n          && dragStartBit === dragSignal.msbBitIndex()\n        ) {\n          if (bitIdx < dragSignal.startBit) {\n            // should not be able to drag the MSB past the LSB\n            return;\n          }\n          const diff = bitIdx - dragStartBit;\n          if (dragSignal.bitDescription(bitIdx) === null) {\n            dragSignal.size += Math.abs(diff);\n          } else {\n            dragSignal.size -= Math.abs(diff);\n          }\n          signals[dragSignal.name] = dragSignal;\n          dragStartBit = dragSignal.msbBitIndex();\n        } else if (\n          !dragSignal.isLittleEndian\n          && dragStartBit === dragSignal.lsbBitIndex()\n        ) {\n          const diff = bitIdx - dragStartBit;\n          if (dragSignal.bitDescription(bitIdx) === null) {\n            dragSignal.size += Math.abs(diff);\n          } else {\n            dragSignal.size -= Math.abs(diff);\n          }\n          signals[dragSignal.name] = dragSignal;\n          dragStartBit = dragSignal.lsbBitIndex();\n        }\n        this.setState({\n          signals,\n          dragSignal,\n          dragCurrentBit: bitIdx,\n          dragStartBit\n        });\n      } else {\n        this.setState({ dragCurrentBit: bitIdx });\n      }\n    }\n    if (signal) {\n      this.onSignalHover(signal);\n    }\n  };\n\n  onSignalHoverEnd = (signal) => {\n    if (!signal) return;\n\n    this.setState({ highlightedSignal: null }, this.updateSignalStyles);\n  };\n\n  nextNewSignalName() {\n    const existingNames = Object.keys(this.state.signals);\n    let signalNum = 1;\n    let signalName;\n    do {\n      signalName = `NEW_SIGNAL_${signalNum}`;\n      signalNum++;\n    } while (existingNames.indexOf(signalName) !== -1);\n\n    return signalName;\n  }\n\n  onBitMouseDown(dragStartBit, dragSignal) {\n    this.setState({\n      dragStartBit,\n      dragSignal: dragSignal || null\n    });\n  }\n\n  createSignal({ startBit, size, isLittleEndian }) {\n    const signal = new Signal({\n      name: this.nextNewSignalName(),\n      startBit,\n      size,\n      isLittleEndian\n    });\n    let { signals } = this.state;\n    signals = { ...signals };\n    signals[signal.name] = signal;\n\n    this.setState({ signals }, this.propagateUpSignalChange);\n  }\n\n  createSignalIfNotExtendingOne(dragStartBit, dragEndBit) {\n    if (this.state.dragSignal === null) {\n      // check for overlapping bits\n      for (let i = dragStartBit; i <= dragEndBit; i++) {\n        if (this.signalForBit(i) !== undefined) {\n          // Don't create signal if a signal is already defined in the selected range.\n          return;\n        }\n      }\n      const isDragAcrossSingleByte = Math.floor(dragEndBit / 8) === Math.floor(dragStartBit / 8);\n      const isDragDirectionUp = !isDragAcrossSingleByte && dragEndBit < dragStartBit;\n\n      let isLittleEndian;\n      if (isDragAcrossSingleByte || !isDragDirectionUp) {\n        isLittleEndian = dragStartBit % 8 < 4;\n      } else {\n        isLittleEndian = dragStartBit % 8 >= 4;\n      }\n      let size;\n      let startBit = dragStartBit;\n\n      if (isDragAcrossSingleByte) {\n        size = Math.abs(dragEndBit - dragStartBit) + 1;\n      } else if (isLittleEndian) {\n        if (dragEndBit > dragStartBit) {\n          startBit = dragStartBit;\n          size = dragEndBit - dragStartBit + 1;\n        } else {\n          startBit = dragEndBit;\n          size = dragStartBit - dragEndBit + 1;\n        }\n      } else {\n        if (dragEndBit < dragStartBit) {\n          startBit = dragEndBit;\n        }\n        size = Math.abs(\n          DbcUtils.bigEndianBitIndex(dragEndBit)\n              - DbcUtils.bigEndianBitIndex(dragStartBit)\n        ) + 1;\n      }\n\n      this.createSignal({ startBit, size, isLittleEndian });\n    }\n  }\n\n  onBitMouseUp(dragEndBit, signal) {\n    if (this.state.dragStartBit !== null) {\n      const { dragStartBit } = this.state;\n\n      if (dragEndBit !== dragStartBit) {\n        // one-bit signal requires double click\n        // see onBitDoubleClick\n        this.createSignalIfNotExtendingOne(dragStartBit, dragEndBit);\n      }\n      this.propagateUpSignalChange();\n      this.resetDragState();\n    }\n  }\n\n  byteValueHex(byteIdx) {\n    const { entries } = this.props.message;\n    if (this.props.messageIndex < entries.length) {\n      const entry = entries[this.props.messageIndex];\n\n      return entry.hexData.substr(byteIdx * 2, 2);\n    }\n    return '--';\n  }\n\n  bitValue(byteIdx, byteBitIdx) {\n    const { entries } = this.props.message;\n    if (this.props.messageIndex < entries.length) {\n      const entry = entries[this.props.messageIndex];\n      const data = Buffer.from(entry.hexData, 'hex');\n      if (byteIdx >= data.length) {\n        return '-';\n      }\n      const byte = data.readInt8(byteIdx);\n      return (byte >> byteBitIdx) & 1;\n    }\n    return '-';\n  }\n\n  bitIsContainedInSelection(bitIdx, isLittleEndian = false) {\n    const { dragStartBit, dragCurrentBit } = this.state;\n\n    if (isLittleEndian || dragStartBit % 8 < 4) {\n      return (\n        dragStartBit !== null\n        && dragCurrentBit !== null\n        && bitIdx >= dragStartBit\n        && bitIdx <= dragCurrentBit\n      );\n    }\n    const bigEndianStartBit = DbcUtils.bigEndianBitIndex(dragStartBit);\n    const bigEndianCurrentBit = DbcUtils.bigEndianBitIndex(dragCurrentBit);\n    const bigEndianBitIdx = DbcUtils.bigEndianBitIndex(bitIdx);\n    return (\n      dragStartBit !== null\n      && dragCurrentBit !== null\n      && bigEndianBitIdx >= bigEndianStartBit\n      && bigEndianBitIdx <= bigEndianCurrentBit\n    );\n  }\n\n  onBitDoubleClick(startBit, signal) {\n    if (signal === undefined) {\n      this.createSignal({ startBit, size: 1, isLittleEndian: false });\n    }\n  }\n\n  renderBitMatrix() {\n    const { message } = this.props;\n    const rows = [];\n    let rowCount;\n    if (message.frame && message.frame.size) {\n      rowCount = Math.floor((message.frame.size * 8) / 8);\n    } else {\n      rowCount = this.state.maxMessageBytes;\n    }\n\n    for (let i = 0; i < rowCount; i++) {\n      const rowBits = [];\n\n      rowBits.push(<td key={`rowIndex${i}`} className={css(Styles.bit, Styles.byteIndex)}>{i.toString()}</td>);\n\n      for (let j = 7; j >= 0; j--) {\n        const bitIdx = i * 8 + j;\n        const signal = this.signalForBit(bitIdx);\n        let bitStyle = null;\n        let bitSignificance = '';\n        if (signal) {\n          bitStyle = this.state.signalStyles[signal.name] || null;\n          const bitDesc = signal.bitDescription(bitIdx);\n          bitSignificance = bitDesc.isMsb ? 'msb' : bitDesc.isLsb ? 'lsb' : '';\n        } else if (this.bitIsContainedInSelection(bitIdx)) {\n          bitStyle = Styles.bitSelectedStyle;\n        }\n        const className = css('bit', Styles.bit, bitStyle);\n        const bitValue = this.bitValue(i, j);\n\n        rowBits.push(\n          <td\n            key={j.toString()}\n            className={className}\n            onMouseEnter={() => this.onBitHover(bitIdx, signal)}\n            onMouseLeave={() => this.onSignalHoverEnd(signal)}\n            onMouseDown={this.onBitMouseDown.bind(this, bitIdx, signal)}\n            onMouseUp={this.onBitMouseUp.bind(this, bitIdx, signal)}\n            onDoubleClick={this.onBitDoubleClick.bind(this, bitIdx, signal)}\n          >\n            <span>{bitValue}</span>\n            <span className={css(Styles.bitSignificance)}>\n              {bitSignificance}\n            </span>\n          </td>\n        );\n      }\n\n      rowBits.push(<td key=\"hex-repr\" className={css(Styles.bit)}><b>{this.byteValueHex(i)}</b></td>);\n      rows.push(<tr key={i.toString()}>{rowBits}</tr>);\n    }\n\n    return (\n      <div className=\"cabana-explorer-signals-matrix\" onMouseMove={this.matrixMouseMove}>\n        {this.state.highlightedSignal &&\n          <p ref={this.highlightedSignalTooltipRef} className=\"cabana-explorer-signals-matrix-tooltip\" />\n        }\n        <table cellSpacing={0} onMouseLeave={this.resetDragState}>\n          <tbody>{rows}</tbody>\n        </table>\n      </div>\n    );\n  }\n\n  resetDragState = () => {\n    this.setState({\n      dragStartBit: null,\n      dragSignal: null,\n      dragCurrentBit: null\n    });\n  };\n\n  matrixMouseMove = (ev) => {\n    if (this.state.highlightedSignal && this.highlightedSignalTooltipRef.current) {\n      const tt = this.highlightedSignalTooltipRef.current;\n      const signal = this.state.signals[this.state.highlightedSignal];\n\n      tt.innerHTML = signal.name;\n      if (ev) {\n        tt.style.left = (ev.clientX + 15) + 'px';\n        tt.style.top = (ev.clientY + 5) + 'px';\n      }\n    }\n  };\n\n  onTentativeSignalChange = (signal) => {\n    // Tentative signal changes are not propagated up\n    // but their effects are displayed in the bitmatrix\n    const { signals } = this.state;\n    signals[signal.name] = signal;\n    this.setState({ signals });\n  };\n\n  onSignalChange = (signal) => {\n    const { signals } = this.state;\n\n    if (signal.name in signals && signals[signal.name].uid !== signal.uid) {\n      return false;\n    }\n\n    for (const signalName in signals) {\n      if (signals[signalName].uid === signal.uid) {\n        delete signals[signalName];\n      }\n    }\n    signals[signal.name] = signal;\n\n    this.setState({ signals }, this.propagateUpSignalChange);\n    return true;\n  };\n\n  onSignalRemove = (signal) => {\n    const { signals } = this.state;\n    delete signals[signal.name];\n    this.setState({ signals }, this.propagateUpSignalChange);\n  };\n\n  propagateUpSignalChange() {\n    const { signals } = this.state;\n\n    this.props.onConfirmedSignalChange(\n      this.props.message,\n      this.copySignals(signals)\n    );\n  }\n\n  onSignalPlotChange = (shouldPlot, signalUid) => {\n    const { message } = this.props;\n\n    this.props.onSignalPlotChange(shouldPlot, message.id, signalUid);\n  };\n\n  render() {\n    const { selectedMessageKey } = this.props;\n    return (\n      <div className=\"cabana-explorer-signals-controller\">\n        {Object.keys(this.state.signals).length === 0 ? (\n          <p>Double click or drag to add a signal</p>\n        ) : null}\n        {this.props.message.entries[this.props.messageIndex] ? (\n          <div className=\"cabana-explorer-signals-time\">\n            <p>\n              time:\n              {' '}\n              {this.props.message.entries[\n                this.props.messageIndex\n              ].relTime.toFixed(3)}\n            </p>\n          </div>\n        ) : null}\n        {this.renderBitMatrix()}\n        <SignalLegend\n          signals={this.state.signals}\n          signalStyles={this.state.signalStyles}\n          highlightedSignal={this.state.highlightedSignal}\n          onSignalHover={this.onSignalHover}\n          onSignalHoverEnd={this.onSignalHoverEnd}\n          onTentativeSignalChange={this.onTentativeSignalChange}\n          onSignalChange={this.onSignalChange}\n          onSignalRemove={this.onSignalRemove}\n          onSignalPlotChange={this.onSignalPlotChange}\n          plottedSignalUids={this.props.plottedSignalUids}\n          selectedMessageKey={selectedMessageKey}\n        />\n      </div>\n    );\n  }\n}\n"]},"metadata":{},"sourceType":"module"}