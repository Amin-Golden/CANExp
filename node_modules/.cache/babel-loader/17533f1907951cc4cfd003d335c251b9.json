{"ast":null,"code":"\"use strict\";\n/**\n * @author jdiaz5513\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n}); // Perform some bit gymnastics to determine the native endian format.\n\nvar tmpWord = new DataView(new ArrayBuffer(8));\nnew Uint16Array(tmpWord.buffer)[0] = 0x0102;\n/** Default size (in bytes) for newly allocated segments. */\n\nexports.DEFAULT_BUFFER_SIZE = 4096;\nexports.DEFAULT_DECODE_LIMIT = 64 << 20; // 64 MiB\n\n/**\n * Limit to how deeply nested pointers are allowed to be. The root struct of a message will start at this value, and it\n * is decremented as pointers are dereferenced.\n */\n\nexports.DEFAULT_DEPTH_LIMIT = 64;\n/**\n * Limit to the number of **bytes** that can be traversed in a single message. This is necessary to prevent certain\n * classes of DoS attacks where maliciously crafted data can be self-referencing in a way that wouldn't trigger the\n * depth limit.\n *\n * For this reason, it is advised to cache pointers into variables and not constantly dereference them since the\n * message's traversal limit gets decremented each time.\n */\n\nexports.DEFAULT_TRAVERSE_LIMIT = 64 << 20; // 64 MiB\n\n/**\n * When allocating array buffers dynamically (while packing or in certain Arena implementations) the previous buffer's\n * size is multiplied by this number to determine the next buffer's size. This is chosen to keep both time spent\n * reallocating and wasted memory to a minimum.\n *\n * Smaller numbers would save memory at the expense of CPU time.\n */\n\nexports.GROWTH_FACTOR = 1.5;\n/** A bitmask applied to obtain the size of a list pointer. */\n\nexports.LIST_SIZE_MASK = 0x00000007;\n/** Maximum number of bytes to dump at once when dumping array buffers to string. */\n\nexports.MAX_BUFFER_DUMP_BYTES = 8192;\n/** The maximum value for a 32-bit integer. */\n\nexports.MAX_INT32 = 0x7fffffff;\n/** The maximum value for a 32-bit unsigned integer. */\n\nexports.MAX_UINT32 = 0xffffffff;\n/** The largest integer that can be precisely represented in JavaScript. */\n\nexports.MAX_SAFE_INTEGER = 9007199254740991;\n/** Maximum limit on the number of segments in a message stream. */\n\nexports.MAX_STREAM_SEGMENTS = 512;\n/** The smallest integer that can be precisely represented in JavaScript. */\n\nexports.MIN_SAFE_INTEGER = -9007199254740991;\n/** Minimum growth increment for a SingleSegmentArena. */\n\nexports.MIN_SINGLE_SEGMENT_GROWTH = 4096;\n/**\n * This will be `true` if the machine running this code stores numbers natively in little-endian format. This is useful\n * for some numeric type conversions when the endianness does not affect the output. Using the native endianness for\n * these operations is _slightly_ faster.\n */\n\nexports.NATIVE_LITTLE_ENDIAN = tmpWord.getUint8(0) === 0x02;\n/**\n * When packing a message, this is the number of zero bytes required after a SPAN (0xff) tag is written to the packed\n * message before the span is terminated.\n *\n * This little detail is left up to the implementation because it can be tuned for performance. Setting this to a higher\n * value may help with messages that contain a ton of text/data.\n *\n * It is imperative to never set this below 1 or else BAD THINGS. You have been warned.\n */\n\nexports.PACK_SPAN_THRESHOLD = 2;\n/**\n * How far to travel into a nested pointer structure during a deep copy; when this limit is exhausted the copy\n * operation will throw an error.\n */\n\nexports.POINTER_COPY_LIMIT = 32;\n/** A bitmask for looking up the double-far flag on a far pointer. */\n\nexports.POINTER_DOUBLE_FAR_MASK = 0x00000004;\n/** A bitmask for looking up the pointer type. */\n\nexports.POINTER_TYPE_MASK = 0x00000003;\n/** Used for some 64-bit conversions, equal to Math.pow(2, 32). */\n\nexports.VAL32 = 0x100000000;\n/** The maximum value allowed for depth traversal limits. */\n\nexports.MAX_DEPTH = exports.MAX_INT32;\n/** The maximum byte length for a single segment. */\n\nexports.MAX_SEGMENT_LENGTH = exports.MAX_UINT32;","map":{"version":3,"sources":["constants.ts"],"names":[],"mappings":";AAAA;;AAEG;;;;IAEH;;AAEA,IAAM,OAAO,GAAG,IAAI,QAAJ,CAAa,IAAI,WAAJ,CAAgB,CAAhB,CAAb,CAAhB;AACC,IAAI,WAAJ,CAAgB,OAAO,CAAC,MAAxB,CAAD,CAAkC,CAAlC,IAAuC,MAAvC;AAEA;;AAEa,OAAA,CAAA,mBAAA,GAAsB,IAAtB;AAEA,OAAA,CAAA,oBAAA,GAAuB,MAAM,EAA7B,C,CAAmC;;AAEhD;;;AAGG;;AAEU,OAAA,CAAA,mBAAA,GAAsB,EAAtB;AAEb;;;;;;;AAOG;;AAEU,OAAA,CAAA,sBAAA,GAAyB,MAAM,EAA/B,C,CAAqC;;AAElD;;;;;;AAMG;;AAEU,OAAA,CAAA,aAAA,GAAgB,GAAhB;AAEb;;AAEa,OAAA,CAAA,cAAA,GAAiB,UAAjB;AAEb;;AAEa,OAAA,CAAA,qBAAA,GAAwB,IAAxB;AAEb;;AAEa,OAAA,CAAA,SAAA,GAAY,UAAZ;AAEb;;AAEa,OAAA,CAAA,UAAA,GAAa,UAAb;AAEb;;AAEa,OAAA,CAAA,gBAAA,GAAmB,gBAAnB;AAEb;;AAEa,OAAA,CAAA,mBAAA,GAAsB,GAAtB;AAEb;;AAEa,OAAA,CAAA,gBAAA,GAAmB,CAAC,gBAApB;AAEb;;AAEa,OAAA,CAAA,yBAAA,GAA4B,IAA5B;AAEb;;;;AAIG;;AAEU,OAAA,CAAA,oBAAA,GAAuB,OAAO,CAAC,QAAR,CAAiB,CAAjB,MAAwB,IAA/C;AAEb;;;;;;;;AAQG;;AAEU,OAAA,CAAA,mBAAA,GAAsB,CAAtB;AAEb;;;AAGG;;AAEU,OAAA,CAAA,kBAAA,GAAqB,EAArB;AAEb;;AAEa,OAAA,CAAA,uBAAA,GAA0B,UAA1B;AAEb;;AAEa,OAAA,CAAA,iBAAA,GAAoB,UAApB;AAEb;;AAEa,OAAA,CAAA,KAAA,GAAQ,WAAR;AAEb;;AAEa,OAAA,CAAA,SAAA,GAAY,OAAA,CAAA,SAAZ;AAEb;;AAEa,OAAA,CAAA,kBAAA,GAAqB,OAAA,CAAA,UAArB","sourceRoot":"../src","sourcesContent":["\"use strict\";\n/**\n * @author jdiaz5513\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\n// Perform some bit gymnastics to determine the native endian format.\nvar tmpWord = new DataView(new ArrayBuffer(8));\n(new Uint16Array(tmpWord.buffer))[0] = 0x0102;\n/** Default size (in bytes) for newly allocated segments. */\nexports.DEFAULT_BUFFER_SIZE = 4096;\nexports.DEFAULT_DECODE_LIMIT = 64 << 20; // 64 MiB\n/**\n * Limit to how deeply nested pointers are allowed to be. The root struct of a message will start at this value, and it\n * is decremented as pointers are dereferenced.\n */\nexports.DEFAULT_DEPTH_LIMIT = 64;\n/**\n * Limit to the number of **bytes** that can be traversed in a single message. This is necessary to prevent certain\n * classes of DoS attacks where maliciously crafted data can be self-referencing in a way that wouldn't trigger the\n * depth limit.\n *\n * For this reason, it is advised to cache pointers into variables and not constantly dereference them since the\n * message's traversal limit gets decremented each time.\n */\nexports.DEFAULT_TRAVERSE_LIMIT = 64 << 20; // 64 MiB\n/**\n * When allocating array buffers dynamically (while packing or in certain Arena implementations) the previous buffer's\n * size is multiplied by this number to determine the next buffer's size. This is chosen to keep both time spent\n * reallocating and wasted memory to a minimum.\n *\n * Smaller numbers would save memory at the expense of CPU time.\n */\nexports.GROWTH_FACTOR = 1.5;\n/** A bitmask applied to obtain the size of a list pointer. */\nexports.LIST_SIZE_MASK = 0x00000007;\n/** Maximum number of bytes to dump at once when dumping array buffers to string. */\nexports.MAX_BUFFER_DUMP_BYTES = 8192;\n/** The maximum value for a 32-bit integer. */\nexports.MAX_INT32 = 0x7fffffff;\n/** The maximum value for a 32-bit unsigned integer. */\nexports.MAX_UINT32 = 0xffffffff;\n/** The largest integer that can be precisely represented in JavaScript. */\nexports.MAX_SAFE_INTEGER = 9007199254740991;\n/** Maximum limit on the number of segments in a message stream. */\nexports.MAX_STREAM_SEGMENTS = 512;\n/** The smallest integer that can be precisely represented in JavaScript. */\nexports.MIN_SAFE_INTEGER = -9007199254740991;\n/** Minimum growth increment for a SingleSegmentArena. */\nexports.MIN_SINGLE_SEGMENT_GROWTH = 4096;\n/**\n * This will be `true` if the machine running this code stores numbers natively in little-endian format. This is useful\n * for some numeric type conversions when the endianness does not affect the output. Using the native endianness for\n * these operations is _slightly_ faster.\n */\nexports.NATIVE_LITTLE_ENDIAN = tmpWord.getUint8(0) === 0x02;\n/**\n * When packing a message, this is the number of zero bytes required after a SPAN (0xff) tag is written to the packed\n * message before the span is terminated.\n *\n * This little detail is left up to the implementation because it can be tuned for performance. Setting this to a higher\n * value may help with messages that contain a ton of text/data.\n *\n * It is imperative to never set this below 1 or else BAD THINGS. You have been warned.\n */\nexports.PACK_SPAN_THRESHOLD = 2;\n/**\n * How far to travel into a nested pointer structure during a deep copy; when this limit is exhausted the copy\n * operation will throw an error.\n */\nexports.POINTER_COPY_LIMIT = 32;\n/** A bitmask for looking up the double-far flag on a far pointer. */\nexports.POINTER_DOUBLE_FAR_MASK = 0x00000004;\n/** A bitmask for looking up the pointer type. */\nexports.POINTER_TYPE_MASK = 0x00000003;\n/** Used for some 64-bit conversions, equal to Math.pow(2, 32). */\nexports.VAL32 = 0x100000000;\n/** The maximum value allowed for depth traversal limits. */\nexports.MAX_DEPTH = exports.MAX_INT32;\n/** The maximum byte length for a single segment. */\nexports.MAX_SEGMENT_LENGTH = exports.MAX_UINT32;\n\n//# sourceMappingURL=constants.js.map\n"]},"metadata":{},"sourceType":"script"}