{"ast":null,"code":"'use strict';\n/* @flow */\n\nvar uniqueCountSorted = require('./unique_count_sorted'),\n    numericSort = require('./numeric_sort');\n/**\n * Create a new column x row matrix.\n *\n * @private\n * @param {number} columns\n * @param {number} rows\n * @return {Array<Array<number>>} matrix\n * @example\n * makeMatrix(10, 10);\n */\n\n\nfunction makeMatrix(columns, rows) {\n  var matrix = [];\n\n  for (var i = 0; i < columns; i++) {\n    var column = [];\n\n    for (var j = 0; j < rows; j++) {\n      column.push(0);\n    }\n\n    matrix.push(column);\n  }\n\n  return matrix;\n}\n/**\n * Generates incrementally computed values based on the sums and sums of\n * squares for the data array\n *\n * @private\n * @param {number} j\n * @param {number} i\n * @param {Array<number>} sums\n * @param {Array<number>} sumsOfSquares\n * @return {number}\n * @example\n * ssq(0, 1, [-1, 0, 2], [1, 1, 5]);\n */\n\n\nfunction ssq(j, i, sums, sumsOfSquares) {\n  var sji; // s(j, i)\n\n  if (j > 0) {\n    var muji = (sums[i] - sums[j - 1]) / (i - j + 1); // mu(j, i)\n\n    sji = sumsOfSquares[i] - sumsOfSquares[j - 1] - (i - j + 1) * muji * muji;\n  } else {\n    sji = sumsOfSquares[i] - sums[i] * sums[i] / (i + 1);\n  }\n\n  if (sji < 0) {\n    return 0;\n  }\n\n  return sji;\n}\n/**\n * Function that recursively divides and conquers computations\n * for cluster j\n *\n * @private\n * @param {number} iMin Minimum index in cluster to be computed\n * @param {number} iMax Maximum index in cluster to be computed\n * @param {number} cluster Index of the cluster currently being computed\n * @param {Array<Array<number>>} matrix\n * @param {Array<Array<number>>} backtrackMatrix\n * @param {Array<number>} sums\n * @param {Array<number>} sumsOfSquares\n */\n\n\nfunction fillMatrixColumn(iMin, iMax, cluster, matrix, backtrackMatrix, sums, sumsOfSquares) {\n  if (iMin > iMax) {\n    return;\n  } // Start at midpoint between iMin and iMax\n\n\n  var i = Math.floor((iMin + iMax) / 2);\n  matrix[cluster][i] = matrix[cluster - 1][i - 1];\n  backtrackMatrix[cluster][i] = i;\n  var jlow = cluster; // the lower end for j\n\n  if (iMin > cluster) {\n    jlow = Math.max(jlow, backtrackMatrix[cluster][iMin - 1] || 0);\n  }\n\n  jlow = Math.max(jlow, backtrackMatrix[cluster - 1][i] || 0);\n  var jhigh = i - 1; // the upper end for j\n\n  if (iMax < matrix.length - 1) {\n    jhigh = Math.min(jhigh, backtrackMatrix[cluster][iMax + 1] || 0);\n  }\n\n  var sji;\n  var sjlowi;\n  var ssqjlow;\n  var ssqj;\n\n  for (var j = jhigh; j >= jlow; --j) {\n    sji = ssq(j, i, sums, sumsOfSquares);\n\n    if (sji + matrix[cluster - 1][jlow - 1] >= matrix[cluster][i]) {\n      break;\n    } // Examine the lower bound of the cluster border\n\n\n    sjlowi = ssq(jlow, i, sums, sumsOfSquares);\n    ssqjlow = sjlowi + matrix[cluster - 1][jlow - 1];\n\n    if (ssqjlow < matrix[cluster][i]) {\n      // Shrink the lower bound\n      matrix[cluster][i] = ssqjlow;\n      backtrackMatrix[cluster][i] = jlow;\n    }\n\n    jlow++;\n    ssqj = sji + matrix[cluster - 1][j - 1];\n\n    if (ssqj < matrix[cluster][i]) {\n      matrix[cluster][i] = ssqj;\n      backtrackMatrix[cluster][i] = j;\n    }\n  }\n\n  fillMatrixColumn(iMin, i - 1, cluster, matrix, backtrackMatrix, sums, sumsOfSquares);\n  fillMatrixColumn(i + 1, iMax, cluster, matrix, backtrackMatrix, sums, sumsOfSquares);\n}\n/**\n * Initializes the main matrices used in Ckmeans and kicks\n * off the divide and conquer cluster computation strategy\n *\n * @private\n * @param {Array<number>} data sorted array of values\n * @param {Array<Array<number>>} matrix\n * @param {Array<Array<number>>} backtrackMatrix\n */\n\n\nfunction fillMatrices(data, matrix, backtrackMatrix) {\n  var nValues = matrix[0].length; // Shift values by the median to improve numeric stability\n\n  var shift = data[Math.floor(nValues / 2)]; // Cumulative sum and cumulative sum of squares for all values in data array\n\n  var sums = [];\n  var sumsOfSquares = []; // Initialize first column in matrix & backtrackMatrix\n\n  for (var i = 0, shiftedValue; i < nValues; ++i) {\n    shiftedValue = data[i] - shift;\n\n    if (i === 0) {\n      sums.push(shiftedValue);\n      sumsOfSquares.push(shiftedValue * shiftedValue);\n    } else {\n      sums.push(sums[i - 1] + shiftedValue);\n      sumsOfSquares.push(sumsOfSquares[i - 1] + shiftedValue * shiftedValue);\n    } // Initialize for cluster = 0\n\n\n    matrix[0][i] = ssq(0, i, sums, sumsOfSquares);\n    backtrackMatrix[0][i] = 0;\n  } // Initialize the rest of the columns\n\n\n  var iMin;\n\n  for (var cluster = 1; cluster < matrix.length; ++cluster) {\n    if (cluster < matrix.length - 1) {\n      iMin = cluster;\n    } else {\n      // No need to compute matrix[K-1][0] ... matrix[K-1][N-2]\n      iMin = nValues - 1;\n    }\n\n    fillMatrixColumn(iMin, nValues - 1, cluster, matrix, backtrackMatrix, sums, sumsOfSquares);\n  }\n}\n/**\n * Ckmeans clustering is an improvement on heuristic-based clustering\n * approaches like Jenks. The algorithm was developed in\n * [Haizhou Wang and Mingzhou Song](http://journal.r-project.org/archive/2011-2/RJournal_2011-2_Wang+Song.pdf)\n * as a [dynamic programming](https://en.wikipedia.org/wiki/Dynamic_programming) approach\n * to the problem of clustering numeric data into groups with the least\n * within-group sum-of-squared-deviations.\n *\n * Minimizing the difference within groups - what Wang & Song refer to as\n * `withinss`, or within sum-of-squares, means that groups are optimally\n * homogenous within and the data is split into representative groups.\n * This is very useful for visualization, where you may want to represent\n * a continuous variable in discrete color or style groups. This function\n * can provide groups that emphasize differences between data.\n *\n * Being a dynamic approach, this algorithm is based on two matrices that\n * store incrementally-computed values for squared deviations and backtracking\n * indexes.\n *\n * This implementation is based on Ckmeans 3.4.6, which introduced a new divide\n * and conquer approach that improved runtime from O(kn^2) to O(kn log(n)).\n *\n * Unlike the [original implementation](https://cran.r-project.org/web/packages/Ckmeans.1d.dp/index.html),\n * this implementation does not include any code to automatically determine\n * the optimal number of clusters: this information needs to be explicitly\n * provided.\n *\n * ### References\n * _Ckmeans.1d.dp: Optimal k-means Clustering in One Dimension by Dynamic\n * Programming_ Haizhou Wang and Mingzhou Song ISSN 2073-4859\n *\n * from The R Journal Vol. 3/2, December 2011\n * @param {Array<number>} x input data, as an array of number values\n * @param {number} nClusters number of desired classes. This cannot be\n * greater than the number of values in the data array.\n * @returns {Array<Array<number>>} clustered input\n * @throws {Error} if the number of requested clusters is higher than the size of the data\n * @example\n * ckmeans([-1, 2, -1, 2, 4, 5, 6, -1, 2, -1], 3);\n * // The input, clustered into groups of similar numbers.\n * //= [[-1, -1, -1, -1], [2, 2, 2], [4, 5, 6]]);\n */\n\n\nfunction ckmeans(x\n/*: Array<number> */\n, nClusters\n/*: number */\n)\n/*: Array<Array<number>> */\n{\n  if (nClusters > x.length) {\n    throw new Error('cannot generate more classes than there are data values');\n  }\n\n  var sorted = numericSort(x),\n      // we'll use this as the maximum number of clusters\n  uniqueCount = uniqueCountSorted(sorted); // if all of the input values are identical, there's one cluster\n  // with all of the input in it.\n\n  if (uniqueCount === 1) {\n    return [sorted];\n  } // named 'S' originally\n\n\n  var matrix = makeMatrix(nClusters, sorted.length),\n      // named 'J' originally\n  backtrackMatrix = makeMatrix(nClusters, sorted.length); // This is a dynamic programming way to solve the problem of minimizing\n  // within-cluster sum of squares. It's similar to linear regression\n  // in this way, and this calculation incrementally computes the\n  // sum of squares that are later read.\n\n  fillMatrices(sorted, matrix, backtrackMatrix); // The real work of Ckmeans clustering happens in the matrix generation:\n  // the generated matrices encode all possible clustering combinations, and\n  // once they're generated we can solve for the best clustering groups\n  // very quickly.\n\n  var clusters = [],\n      clusterRight = backtrackMatrix[0].length - 1; // Backtrack the clusters from the dynamic programming matrix. This\n  // starts at the bottom-right corner of the matrix (if the top-left is 0, 0),\n  // and moves the cluster target with the loop.\n\n  for (var cluster = backtrackMatrix.length - 1; cluster >= 0; cluster--) {\n    var clusterLeft = backtrackMatrix[cluster][clusterRight]; // fill the cluster from the sorted input by taking a slice of the\n    // array. the backtrack matrix makes this easy - it stores the\n    // indexes where the cluster should start and end.\n\n    clusters[cluster] = sorted.slice(clusterLeft, clusterRight + 1);\n\n    if (cluster > 0) {\n      clusterRight = clusterLeft - 1;\n    }\n  }\n\n  return clusters;\n}\n\nmodule.exports = ckmeans;","map":{"version":3,"sources":["/home/amax/Autoro/cabana/node_modules/simple-statistics/src/ckmeans.js"],"names":["uniqueCountSorted","require","numericSort","makeMatrix","columns","rows","matrix","i","column","j","push","ssq","sums","sumsOfSquares","sji","muji","fillMatrixColumn","iMin","iMax","cluster","backtrackMatrix","Math","floor","jlow","max","jhigh","length","min","sjlowi","ssqjlow","ssqj","fillMatrices","data","nValues","shift","shiftedValue","ckmeans","x","nClusters","Error","sorted","uniqueCount","clusters","clusterRight","clusterLeft","slice","module","exports"],"mappings":"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","sourcesContent":["'use strict';\n/* @flow */\n\nvar uniqueCountSorted = require('./unique_count_sorted'),\n    numericSort = require('./numeric_sort');\n\n/**\n * Create a new column x row matrix.\n *\n * @private\n * @param {number} columns\n * @param {number} rows\n * @return {Array<Array<number>>} matrix\n * @example\n * makeMatrix(10, 10);\n */\nfunction makeMatrix(columns, rows) {\n    var matrix = [];\n    for (var i = 0; i < columns; i++) {\n        var column = [];\n        for (var j = 0; j < rows; j++) {\n            column.push(0);\n        }\n        matrix.push(column);\n    }\n    return matrix;\n}\n\n/**\n * Generates incrementally computed values based on the sums and sums of\n * squares for the data array\n *\n * @private\n * @param {number} j\n * @param {number} i\n * @param {Array<number>} sums\n * @param {Array<number>} sumsOfSquares\n * @return {number}\n * @example\n * ssq(0, 1, [-1, 0, 2], [1, 1, 5]);\n */\nfunction ssq(j, i, sums, sumsOfSquares) {\n    var sji; // s(j, i)\n    if (j > 0) {\n        var muji = (sums[i] - sums[j - 1]) / (i - j + 1); // mu(j, i)\n        sji = sumsOfSquares[i] - sumsOfSquares[j - 1] - (i - j + 1) * muji * muji;\n    } else {\n        sji = sumsOfSquares[i] - sums[i] * sums[i] / (i + 1);\n    }\n    if (sji < 0) {\n        return 0;\n    }\n    return sji;\n}\n\n/**\n * Function that recursively divides and conquers computations\n * for cluster j\n *\n * @private\n * @param {number} iMin Minimum index in cluster to be computed\n * @param {number} iMax Maximum index in cluster to be computed\n * @param {number} cluster Index of the cluster currently being computed\n * @param {Array<Array<number>>} matrix\n * @param {Array<Array<number>>} backtrackMatrix\n * @param {Array<number>} sums\n * @param {Array<number>} sumsOfSquares\n */\nfunction fillMatrixColumn(iMin, iMax, cluster, matrix, backtrackMatrix, sums, sumsOfSquares) {\n    if (iMin > iMax) {\n        return;\n    }\n\n    // Start at midpoint between iMin and iMax\n    var i = Math.floor((iMin + iMax) / 2);\n\n    matrix[cluster][i] = matrix[cluster - 1][i - 1];\n    backtrackMatrix[cluster][i] = i;\n\n    var jlow = cluster; // the lower end for j\n\n    if (iMin > cluster) {\n        jlow = Math.max(jlow, backtrackMatrix[cluster][iMin - 1] || 0);\n    }\n    jlow = Math.max(jlow, backtrackMatrix[cluster - 1][i] || 0);\n\n    var jhigh = i - 1; // the upper end for j\n    if (iMax < matrix.length - 1) {\n        jhigh = Math.min(jhigh, backtrackMatrix[cluster][iMax + 1] || 0);\n    }\n\n    var sji;\n    var sjlowi;\n    var ssqjlow;\n    var ssqj;\n    for (var j = jhigh; j >= jlow; --j) {\n        sji = ssq(j, i, sums, sumsOfSquares);\n\n        if (sji + matrix[cluster - 1][jlow - 1] >= matrix[cluster][i]) {\n            break;\n        }\n\n        // Examine the lower bound of the cluster border\n        sjlowi = ssq(jlow, i, sums, sumsOfSquares);\n\n        ssqjlow = sjlowi + matrix[cluster - 1][jlow - 1];\n\n        if (ssqjlow < matrix[cluster][i]) {\n            // Shrink the lower bound\n            matrix[cluster][i] = ssqjlow;\n            backtrackMatrix[cluster][i] = jlow;\n        }\n        jlow++;\n\n        ssqj = sji + matrix[cluster - 1][j - 1];\n        if (ssqj < matrix[cluster][i]) {\n            matrix[cluster][i] = ssqj;\n            backtrackMatrix[cluster][i] = j;\n        }\n    }\n\n    fillMatrixColumn(iMin, i - 1, cluster, matrix, backtrackMatrix, sums, sumsOfSquares);\n    fillMatrixColumn(i + 1, iMax, cluster, matrix, backtrackMatrix, sums, sumsOfSquares);\n}\n\n/**\n * Initializes the main matrices used in Ckmeans and kicks\n * off the divide and conquer cluster computation strategy\n *\n * @private\n * @param {Array<number>} data sorted array of values\n * @param {Array<Array<number>>} matrix\n * @param {Array<Array<number>>} backtrackMatrix\n */\nfunction fillMatrices(data, matrix, backtrackMatrix) {\n    var nValues = matrix[0].length;\n\n    // Shift values by the median to improve numeric stability\n    var shift = data[Math.floor(nValues / 2)];\n\n    // Cumulative sum and cumulative sum of squares for all values in data array\n    var sums = [];\n    var sumsOfSquares = [];\n\n    // Initialize first column in matrix & backtrackMatrix\n    for (var i = 0, shiftedValue; i < nValues; ++i) {\n        shiftedValue = data[i] - shift;\n        if (i === 0) {\n            sums.push(shiftedValue);\n            sumsOfSquares.push(shiftedValue * shiftedValue);\n        } else {\n            sums.push(sums[i - 1] + shiftedValue);\n            sumsOfSquares.push(sumsOfSquares[i - 1] + shiftedValue * shiftedValue);\n        }\n\n        // Initialize for cluster = 0\n        matrix[0][i] = ssq(0, i, sums, sumsOfSquares);\n        backtrackMatrix[0][i] = 0;\n    }\n\n    // Initialize the rest of the columns\n    var iMin;\n    for (var cluster = 1; cluster < matrix.length; ++cluster) {\n        if (cluster < matrix.length - 1) {\n            iMin = cluster;\n        } else {\n            // No need to compute matrix[K-1][0] ... matrix[K-1][N-2]\n            iMin = nValues - 1;\n        }\n\n        fillMatrixColumn(iMin, nValues - 1, cluster, matrix, backtrackMatrix, sums, sumsOfSquares);\n    }\n}\n\n/**\n * Ckmeans clustering is an improvement on heuristic-based clustering\n * approaches like Jenks. The algorithm was developed in\n * [Haizhou Wang and Mingzhou Song](http://journal.r-project.org/archive/2011-2/RJournal_2011-2_Wang+Song.pdf)\n * as a [dynamic programming](https://en.wikipedia.org/wiki/Dynamic_programming) approach\n * to the problem of clustering numeric data into groups with the least\n * within-group sum-of-squared-deviations.\n *\n * Minimizing the difference within groups - what Wang & Song refer to as\n * `withinss`, or within sum-of-squares, means that groups are optimally\n * homogenous within and the data is split into representative groups.\n * This is very useful for visualization, where you may want to represent\n * a continuous variable in discrete color or style groups. This function\n * can provide groups that emphasize differences between data.\n *\n * Being a dynamic approach, this algorithm is based on two matrices that\n * store incrementally-computed values for squared deviations and backtracking\n * indexes.\n *\n * This implementation is based on Ckmeans 3.4.6, which introduced a new divide\n * and conquer approach that improved runtime from O(kn^2) to O(kn log(n)).\n *\n * Unlike the [original implementation](https://cran.r-project.org/web/packages/Ckmeans.1d.dp/index.html),\n * this implementation does not include any code to automatically determine\n * the optimal number of clusters: this information needs to be explicitly\n * provided.\n *\n * ### References\n * _Ckmeans.1d.dp: Optimal k-means Clustering in One Dimension by Dynamic\n * Programming_ Haizhou Wang and Mingzhou Song ISSN 2073-4859\n *\n * from The R Journal Vol. 3/2, December 2011\n * @param {Array<number>} x input data, as an array of number values\n * @param {number} nClusters number of desired classes. This cannot be\n * greater than the number of values in the data array.\n * @returns {Array<Array<number>>} clustered input\n * @throws {Error} if the number of requested clusters is higher than the size of the data\n * @example\n * ckmeans([-1, 2, -1, 2, 4, 5, 6, -1, 2, -1], 3);\n * // The input, clustered into groups of similar numbers.\n * //= [[-1, -1, -1, -1], [2, 2, 2], [4, 5, 6]]);\n */\nfunction ckmeans(x/*: Array<number> */, nClusters/*: number */)/*: Array<Array<number>> */ {\n\n    if (nClusters > x.length) {\n        throw new Error('cannot generate more classes than there are data values');\n    }\n\n    var sorted = numericSort(x),\n        // we'll use this as the maximum number of clusters\n        uniqueCount = uniqueCountSorted(sorted);\n\n    // if all of the input values are identical, there's one cluster\n    // with all of the input in it.\n    if (uniqueCount === 1) {\n        return [sorted];\n    }\n\n    // named 'S' originally\n    var matrix = makeMatrix(nClusters, sorted.length),\n        // named 'J' originally\n        backtrackMatrix = makeMatrix(nClusters, sorted.length);\n\n    // This is a dynamic programming way to solve the problem of minimizing\n    // within-cluster sum of squares. It's similar to linear regression\n    // in this way, and this calculation incrementally computes the\n    // sum of squares that are later read.\n    fillMatrices(sorted, matrix, backtrackMatrix);\n\n    // The real work of Ckmeans clustering happens in the matrix generation:\n    // the generated matrices encode all possible clustering combinations, and\n    // once they're generated we can solve for the best clustering groups\n    // very quickly.\n    var clusters = [],\n        clusterRight = backtrackMatrix[0].length - 1;\n\n    // Backtrack the clusters from the dynamic programming matrix. This\n    // starts at the bottom-right corner of the matrix (if the top-left is 0, 0),\n    // and moves the cluster target with the loop.\n    for (var cluster = backtrackMatrix.length - 1; cluster >= 0; cluster--) {\n\n        var clusterLeft = backtrackMatrix[cluster][clusterRight];\n\n        // fill the cluster from the sorted input by taking a slice of the\n        // array. the backtrack matrix makes this easy - it stores the\n        // indexes where the cluster should start and end.\n        clusters[cluster] = sorted.slice(clusterLeft, clusterRight + 1);\n\n        if (cluster > 0) {\n            clusterRight = clusterLeft - 1;\n        }\n    }\n\n    return clusters;\n}\n\nmodule.exports = ckmeans;\n"]},"metadata":{},"sourceType":"script"}