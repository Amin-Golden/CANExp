{"ast":null,"code":"\"use strict\";\n/**\n * @author jdiaz5513\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar tslib_1 = require(\"tslib\");\n\nvar debug_1 = require(\"debug\");\n\nvar list_element_size_1 = require(\"../list-element-size\");\n\nvar list_1 = require(\"./list\");\n\nvar pointer_1 = require(\"./pointer\");\n\nvar pointer_type_1 = require(\"./pointer-type\");\n\nvar trace = debug_1.default('capnp:data');\ntrace('load');\n/**\n * A generic blob of bytes. Can be converted to a DataView or Uint8Array to access its contents using `toDataView()` and\n * `toUint8Array()`. Use `copyBuffer()` to copy an entire buffer at once.\n *\n * @export\n * @class Data\n * @extends {List<number>}\n */\n\nvar Data =\n/** @class */\nfunction (_super) {\n  tslib_1.__extends(Data, _super);\n\n  function Data() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  Data.fromPointer = function (pointer) {\n    pointer_1.validate(pointer_type_1.PointerType.LIST, pointer, list_element_size_1.ListElementSize.BYTE);\n    return this._fromPointerUnchecked(pointer);\n  };\n\n  Data._fromPointerUnchecked = function (pointer) {\n    return new this(pointer.segment, pointer.byteOffset, pointer._capnp.depthLimit);\n  };\n  /**\n   * Copy the contents of `src` into this Data pointer. If `src` is smaller than the length of this pointer then the\n   * remaining bytes will be zeroed out. Extra bytes in `src` are ignored.\n   *\n   * @param {(ArrayBuffer | ArrayBufferView)} src The source buffer.\n   * @returns {void}\n   */\n  // TODO: Would be nice to have a way to zero-copy a buffer by allocating a new segment into the message with that\n  // buffer data.\n\n\n  Data.prototype.copyBuffer = function (src) {\n    var c = pointer_1.getContent(this);\n    var dstLength = this.getLength();\n    var srcLength = src.byteLength;\n    var i = src instanceof ArrayBuffer ? new Uint8Array(src) : new Uint8Array(src.buffer, src.byteOffset, Math.min(dstLength, srcLength));\n    var o = new Uint8Array(c.segment.buffer, c.byteOffset, this.getLength());\n    o.set(i);\n\n    if (dstLength > srcLength) {\n      trace('Zeroing out remaining %d bytes after copy into %s.', dstLength - srcLength, this);\n      o.fill(0, srcLength, dstLength);\n    } else if (dstLength < srcLength) {\n      trace('Truncated %d bytes from source buffer while copying to %s.', srcLength - dstLength, this);\n    }\n  };\n  /**\n   * Read a byte from the specified offset.\n   *\n   * @param {number} byteOffset The byte offset to read.\n   * @returns {number} The byte value.\n   */\n\n\n  Data.prototype.get = function (byteOffset) {\n    var c = pointer_1.getContent(this);\n    return c.segment.getUint8(c.byteOffset + byteOffset);\n  };\n  /**\n   * Write a byte at the specified offset.\n   *\n   * @param {number} byteOffset The byte offset to set.\n   * @param {number} value The byte value to set.\n   * @returns {void}\n   */\n\n\n  Data.prototype.set = function (byteOffset, value) {\n    var c = pointer_1.getContent(this);\n    c.segment.setUint8(c.byteOffset + byteOffset, value);\n  };\n  /**\n   * Creates a **copy** of the underlying buffer data and returns it as an ArrayBuffer.\n   *\n   * To obtain a reference to the underlying buffer instead, use `toUint8Array()` or `toDataView()`.\n   *\n   * @returns {ArrayBuffer} A copy of this data buffer.\n   */\n\n\n  Data.prototype.toArrayBuffer = function () {\n    var c = pointer_1.getContent(this);\n    return c.segment.buffer.slice(c.byteOffset, c.byteOffset + this.getLength());\n  };\n  /**\n   * Convert this Data pointer to a DataView representing the pointer's contents.\n   *\n   * WARNING: The DataView references memory from a message segment, so do not venture outside the bounds of the\n   * DataView or else BAD THINGS.\n   *\n   * @returns {DataView} A live reference to the underlying buffer.\n   */\n\n\n  Data.prototype.toDataView = function () {\n    var c = pointer_1.getContent(this);\n    return new DataView(c.segment.buffer, c.byteOffset, this.getLength());\n  };\n\n  Data.prototype.toString = function () {\n    return \"Data_\" + _super.prototype.toString.call(this);\n  };\n  /**\n   * Convert this Data pointer to a Uint8Array representing the pointer's contents.\n   *\n   * WARNING: The Uint8Array references memory from a message segment, so do not venture outside the bounds of the\n   * Uint8Array or else BAD THINGS.\n   *\n   * @returns {DataView} A live reference to the underlying buffer.\n   */\n\n\n  Data.prototype.toUint8Array = function () {\n    var c = pointer_1.getContent(this);\n    return new Uint8Array(c.segment.buffer, c.byteOffset, this.getLength());\n  };\n\n  return Data;\n}(list_1.List);\n\nexports.Data = Data;","map":{"version":3,"sources":["serialization/pointers/data.ts"],"names":[],"mappings":"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","sourceRoot":"../../../src","sourcesContent":["\"use strict\";\n/**\n * @author jdiaz5513\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = require(\"tslib\");\nvar debug_1 = require(\"debug\");\nvar list_element_size_1 = require(\"../list-element-size\");\nvar list_1 = require(\"./list\");\nvar pointer_1 = require(\"./pointer\");\nvar pointer_type_1 = require(\"./pointer-type\");\nvar trace = debug_1.default('capnp:data');\ntrace('load');\n/**\n * A generic blob of bytes. Can be converted to a DataView or Uint8Array to access its contents using `toDataView()` and\n * `toUint8Array()`. Use `copyBuffer()` to copy an entire buffer at once.\n *\n * @export\n * @class Data\n * @extends {List<number>}\n */\nvar Data = /** @class */ (function (_super) {\n    tslib_1.__extends(Data, _super);\n    function Data() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Data.fromPointer = function (pointer) {\n        pointer_1.validate(pointer_type_1.PointerType.LIST, pointer, list_element_size_1.ListElementSize.BYTE);\n        return this._fromPointerUnchecked(pointer);\n    };\n    Data._fromPointerUnchecked = function (pointer) {\n        return new this(pointer.segment, pointer.byteOffset, pointer._capnp.depthLimit);\n    };\n    /**\n     * Copy the contents of `src` into this Data pointer. If `src` is smaller than the length of this pointer then the\n     * remaining bytes will be zeroed out. Extra bytes in `src` are ignored.\n     *\n     * @param {(ArrayBuffer | ArrayBufferView)} src The source buffer.\n     * @returns {void}\n     */\n    // TODO: Would be nice to have a way to zero-copy a buffer by allocating a new segment into the message with that\n    // buffer data.\n    Data.prototype.copyBuffer = function (src) {\n        var c = pointer_1.getContent(this);\n        var dstLength = this.getLength();\n        var srcLength = src.byteLength;\n        var i = src instanceof ArrayBuffer\n            ? new Uint8Array(src)\n            : new Uint8Array(src.buffer, src.byteOffset, Math.min(dstLength, srcLength));\n        var o = new Uint8Array(c.segment.buffer, c.byteOffset, this.getLength());\n        o.set(i);\n        if (dstLength > srcLength) {\n            trace('Zeroing out remaining %d bytes after copy into %s.', dstLength - srcLength, this);\n            o.fill(0, srcLength, dstLength);\n        }\n        else if (dstLength < srcLength) {\n            trace('Truncated %d bytes from source buffer while copying to %s.', srcLength - dstLength, this);\n        }\n    };\n    /**\n     * Read a byte from the specified offset.\n     *\n     * @param {number} byteOffset The byte offset to read.\n     * @returns {number} The byte value.\n     */\n    Data.prototype.get = function (byteOffset) {\n        var c = pointer_1.getContent(this);\n        return c.segment.getUint8(c.byteOffset + byteOffset);\n    };\n    /**\n     * Write a byte at the specified offset.\n     *\n     * @param {number} byteOffset The byte offset to set.\n     * @param {number} value The byte value to set.\n     * @returns {void}\n     */\n    Data.prototype.set = function (byteOffset, value) {\n        var c = pointer_1.getContent(this);\n        c.segment.setUint8(c.byteOffset + byteOffset, value);\n    };\n    /**\n     * Creates a **copy** of the underlying buffer data and returns it as an ArrayBuffer.\n     *\n     * To obtain a reference to the underlying buffer instead, use `toUint8Array()` or `toDataView()`.\n     *\n     * @returns {ArrayBuffer} A copy of this data buffer.\n     */\n    Data.prototype.toArrayBuffer = function () {\n        var c = pointer_1.getContent(this);\n        return c.segment.buffer.slice(c.byteOffset, c.byteOffset + this.getLength());\n    };\n    /**\n     * Convert this Data pointer to a DataView representing the pointer's contents.\n     *\n     * WARNING: The DataView references memory from a message segment, so do not venture outside the bounds of the\n     * DataView or else BAD THINGS.\n     *\n     * @returns {DataView} A live reference to the underlying buffer.\n     */\n    Data.prototype.toDataView = function () {\n        var c = pointer_1.getContent(this);\n        return new DataView(c.segment.buffer, c.byteOffset, this.getLength());\n    };\n    Data.prototype.toString = function () {\n        return \"Data_\" + _super.prototype.toString.call(this);\n    };\n    /**\n     * Convert this Data pointer to a Uint8Array representing the pointer's contents.\n     *\n     * WARNING: The Uint8Array references memory from a message segment, so do not venture outside the bounds of the\n     * Uint8Array or else BAD THINGS.\n     *\n     * @returns {DataView} A live reference to the underlying buffer.\n     */\n    Data.prototype.toUint8Array = function () {\n        var c = pointer_1.getContent(this);\n        return new Uint8Array(c.segment.buffer, c.byteOffset, this.getLength());\n    };\n    return Data;\n}(list_1.List));\nexports.Data = Data;\n\n//# sourceMappingURL=data.js.map\n"]},"metadata":{},"sourceType":"script"}