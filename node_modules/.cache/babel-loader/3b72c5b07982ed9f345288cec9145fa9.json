{"ast":null,"code":"/* @flow */\n'use strict';\n/**\n * Implementation of [Combinations](https://en.wikipedia.org/wiki/Combination) with replacement\n * Combinations are unique subsets of a collection - in this case, k x from a collection at a time.\n * 'With replacement' means that a given element can be chosen multiple times.\n * Unlike permutation, order doesn't matter for combinations.\n * \n * @param {Array} x any type of data\n * @param {int} k the number of objects in each group (without replacement)\n * @returns {Array<Array>} array of permutations\n * @example\n * combinationsReplacement([1, 2], 2); // => [[1, 1], [1, 2], [2, 2]]\n */\n\nfunction combinationsReplacement(x\n/*: Array<any> */\n, k\n/*: number */\n) {\n  var combinationList = [];\n\n  for (var i = 0; i < x.length; i++) {\n    if (k === 1) {\n      // If we're requested to find only one element, we don't need\n      // to recurse: just push `x[i]` onto the list of combinations.\n      combinationList.push([x[i]]);\n    } else {\n      // Otherwise, recursively find combinations, given `k - 1`. Note that\n      // we request `k - 1`, so if you were looking for k=3 combinations, we're\n      // requesting k=2. This -1 gets reversed in the for loop right after this\n      // code, since we concatenate `x[i]` onto the selected combinations,\n      // bringing `k` back up to your requested level.\n      // This recursion may go many levels deep, since it only stops once\n      // k=1.\n      var subsetCombinations = combinationsReplacement(x.slice(i, x.length), k - 1);\n\n      for (var j = 0; j < subsetCombinations.length; j++) {\n        combinationList.push([x[i]].concat(subsetCombinations[j]));\n      }\n    }\n  }\n\n  return combinationList;\n}\n\nmodule.exports = combinationsReplacement;","map":{"version":3,"sources":["/home/amax/Autoro/cabana/node_modules/simple-statistics/src/combinations_replacement.js"],"names":["combinationsReplacement","x","k","combinationList","i","length","push","subsetCombinations","slice","j","concat","module","exports"],"mappings":"AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,SAASA,uBAAT,CACIC;AAAE;AADN,EAEIC;AAAE;AAFN,EAEqB;AAEjB,MAAIC,eAAe,GAAG,EAAtB;;AAEA,OAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGH,CAAC,CAACI,MAAtB,EAA8BD,CAAC,EAA/B,EAAmC;AAC/B,QAAIF,CAAC,KAAK,CAAV,EAAa;AACT;AACA;AACAC,MAAAA,eAAe,CAACG,IAAhB,CAAqB,CAACL,CAAC,CAACG,CAAD,CAAF,CAArB;AACH,KAJD,MAIO;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAIG,kBAAkB,GAAGP,uBAAuB,CAC5CC,CAAC,CAACO,KAAF,CAAQJ,CAAR,EAAWH,CAAC,CAACI,MAAb,CAD4C,EAE5CH,CAAC,GAAG,CAFwC,CAAhD;;AAIA,WAAK,IAAIO,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGF,kBAAkB,CAACF,MAAvC,EAA+CI,CAAC,EAAhD,EAAoD;AAChDN,QAAAA,eAAe,CAACG,IAAhB,CAAqB,CAACL,CAAC,CAACG,CAAD,CAAF,EAChBM,MADgB,CACTH,kBAAkB,CAACE,CAAD,CADT,CAArB;AAEH;AACJ;AACJ;;AAED,SAAON,eAAP;AACH;;AAEDQ,MAAM,CAACC,OAAP,GAAiBZ,uBAAjB","sourcesContent":["/* @flow */\n'use strict';\n\n/**\n * Implementation of [Combinations](https://en.wikipedia.org/wiki/Combination) with replacement\n * Combinations are unique subsets of a collection - in this case, k x from a collection at a time.\n * 'With replacement' means that a given element can be chosen multiple times.\n * Unlike permutation, order doesn't matter for combinations.\n * \n * @param {Array} x any type of data\n * @param {int} k the number of objects in each group (without replacement)\n * @returns {Array<Array>} array of permutations\n * @example\n * combinationsReplacement([1, 2], 2); // => [[1, 1], [1, 2], [2, 2]]\n */\nfunction combinationsReplacement(\n    x /*: Array<any> */,\n    k /*: number */) {\n\n    var combinationList = [];\n\n    for (var i = 0; i < x.length; i++) {\n        if (k === 1) {\n            // If we're requested to find only one element, we don't need\n            // to recurse: just push `x[i]` onto the list of combinations.\n            combinationList.push([x[i]])\n        } else {\n            // Otherwise, recursively find combinations, given `k - 1`. Note that\n            // we request `k - 1`, so if you were looking for k=3 combinations, we're\n            // requesting k=2. This -1 gets reversed in the for loop right after this\n            // code, since we concatenate `x[i]` onto the selected combinations,\n            // bringing `k` back up to your requested level.\n            // This recursion may go many levels deep, since it only stops once\n            // k=1.\n            var subsetCombinations = combinationsReplacement(\n                x.slice(i, x.length),\n                k - 1);\n\n            for (var j = 0; j < subsetCombinations.length; j++) {\n                combinationList.push([x[i]]\n                    .concat(subsetCombinations[j]));\n            }\n        }\n    }\n\n    return combinationList;\n}\n\nmodule.exports = combinationsReplacement;\n"]},"metadata":{},"sourceType":"script"}