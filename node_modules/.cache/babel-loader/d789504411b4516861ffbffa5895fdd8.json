{"ast":null,"code":"'use strict';\n/* @flow */\n\n/**\n * [Bayesian Classifier](http://en.wikipedia.org/wiki/Naive_Bayes_classifier)\n *\n * This is a naïve bayesian classifier that takes\n * singly-nested objects.\n *\n * @class\n * @example\n * var bayes = new BayesianClassifier();\n * bayes.train({\n *   species: 'Cat'\n * }, 'animal');\n * var result = bayes.score({\n *   species: 'Cat'\n * })\n * // result\n * // {\n * //   animal: 1\n * // }\n */\n\nfunction BayesianClassifier() {\n  // The number of items that are currently\n  // classified in the model\n  this.totalCount = 0; // Every item classified in the model\n\n  this.data = {};\n}\n/**\n * Train the classifier with a new item, which has a single\n * dimension of Javascript literal keys and values.\n *\n * @param {Object} item an object with singly-deep properties\n * @param {string} category the category this item belongs to\n * @return {undefined} adds the item to the classifier\n */\n\n\nBayesianClassifier.prototype.train = function (item, category) {\n  // If the data object doesn't have any values\n  // for this category, create a new object for it.\n  if (!this.data[category]) {\n    this.data[category] = {};\n  } // Iterate through each key in the item.\n\n\n  for (var k in item) {\n    var v = item[k]; // Initialize the nested object `data[category][k][item[k]]`\n    // with an object of keys that equal 0.\n\n    if (this.data[category][k] === undefined) {\n      this.data[category][k] = {};\n    }\n\n    if (this.data[category][k][v] === undefined) {\n      this.data[category][k][v] = 0;\n    } // And increment the key for this key/value combination.\n\n\n    this.data[category][k][v]++;\n  } // Increment the number of items classified\n\n\n  this.totalCount++;\n};\n/**\n * Generate a score of how well this item matches all\n * possible categories based on its attributes\n *\n * @param {Object} item an item in the same format as with train\n * @returns {Object} of probabilities that this item belongs to a\n * given category.\n */\n\n\nBayesianClassifier.prototype.score = function (item) {\n  // Initialize an empty array of odds per category.\n  var odds = {},\n      category; // Iterate through each key in the item,\n  // then iterate through each category that has been used\n  // in previous calls to `.train()`\n\n  for (var k in item) {\n    var v = item[k];\n\n    for (category in this.data) {\n      // Create an empty object for storing key - value combinations\n      // for this category.\n      odds[category] = {}; // If this item doesn't even have a property, it counts for nothing,\n      // but if it does have the property that we're looking for from\n      // the item to categorize, it counts based on how popular it is\n      // versus the whole population.\n\n      if (this.data[category][k]) {\n        odds[category][k + '_' + v] = (this.data[category][k][v] || 0) / this.totalCount;\n      } else {\n        odds[category][k + '_' + v] = 0;\n      }\n    }\n  } // Set up a new object that will contain sums of these odds by category\n\n\n  var oddsSums = {};\n\n  for (category in odds) {\n    // Tally all of the odds for each category-combination pair -\n    // the non-existence of a category does not add anything to the\n    // score.\n    oddsSums[category] = 0;\n\n    for (var combination in odds[category]) {\n      oddsSums[category] += odds[category][combination];\n    }\n  }\n\n  return oddsSums;\n};\n\nmodule.exports = BayesianClassifier;","map":{"version":3,"sources":["/home/amax/Autoro/cabana/node_modules/simple-statistics/src/bayesian_classifier.js"],"names":["BayesianClassifier","totalCount","data","prototype","train","item","category","k","v","undefined","score","odds","oddsSums","combination","module","exports"],"mappings":"AAAA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,SAASA,kBAAT,GAA8B;AAC1B;AACA;AACA,OAAKC,UAAL,GAAkB,CAAlB,CAH0B,CAI1B;;AACA,OAAKC,IAAL,GAAY,EAAZ;AACH;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACAF,kBAAkB,CAACG,SAAnB,CAA6BC,KAA7B,GAAqC,UAASC,IAAT,EAAeC,QAAf,EAAyB;AAC1D;AACA;AACA,MAAI,CAAC,KAAKJ,IAAL,CAAUI,QAAV,CAAL,EAA0B;AACtB,SAAKJ,IAAL,CAAUI,QAAV,IAAsB,EAAtB;AACH,GALyD,CAO1D;;;AACA,OAAK,IAAIC,CAAT,IAAcF,IAAd,EAAoB;AAChB,QAAIG,CAAC,GAAGH,IAAI,CAACE,CAAD,CAAZ,CADgB,CAEhB;AACA;;AACA,QAAI,KAAKL,IAAL,CAAUI,QAAV,EAAoBC,CAApB,MAA2BE,SAA/B,EAA0C;AACtC,WAAKP,IAAL,CAAUI,QAAV,EAAoBC,CAApB,IAAyB,EAAzB;AACH;;AACD,QAAI,KAAKL,IAAL,CAAUI,QAAV,EAAoBC,CAApB,EAAuBC,CAAvB,MAA8BC,SAAlC,EAA6C;AACzC,WAAKP,IAAL,CAAUI,QAAV,EAAoBC,CAApB,EAAuBC,CAAvB,IAA4B,CAA5B;AACH,KATe,CAWhB;;;AACA,SAAKN,IAAL,CAAUI,QAAV,EAAoBC,CAApB,EAAuBC,CAAvB;AACH,GArByD,CAuB1D;;;AACA,OAAKP,UAAL;AACH,CAzBD;AA2BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACAD,kBAAkB,CAACG,SAAnB,CAA6BO,KAA7B,GAAqC,UAASL,IAAT,EAAe;AAChD;AACA,MAAIM,IAAI,GAAG,EAAX;AAAA,MAAeL,QAAf,CAFgD,CAGhD;AACA;AACA;;AACA,OAAK,IAAIC,CAAT,IAAcF,IAAd,EAAoB;AAChB,QAAIG,CAAC,GAAGH,IAAI,CAACE,CAAD,CAAZ;;AACA,SAAKD,QAAL,IAAiB,KAAKJ,IAAtB,EAA4B;AACxB;AACA;AACAS,MAAAA,IAAI,CAACL,QAAD,CAAJ,GAAiB,EAAjB,CAHwB,CAKxB;AACA;AACA;AACA;;AACA,UAAI,KAAKJ,IAAL,CAAUI,QAAV,EAAoBC,CAApB,CAAJ,EAA4B;AACxBI,QAAAA,IAAI,CAACL,QAAD,CAAJ,CAAeC,CAAC,GAAG,GAAJ,GAAUC,CAAzB,IAA8B,CAAC,KAAKN,IAAL,CAAUI,QAAV,EAAoBC,CAApB,EAAuBC,CAAvB,KAA6B,CAA9B,IAAmC,KAAKP,UAAtE;AACH,OAFD,MAEO;AACHU,QAAAA,IAAI,CAACL,QAAD,CAAJ,CAAeC,CAAC,GAAG,GAAJ,GAAUC,CAAzB,IAA8B,CAA9B;AACH;AACJ;AACJ,GAvB+C,CAyBhD;;;AACA,MAAII,QAAQ,GAAG,EAAf;;AAEA,OAAKN,QAAL,IAAiBK,IAAjB,EAAuB;AACnB;AACA;AACA;AACAC,IAAAA,QAAQ,CAACN,QAAD,CAAR,GAAqB,CAArB;;AACA,SAAK,IAAIO,WAAT,IAAwBF,IAAI,CAACL,QAAD,CAA5B,EAAwC;AACpCM,MAAAA,QAAQ,CAACN,QAAD,CAAR,IAAsBK,IAAI,CAACL,QAAD,CAAJ,CAAeO,WAAf,CAAtB;AACH;AACJ;;AAED,SAAOD,QAAP;AACH,CAvCD;;AAyCAE,MAAM,CAACC,OAAP,GAAiBf,kBAAjB","sourcesContent":["'use strict';\n/* @flow */\n\n/**\n * [Bayesian Classifier](http://en.wikipedia.org/wiki/Naive_Bayes_classifier)\n *\n * This is a naïve bayesian classifier that takes\n * singly-nested objects.\n *\n * @class\n * @example\n * var bayes = new BayesianClassifier();\n * bayes.train({\n *   species: 'Cat'\n * }, 'animal');\n * var result = bayes.score({\n *   species: 'Cat'\n * })\n * // result\n * // {\n * //   animal: 1\n * // }\n */\nfunction BayesianClassifier() {\n    // The number of items that are currently\n    // classified in the model\n    this.totalCount = 0;\n    // Every item classified in the model\n    this.data = {};\n}\n\n/**\n * Train the classifier with a new item, which has a single\n * dimension of Javascript literal keys and values.\n *\n * @param {Object} item an object with singly-deep properties\n * @param {string} category the category this item belongs to\n * @return {undefined} adds the item to the classifier\n */\nBayesianClassifier.prototype.train = function(item, category) {\n    // If the data object doesn't have any values\n    // for this category, create a new object for it.\n    if (!this.data[category]) {\n        this.data[category] = {};\n    }\n\n    // Iterate through each key in the item.\n    for (var k in item) {\n        var v = item[k];\n        // Initialize the nested object `data[category][k][item[k]]`\n        // with an object of keys that equal 0.\n        if (this.data[category][k] === undefined) {\n            this.data[category][k] = {};\n        }\n        if (this.data[category][k][v] === undefined) {\n            this.data[category][k][v] = 0;\n        }\n\n        // And increment the key for this key/value combination.\n        this.data[category][k][v]++;\n    }\n\n    // Increment the number of items classified\n    this.totalCount++;\n};\n\n/**\n * Generate a score of how well this item matches all\n * possible categories based on its attributes\n *\n * @param {Object} item an item in the same format as with train\n * @returns {Object} of probabilities that this item belongs to a\n * given category.\n */\nBayesianClassifier.prototype.score = function(item) {\n    // Initialize an empty array of odds per category.\n    var odds = {}, category;\n    // Iterate through each key in the item,\n    // then iterate through each category that has been used\n    // in previous calls to `.train()`\n    for (var k in item) {\n        var v = item[k];\n        for (category in this.data) {\n            // Create an empty object for storing key - value combinations\n            // for this category.\n            odds[category] = {};\n\n            // If this item doesn't even have a property, it counts for nothing,\n            // but if it does have the property that we're looking for from\n            // the item to categorize, it counts based on how popular it is\n            // versus the whole population.\n            if (this.data[category][k]) {\n                odds[category][k + '_' + v] = (this.data[category][k][v] || 0) / this.totalCount;\n            } else {\n                odds[category][k + '_' + v] = 0;\n            }\n        }\n    }\n\n    // Set up a new object that will contain sums of these odds by category\n    var oddsSums = {};\n\n    for (category in odds) {\n        // Tally all of the odds for each category-combination pair -\n        // the non-existence of a category does not add anything to the\n        // score.\n        oddsSums[category] = 0;\n        for (var combination in odds[category]) {\n            oddsSums[category] += odds[category][combination];\n        }\n    }\n\n    return oddsSums;\n};\n\nmodule.exports = BayesianClassifier;\n"]},"metadata":{},"sourceType":"script"}