{"ast":null,"code":"\"use strict\";\n/**\n * @author jdiaz5513\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar constants_1 = require(\"../constants\");\n\nvar errors_1 = require(\"../errors\");\n/**\n * Compute the Hamming weight (number of bits set to 1) of a number. Used to figure out how many bytes follow a tag byte\n * while computing the size of a packed message.\n *\n * WARNING: Using this with floating point numbers will void your warranty.\n *\n * @param {number} x A real integer.\n * @returns {number} The hamming weight (integer).\n */\n\n\nfunction getHammingWeight(x) {\n  // Thanks, HACKMEM!\n  var w = x - (x >> 1 & 0x55555555);\n  w = (w & 0x33333333) + (w >> 2 & 0x33333333);\n  return (w + (w >> 4) & 0x0f0f0f0f) * 0x01010101 >> 24;\n}\n\nexports.getHammingWeight = getHammingWeight;\n/**\n * Compute the tag byte from the 8 bytes of a 64-bit word.\n *\n * @param {byte} a The first byte.\n * @param {byte} b The second byte.\n * @param {byte} c The third byte.\n * @param {byte} d The fourth byte.\n * @param {byte} e The fifth byte.\n * @param {byte} f The sixth byte.\n * @param {byte} g The seventh byte.\n * @param {byte} h The eighth byte (phew!).\n * @returns {number} The tag byte.\n */\n\nfunction getTagByte(a, b, c, d, e, f, g, h) {\n  // Yes, it's pretty. Don't touch it.\n  return (a === 0 ? 0 : 1) | (b === 0 ? 0 : 2) | (c === 0 ? 0 : 4) | (d === 0 ? 0 : 8) | (e === 0 ? 0 : 16) | (f === 0 ? 0 : 32) | (g === 0 ? 0 : 64) | (h === 0 ? 0 : 128);\n}\n\nexports.getTagByte = getTagByte;\n/**\n * Efficiently calculate the length of a packed Cap'n Proto message.\n *\n * @export\n * @param {ArrayBuffer} packed The packed message.\n * @returns {number} The length of the unpacked message in bytes.\n */\n\nfunction getUnpackedByteLength(packed) {\n  var p = new Uint8Array(packed);\n  var wordLength = 0;\n  var lastTag = 0x77;\n\n  for (var i = 0; i < p.byteLength;) {\n    var tag = p[i];\n\n    if (lastTag === 0\n    /* ZERO */\n    ) {\n      wordLength += tag;\n      i++;\n      lastTag = 0x77;\n    } else if (lastTag === 255\n    /* SPAN */\n    ) {\n      wordLength += tag;\n      i += tag * 8 + 1;\n      lastTag = 0x77;\n    } else {\n      wordLength++;\n      i += getHammingWeight(tag) + 1;\n      lastTag = tag;\n    }\n  }\n\n  return wordLength * 8;\n}\n\nexports.getUnpackedByteLength = getUnpackedByteLength;\n/**\n * Compute the number of zero bytes that occur in a given 64-bit word, provided as eight separate bytes.\n *\n * @param {byte} a The first byte.\n * @param {byte} b The second byte.\n * @param {byte} c The third byte.\n * @param {byte} d The fourth byte.\n * @param {byte} e The fifth byte.\n * @param {byte} f The sixth byte.\n * @param {byte} g The seventh byte.\n * @param {byte} h The eighth byte (phew!).\n * @returns {number} The number of these bytes that are zero.\n */\n\nfunction getZeroByteCount(a, b, c, d, e, f, g, h) {\n  return (a === 0 ? 1 : 0) + (b === 0 ? 1 : 0) + (c === 0 ? 1 : 0) + (d === 0 ? 1 : 0) + (e === 0 ? 1 : 0) + (f === 0 ? 1 : 0) + (g === 0 ? 1 : 0) + (h === 0 ? 1 : 0);\n}\n\nexports.getZeroByteCount = getZeroByteCount;\n/**\n * Pack a section of a Cap'n Proto message into a compressed format. This will efficiently compress zero bytes (which\n * are common in idiomatic Cap'n Proto messages) into a compact form.\n *\n * For stream-framed messages this is called once for the frame header and once again for each segment in the message.\n *\n * The returned array buffer is trimmed to the exact size of the packed message with a single copy operation at the end.\n * This should be decent on CPU time but does require quite a lot of memory (a normal array is filled up with each\n * packed byte until the packing is complete).\n *\n * @export\n * @param {ArrayBuffer} unpacked The message to pack.\n * @param {number} [byteOffset] Starting byte offset to read bytes from, defaults to 0.\n * @param {number} [byteLength] Total number of bytes to read, defaults to the remainder of the buffer contents.\n * @returns {ArrayBuffer} A packed version of the message.\n */\n\nfunction pack(unpacked, byteOffset, byteLength) {\n  if (byteOffset === void 0) {\n    byteOffset = 0;\n  }\n\n  if (unpacked.byteLength % 8 !== 0) throw new Error(errors_1.MSG_PACK_NOT_WORD_ALIGNED);\n  var src = new Uint8Array(unpacked, byteOffset, byteLength); // TODO: Maybe we should do this with buffers? This costs more than 8x the final compressed size in temporary RAM.\n\n  var dst = [];\n  /* Just have to be sure it's neither ZERO nor SPAN. */\n\n  var lastTag = 0x77;\n  /** This is where we need to remember to write the SPAN tag (0xff). */\n\n  var spanTagOffset = NaN;\n  /** How many words have been copied during the current span. */\n\n  var spanWordLength = 0;\n  /**\n   * When this hits zero, we've had PACK_SPAN_THRESHOLD zero bytes pass by and it's time to bail from the span.\n   */\n\n  var spanThreshold = constants_1.PACK_SPAN_THRESHOLD;\n\n  for (var srcByteOffset = 0; srcByteOffset < src.byteLength; srcByteOffset += 8) {\n    /** Read in the entire word. Yes, this feels silly but it's fast! */\n    var a = src[srcByteOffset];\n    var b = src[srcByteOffset + 1];\n    var c = src[srcByteOffset + 2];\n    var d = src[srcByteOffset + 3];\n    var e = src[srcByteOffset + 4];\n    var f = src[srcByteOffset + 5];\n    var g = src[srcByteOffset + 6];\n    var h = src[srcByteOffset + 7];\n    var tag = getTagByte(a, b, c, d, e, f, g, h);\n    /** If this is true we'll skip the normal word write logic after the switch statement. */\n\n    var skipWriteWord = true;\n\n    switch (lastTag) {\n      case 0\n      /* ZERO */\n      :\n        // We're writing a span of words with all zeroes in them. See if we need to bail out of the fast path.\n        if (tag !== 0\n        /* ZERO */\n        || spanWordLength >= 0xff) {\n          // There's a bit in there or we got too many zeroes. Damn, we need to bail.\n          dst.push(spanWordLength);\n          spanWordLength = 0;\n          skipWriteWord = false;\n        } else {\n          // Kay, let's quickly inc this and go.\n          spanWordLength++;\n        }\n\n        break;\n\n      case 255\n      /* SPAN */\n      :\n        // We're writing a span of nonzero words.\n        var zeroCount = getZeroByteCount(a, b, c, d, e, f, g, h); // See if we need to bail now.\n\n        spanThreshold -= zeroCount;\n\n        if (spanThreshold <= 0 || spanWordLength >= 0xff) {\n          // Alright, time to get packing again. Write the number of words we skipped to the beginning of the span.\n          dst[spanTagOffset] = spanWordLength;\n          spanWordLength = 0;\n          spanThreshold = constants_1.PACK_SPAN_THRESHOLD; // We have to write this word normally.\n\n          skipWriteWord = false;\n        } else {\n          // Just write this word verbatim.\n          dst.push(a, b, c, d, e, f, g, h);\n          spanWordLength++;\n        }\n\n        break;\n\n      default:\n        // Didn't get a special tag last time, let's write this as normal.\n        skipWriteWord = false;\n        break;\n    } // A goto is fast, idk why people keep hatin'.\n\n\n    if (skipWriteWord) continue;\n    dst.push(tag);\n    lastTag = tag;\n    if (a !== 0) dst.push(a);\n    if (b !== 0) dst.push(b);\n    if (c !== 0) dst.push(c);\n    if (d !== 0) dst.push(d);\n    if (e !== 0) dst.push(e);\n    if (f !== 0) dst.push(f);\n    if (g !== 0) dst.push(g);\n    if (h !== 0) dst.push(h); // Record the span tag offset if needed, making sure to actually leave room for it.\n\n    if (tag === 255\n    /* SPAN */\n    ) {\n      spanTagOffset = dst.length;\n      dst.push(0);\n    }\n  } // We're done. If we were writing a span let's finish it.\n\n\n  if (lastTag === 0\n  /* ZERO */\n  ) {\n    dst.push(spanWordLength);\n  } else if (lastTag === 255\n  /* SPAN */\n  ) {\n    dst[spanTagOffset] = spanWordLength;\n  }\n\n  return new Uint8Array(dst).buffer;\n}\n\nexports.pack = pack;\n/**\n * Unpack a compressed Cap'n Proto message into a new ArrayBuffer.\n *\n * Unlike the `pack` function, this is able to efficiently determine the exact size needed for the output buffer and\n * runs considerably more efficiently.\n *\n * @export\n * @param {ArrayBuffer} packed An array buffer containing the packed message.\n * @returns {ArrayBuffer} The unpacked message.\n */\n\nfunction unpack(packed) {\n  // We have no choice but to read the packed buffer one byte at a time.\n  var src = new Uint8Array(packed);\n  var dst = new Uint8Array(new ArrayBuffer(getUnpackedByteLength(packed)));\n  /** The last tag byte that we've seen - it starts at a \"neutral\" value. */\n\n  var lastTag = 0x77;\n\n  for (var srcByteOffset = 0, dstByteOffset = 0; srcByteOffset < src.byteLength;) {\n    var tag = src[srcByteOffset];\n\n    if (lastTag === 0\n    /* ZERO */\n    ) {\n      // We have a span of zeroes. New array buffers are guaranteed to be initialized to zero so we just seek ahead.\n      dstByteOffset += tag * 8;\n      srcByteOffset++;\n      lastTag = 0x77;\n    } else if (lastTag === 255\n    /* SPAN */\n    ) {\n      // We have a span of unpacked bytes. Copy them verbatim from the source buffer.\n      var spanByteLength = tag * 8;\n      dst.set(src.subarray(srcByteOffset + 1, srcByteOffset + 1 + spanByteLength), dstByteOffset);\n      dstByteOffset += spanByteLength;\n      srcByteOffset += 1 + spanByteLength;\n      lastTag = 0x77;\n    } else {\n      // Okay, a normal tag. Let's read past the tag and copy bytes that have a bit set in the tag.\n      srcByteOffset++;\n\n      for (var i = 1; i <= 128; i <<= 1) {\n        // We only need to actually touch `dst` if there's a nonzero byte (it's already initialized to zeroes).\n        if ((tag & i) !== 0) dst[dstByteOffset] = src[srcByteOffset++];\n        dstByteOffset++;\n      }\n\n      lastTag = tag;\n    }\n  }\n\n  return dst.buffer;\n}\n\nexports.unpack = unpack;","map":{"version":3,"sources":["serialization/packing.ts"],"names":[],"mappings":";AAAA;;AAEG;;;;;;AAEH,IAAA,WAAA,GAAA,OAAA,CAAA,cAAA,CAAA;;AACA,IAAA,QAAA,GAAA,OAAA,CAAA,WAAA,CAAA;AAqCA;;;;;;;;AAQG;;;AAEH,SAAA,gBAAA,CAAiC,CAAjC,EAA0C;AAExC;AAEA,MAAI,CAAC,GAAG,CAAC,IAAK,CAAC,IAAI,CAAN,GAAW,UAAf,CAAT;AACA,EAAA,CAAC,GAAG,CAAC,CAAC,GAAG,UAAL,KAAqB,CAAC,IAAI,CAAN,GAAW,UAA/B,CAAJ;AACA,SAAQ,CAAC,CAAC,IAAI,CAAC,IAAI,CAAT,CAAD,GAAe,UAAhB,IAA8B,UAA/B,IAA8C,EAArD;AAED;;AARD,OAAA,CAAA,gBAAA,GAAA,gBAAA;AAYA;;;;;;;;;;;;AAYG;;AAEH,SAAA,UAAA,CAA2B,CAA3B,EAAoC,CAApC,EAA6C,CAA7C,EAAsD,CAAtD,EAA+D,CAA/D,EAAwE,CAAxE,EAAiF,CAAjF,EAA0F,CAA1F,EAAiG;AAE/F;AAEA,SAAO,CAAC,CAAC,KAAK,CAAN,GAAU,CAAV,GAAc,CAAf,KACJ,CAAC,KAAK,CAAN,GAAU,CAAV,GAAc,CADV,KAEJ,CAAC,KAAK,CAAN,GAAU,CAAV,GAAc,CAFV,KAGJ,CAAC,KAAK,CAAN,GAAU,CAAV,GAAc,CAHV,KAIJ,CAAC,KAAK,CAAN,GAAU,CAAV,GAAc,EAJV,KAKJ,CAAC,KAAK,CAAN,GAAU,CAAV,GAAc,EALV,KAMJ,CAAC,KAAK,CAAN,GAAU,CAAV,GAAc,EANV,KAOJ,CAAC,KAAK,CAAN,GAAU,CAAV,GAAc,GAPV,CAAP;AASD;;AAbD,OAAA,CAAA,UAAA,GAAA,UAAA;AAeA;;;;;;AAMG;;AAEH,SAAA,qBAAA,CAAsC,MAAtC,EAAyD;AAEvD,MAAM,CAAC,GAAG,IAAI,UAAJ,CAAe,MAAf,CAAV;AACA,MAAI,UAAU,GAAG,CAAjB;AACA,MAAI,OAAO,GAAG,IAAd;;AAEA,OAAK,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,CAAC,CAAC,UAAtB,GAAmC;AAEjC,QAAM,GAAG,GAAG,CAAC,CAAC,CAAD,CAAb;;AAEA,QAAI,OAAO,KAAA;AAAA;AAAX,MAAgC;AAE9B,MAAA,UAAU,IAAI,GAAd;AAEA,MAAA,CAAC;AAED,MAAA,OAAO,GAAG,IAAV;AAED,KARD,MAQO,IAAI,OAAO,KAAA;AAAA;AAAX,MAAgC;AAErC,MAAA,UAAU,IAAI,GAAd;AAEA,MAAA,CAAC,IAAI,GAAG,GAAG,CAAN,GAAU,CAAf;AAEA,MAAA,OAAO,GAAG,IAAV;AAED,KARM,MAQA;AAEL,MAAA,UAAU;AAEV,MAAA,CAAC,IAAI,gBAAgB,CAAC,GAAD,CAAhB,GAAwB,CAA7B;AAEA,MAAA,OAAO,GAAG,GAAV;AAED;AAGF;;AAED,SAAO,UAAU,GAAG,CAApB;AAED;;AAzCD,OAAA,CAAA,qBAAA,GAAA,qBAAA;AA2CA;;;;;;;;;;;;AAYG;;AAEH,SAAA,gBAAA,CAAiC,CAAjC,EAA0C,CAA1C,EAAmD,CAAnD,EAA4D,CAA5D,EAAqE,CAArE,EAA8E,CAA9E,EAAuF,CAAvF,EAAgG,CAAhG,EAAuG;AAErG,SAAO,CAAC,CAAC,KAAK,CAAN,GAAU,CAAV,GAAc,CAAf,KACJ,CAAC,KAAK,CAAN,GAAU,CAAV,GAAc,CADV,KAEJ,CAAC,KAAK,CAAN,GAAU,CAAV,GAAc,CAFV,KAGJ,CAAC,KAAK,CAAN,GAAU,CAAV,GAAc,CAHV,KAIJ,CAAC,KAAK,CAAN,GAAU,CAAV,GAAc,CAJV,KAKJ,CAAC,KAAK,CAAN,GAAU,CAAV,GAAc,CALV,KAMJ,CAAC,KAAK,CAAN,GAAU,CAAV,GAAc,CANV,KAOJ,CAAC,KAAK,CAAN,GAAU,CAAV,GAAc,CAPV,CAAP;AASD;;AAXD,OAAA,CAAA,gBAAA,GAAA,gBAAA;AAaA;;;;;;;;;;;;;;;AAeG;;AAEH,SAAA,IAAA,CAAqB,QAArB,EAA4C,UAA5C,EAA4D,UAA5D,EAA+E;AAAnC,MAAA,UAAA,KAAA,KAAA,CAAA,EAAA;AAAA,IAAA,UAAA,GAAA,CAAA;AAAc;;AAExD,MAAI,QAAQ,CAAC,UAAT,GAAsB,CAAtB,KAA4B,CAAhC,EAAmC,MAAM,IAAI,KAAJ,CAAU,QAAA,CAAA,yBAAV,CAAN;AAEnC,MAAM,GAAG,GAAG,IAAI,UAAJ,CAAe,QAAf,EAAyB,UAAzB,EAAqC,UAArC,CAAZ,CAJ6E,CAM7E;;AAEA,MAAM,GAAG,GAAa,EAAtB;AAEA;;AAEA,MAAI,OAAO,GAAG,IAAd;AAEA;;AAEA,MAAI,aAAa,GAAG,GAApB;AAEA;;AAEA,MAAI,cAAc,GAAG,CAArB;AAEA;;AAEG;;AAEH,MAAI,aAAa,GAAG,WAAA,CAAA,mBAApB;;AAEA,OAAK,IAAI,aAAa,GAAG,CAAzB,EAA4B,aAAa,GAAG,GAAG,CAAC,UAAhD,EAA4D,aAAa,IAAI,CAA7E,EAAgF;AAE9E;AAEA,QAAM,CAAC,GAAG,GAAG,CAAC,aAAD,CAAb;AACA,QAAM,CAAC,GAAG,GAAG,CAAC,aAAa,GAAG,CAAjB,CAAb;AACA,QAAM,CAAC,GAAG,GAAG,CAAC,aAAa,GAAG,CAAjB,CAAb;AACA,QAAM,CAAC,GAAG,GAAG,CAAC,aAAa,GAAG,CAAjB,CAAb;AACA,QAAM,CAAC,GAAG,GAAG,CAAC,aAAa,GAAG,CAAjB,CAAb;AACA,QAAM,CAAC,GAAG,GAAG,CAAC,aAAa,GAAG,CAAjB,CAAb;AACA,QAAM,CAAC,GAAG,GAAG,CAAC,aAAa,GAAG,CAAjB,CAAb;AACA,QAAM,CAAC,GAAG,GAAG,CAAC,aAAa,GAAG,CAAjB,CAAb;AAEA,QAAM,GAAG,GAAG,UAAU,CAAC,CAAD,EAAI,CAAJ,EAAO,CAAP,EAAU,CAAV,EAAa,CAAb,EAAgB,CAAhB,EAAmB,CAAnB,EAAsB,CAAtB,CAAtB;AAEA;;AAEA,QAAI,aAAa,GAAG,IAApB;;AAEA,YAAQ,OAAR;AAEE,WAAA;AAAA;AAAA;AAEE;AAEA,YAAI,GAAG,KAAA;AAAA;AAAH,WAA0B,cAAc,IAAI,IAAhD,EAAsD;AAEpD;AAEA,UAAA,GAAG,CAAC,IAAJ,CAAS,cAAT;AACA,UAAA,cAAc,GAAG,CAAjB;AAEA,UAAA,aAAa,GAAG,KAAhB;AAED,SATD,MASO;AAEL;AAEA,UAAA,cAAc;AAEf;;AAED;;AAEF,WAAA;AAAA;AAAA;AAEE;AAEA,YAAM,SAAS,GAAG,gBAAgB,CAAC,CAAD,EAAI,CAAJ,EAAO,CAAP,EAAU,CAAV,EAAa,CAAb,EAAgB,CAAhB,EAAmB,CAAnB,EAAsB,CAAtB,CAAlC,CAJF,CAME;;AAEA,QAAA,aAAa,IAAI,SAAjB;;AAEA,YAAI,aAAa,IAAI,CAAjB,IAAsB,cAAc,IAAI,IAA5C,EAAkD;AAEhD;AAEA,UAAA,GAAG,CAAC,aAAD,CAAH,GAAqB,cAArB;AACA,UAAA,cAAc,GAAG,CAAjB;AAEA,UAAA,aAAa,GAAG,WAAA,CAAA,mBAAhB,CAPgD,CAShD;;AAEA,UAAA,aAAa,GAAG,KAAhB;AAED,SAbD,MAaO;AAEL;AAEA,UAAA,GAAG,CAAC,IAAJ,CAAS,CAAT,EAAY,CAAZ,EAAe,CAAf,EAAkB,CAAlB,EAAqB,CAArB,EAAwB,CAAxB,EAA2B,CAA3B,EAA8B,CAA9B;AAEA,UAAA,cAAc;AAEf;;AAED;;AAEF;AAEE;AAEA,QAAA,aAAa,GAAG,KAAhB;AAEA;AAlEJ,KAnB8E,CAyF9E;;;AACA,QAAI,aAAJ,EAAmB;AAEnB,IAAA,GAAG,CAAC,IAAJ,CAAS,GAAT;AACA,IAAA,OAAO,GAAG,GAAV;AAEA,QAAI,CAAC,KAAK,CAAV,EAAa,GAAG,CAAC,IAAJ,CAAS,CAAT;AACb,QAAI,CAAC,KAAK,CAAV,EAAa,GAAG,CAAC,IAAJ,CAAS,CAAT;AACb,QAAI,CAAC,KAAK,CAAV,EAAa,GAAG,CAAC,IAAJ,CAAS,CAAT;AACb,QAAI,CAAC,KAAK,CAAV,EAAa,GAAG,CAAC,IAAJ,CAAS,CAAT;AACb,QAAI,CAAC,KAAK,CAAV,EAAa,GAAG,CAAC,IAAJ,CAAS,CAAT;AACb,QAAI,CAAC,KAAK,CAAV,EAAa,GAAG,CAAC,IAAJ,CAAS,CAAT;AACb,QAAI,CAAC,KAAK,CAAV,EAAa,GAAG,CAAC,IAAJ,CAAS,CAAT;AACb,QAAI,CAAC,KAAK,CAAV,EAAa,GAAG,CAAC,IAAJ,CAAS,CAAT,EAtGiE,CAwG9E;;AAEA,QAAI,GAAG,KAAA;AAAA;AAAP,MAA4B;AAE1B,MAAA,aAAa,GAAG,GAAG,CAAC,MAApB;AAEA,MAAA,GAAG,CAAC,IAAJ,CAAS,CAAT;AAED;AAEF,GA9I4E,CAgJ7E;;;AAEA,MAAI,OAAO,KAAA;AAAA;AAAX,IAAgC;AAE9B,IAAA,GAAG,CAAC,IAAJ,CAAS,cAAT;AAED,GAJD,MAIO,IAAI,OAAO,KAAA;AAAA;AAAX,IAAgC;AAErC,IAAA,GAAG,CAAC,aAAD,CAAH,GAAqB,cAArB;AAED;;AAED,SAAO,IAAI,UAAJ,CAAe,GAAf,EAAoB,MAA3B;AAED;;AA9JD,OAAA,CAAA,IAAA,GAAA,IAAA;AAgKA;;;;;;;;;AASG;;AAEH,SAAA,MAAA,CAAuB,MAAvB,EAA0C;AAExC;AAEA,MAAM,GAAG,GAAG,IAAI,UAAJ,CAAe,MAAf,CAAZ;AACA,MAAM,GAAG,GAAG,IAAI,UAAJ,CAAe,IAAI,WAAJ,CAAgB,qBAAqB,CAAC,MAAD,CAArC,CAAf,CAAZ;AAEA;;AAEA,MAAI,OAAO,GAAG,IAAd;;AAEA,OAAK,IAAI,aAAa,GAAG,CAApB,EAAuB,aAAa,GAAG,CAA5C,EAA+C,aAAa,GAAG,GAAG,CAAC,UAAnE,GAAgF;AAE9E,QAAM,GAAG,GAAG,GAAG,CAAC,aAAD,CAAf;;AAEA,QAAI,OAAO,KAAA;AAAA;AAAX,MAAgC;AAE9B;AAEA,MAAA,aAAa,IAAI,GAAG,GAAG,CAAvB;AAEA,MAAA,aAAa;AAEb,MAAA,OAAO,GAAG,IAAV;AAED,KAVD,MAUO,IAAI,OAAO,KAAA;AAAA;AAAX,MAAgC;AAErC;AAEA,UAAM,cAAc,GAAG,GAAG,GAAG,CAA7B;AAEA,MAAA,GAAG,CAAC,GAAJ,CAAQ,GAAG,CAAC,QAAJ,CAAa,aAAa,GAAG,CAA7B,EAAgC,aAAa,GAAG,CAAhB,GAAoB,cAApD,CAAR,EAA6E,aAA7E;AAEA,MAAA,aAAa,IAAI,cAAjB;AACA,MAAA,aAAa,IAAI,IAAI,cAArB;AAEA,MAAA,OAAO,GAAG,IAAV;AAED,KAbM,MAaA;AAEL;AAEA,MAAA,aAAa;;AAEb,WAAK,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,IAAI,GAArB,EAAiC,CAAC,KAAK,CAAvC,EAA0C;AAExC;AAEA,YAAI,CAAC,GAAG,GAAG,CAAP,MAAc,CAAlB,EAAqB,GAAG,CAAC,aAAD,CAAH,GAAqB,GAAG,CAAC,aAAa,EAAd,CAAxB;AAErB,QAAA,aAAa;AAEd;;AAED,MAAA,OAAO,GAAG,GAAV;AAED;AAEF;;AAED,SAAO,GAAG,CAAC,MAAX;AAED;;AA9DD,OAAA,CAAA,MAAA,GAAA,MAAA","sourceRoot":"../../src","sourcesContent":["\"use strict\";\n/**\n * @author jdiaz5513\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar constants_1 = require(\"../constants\");\nvar errors_1 = require(\"../errors\");\n/**\n * Compute the Hamming weight (number of bits set to 1) of a number. Used to figure out how many bytes follow a tag byte\n * while computing the size of a packed message.\n *\n * WARNING: Using this with floating point numbers will void your warranty.\n *\n * @param {number} x A real integer.\n * @returns {number} The hamming weight (integer).\n */\nfunction getHammingWeight(x) {\n    // Thanks, HACKMEM!\n    var w = x - ((x >> 1) & 0x55555555);\n    w = (w & 0x33333333) + ((w >> 2) & 0x33333333);\n    return ((w + (w >> 4) & 0x0f0f0f0f) * 0x01010101) >> 24;\n}\nexports.getHammingWeight = getHammingWeight;\n/**\n * Compute the tag byte from the 8 bytes of a 64-bit word.\n *\n * @param {byte} a The first byte.\n * @param {byte} b The second byte.\n * @param {byte} c The third byte.\n * @param {byte} d The fourth byte.\n * @param {byte} e The fifth byte.\n * @param {byte} f The sixth byte.\n * @param {byte} g The seventh byte.\n * @param {byte} h The eighth byte (phew!).\n * @returns {number} The tag byte.\n */\nfunction getTagByte(a, b, c, d, e, f, g, h) {\n    // Yes, it's pretty. Don't touch it.\n    return (a === 0 ? 0 : 1) |\n        (b === 0 ? 0 : 2) |\n        (c === 0 ? 0 : 4) |\n        (d === 0 ? 0 : 8) |\n        (e === 0 ? 0 : 16) |\n        (f === 0 ? 0 : 32) |\n        (g === 0 ? 0 : 64) |\n        (h === 0 ? 0 : 128);\n}\nexports.getTagByte = getTagByte;\n/**\n * Efficiently calculate the length of a packed Cap'n Proto message.\n *\n * @export\n * @param {ArrayBuffer} packed The packed message.\n * @returns {number} The length of the unpacked message in bytes.\n */\nfunction getUnpackedByteLength(packed) {\n    var p = new Uint8Array(packed);\n    var wordLength = 0;\n    var lastTag = 0x77;\n    for (var i = 0; i < p.byteLength;) {\n        var tag = p[i];\n        if (lastTag === 0 /* ZERO */) {\n            wordLength += tag;\n            i++;\n            lastTag = 0x77;\n        }\n        else if (lastTag === 255 /* SPAN */) {\n            wordLength += tag;\n            i += tag * 8 + 1;\n            lastTag = 0x77;\n        }\n        else {\n            wordLength++;\n            i += getHammingWeight(tag) + 1;\n            lastTag = tag;\n        }\n    }\n    return wordLength * 8;\n}\nexports.getUnpackedByteLength = getUnpackedByteLength;\n/**\n * Compute the number of zero bytes that occur in a given 64-bit word, provided as eight separate bytes.\n *\n * @param {byte} a The first byte.\n * @param {byte} b The second byte.\n * @param {byte} c The third byte.\n * @param {byte} d The fourth byte.\n * @param {byte} e The fifth byte.\n * @param {byte} f The sixth byte.\n * @param {byte} g The seventh byte.\n * @param {byte} h The eighth byte (phew!).\n * @returns {number} The number of these bytes that are zero.\n */\nfunction getZeroByteCount(a, b, c, d, e, f, g, h) {\n    return (a === 0 ? 1 : 0) +\n        (b === 0 ? 1 : 0) +\n        (c === 0 ? 1 : 0) +\n        (d === 0 ? 1 : 0) +\n        (e === 0 ? 1 : 0) +\n        (f === 0 ? 1 : 0) +\n        (g === 0 ? 1 : 0) +\n        (h === 0 ? 1 : 0);\n}\nexports.getZeroByteCount = getZeroByteCount;\n/**\n * Pack a section of a Cap'n Proto message into a compressed format. This will efficiently compress zero bytes (which\n * are common in idiomatic Cap'n Proto messages) into a compact form.\n *\n * For stream-framed messages this is called once for the frame header and once again for each segment in the message.\n *\n * The returned array buffer is trimmed to the exact size of the packed message with a single copy operation at the end.\n * This should be decent on CPU time but does require quite a lot of memory (a normal array is filled up with each\n * packed byte until the packing is complete).\n *\n * @export\n * @param {ArrayBuffer} unpacked The message to pack.\n * @param {number} [byteOffset] Starting byte offset to read bytes from, defaults to 0.\n * @param {number} [byteLength] Total number of bytes to read, defaults to the remainder of the buffer contents.\n * @returns {ArrayBuffer} A packed version of the message.\n */\nfunction pack(unpacked, byteOffset, byteLength) {\n    if (byteOffset === void 0) { byteOffset = 0; }\n    if (unpacked.byteLength % 8 !== 0)\n        throw new Error(errors_1.MSG_PACK_NOT_WORD_ALIGNED);\n    var src = new Uint8Array(unpacked, byteOffset, byteLength);\n    // TODO: Maybe we should do this with buffers? This costs more than 8x the final compressed size in temporary RAM.\n    var dst = [];\n    /* Just have to be sure it's neither ZERO nor SPAN. */\n    var lastTag = 0x77;\n    /** This is where we need to remember to write the SPAN tag (0xff). */\n    var spanTagOffset = NaN;\n    /** How many words have been copied during the current span. */\n    var spanWordLength = 0;\n    /**\n     * When this hits zero, we've had PACK_SPAN_THRESHOLD zero bytes pass by and it's time to bail from the span.\n     */\n    var spanThreshold = constants_1.PACK_SPAN_THRESHOLD;\n    for (var srcByteOffset = 0; srcByteOffset < src.byteLength; srcByteOffset += 8) {\n        /** Read in the entire word. Yes, this feels silly but it's fast! */\n        var a = src[srcByteOffset];\n        var b = src[srcByteOffset + 1];\n        var c = src[srcByteOffset + 2];\n        var d = src[srcByteOffset + 3];\n        var e = src[srcByteOffset + 4];\n        var f = src[srcByteOffset + 5];\n        var g = src[srcByteOffset + 6];\n        var h = src[srcByteOffset + 7];\n        var tag = getTagByte(a, b, c, d, e, f, g, h);\n        /** If this is true we'll skip the normal word write logic after the switch statement. */\n        var skipWriteWord = true;\n        switch (lastTag) {\n            case 0 /* ZERO */:\n                // We're writing a span of words with all zeroes in them. See if we need to bail out of the fast path.\n                if (tag !== 0 /* ZERO */ || spanWordLength >= 0xff) {\n                    // There's a bit in there or we got too many zeroes. Damn, we need to bail.\n                    dst.push(spanWordLength);\n                    spanWordLength = 0;\n                    skipWriteWord = false;\n                }\n                else {\n                    // Kay, let's quickly inc this and go.\n                    spanWordLength++;\n                }\n                break;\n            case 255 /* SPAN */:\n                // We're writing a span of nonzero words.\n                var zeroCount = getZeroByteCount(a, b, c, d, e, f, g, h);\n                // See if we need to bail now.\n                spanThreshold -= zeroCount;\n                if (spanThreshold <= 0 || spanWordLength >= 0xff) {\n                    // Alright, time to get packing again. Write the number of words we skipped to the beginning of the span.\n                    dst[spanTagOffset] = spanWordLength;\n                    spanWordLength = 0;\n                    spanThreshold = constants_1.PACK_SPAN_THRESHOLD;\n                    // We have to write this word normally.\n                    skipWriteWord = false;\n                }\n                else {\n                    // Just write this word verbatim.\n                    dst.push(a, b, c, d, e, f, g, h);\n                    spanWordLength++;\n                }\n                break;\n            default:\n                // Didn't get a special tag last time, let's write this as normal.\n                skipWriteWord = false;\n                break;\n        }\n        // A goto is fast, idk why people keep hatin'.\n        if (skipWriteWord)\n            continue;\n        dst.push(tag);\n        lastTag = tag;\n        if (a !== 0)\n            dst.push(a);\n        if (b !== 0)\n            dst.push(b);\n        if (c !== 0)\n            dst.push(c);\n        if (d !== 0)\n            dst.push(d);\n        if (e !== 0)\n            dst.push(e);\n        if (f !== 0)\n            dst.push(f);\n        if (g !== 0)\n            dst.push(g);\n        if (h !== 0)\n            dst.push(h);\n        // Record the span tag offset if needed, making sure to actually leave room for it.\n        if (tag === 255 /* SPAN */) {\n            spanTagOffset = dst.length;\n            dst.push(0);\n        }\n    }\n    // We're done. If we were writing a span let's finish it.\n    if (lastTag === 0 /* ZERO */) {\n        dst.push(spanWordLength);\n    }\n    else if (lastTag === 255 /* SPAN */) {\n        dst[spanTagOffset] = spanWordLength;\n    }\n    return new Uint8Array(dst).buffer;\n}\nexports.pack = pack;\n/**\n * Unpack a compressed Cap'n Proto message into a new ArrayBuffer.\n *\n * Unlike the `pack` function, this is able to efficiently determine the exact size needed for the output buffer and\n * runs considerably more efficiently.\n *\n * @export\n * @param {ArrayBuffer} packed An array buffer containing the packed message.\n * @returns {ArrayBuffer} The unpacked message.\n */\nfunction unpack(packed) {\n    // We have no choice but to read the packed buffer one byte at a time.\n    var src = new Uint8Array(packed);\n    var dst = new Uint8Array(new ArrayBuffer(getUnpackedByteLength(packed)));\n    /** The last tag byte that we've seen - it starts at a \"neutral\" value. */\n    var lastTag = 0x77;\n    for (var srcByteOffset = 0, dstByteOffset = 0; srcByteOffset < src.byteLength;) {\n        var tag = src[srcByteOffset];\n        if (lastTag === 0 /* ZERO */) {\n            // We have a span of zeroes. New array buffers are guaranteed to be initialized to zero so we just seek ahead.\n            dstByteOffset += tag * 8;\n            srcByteOffset++;\n            lastTag = 0x77;\n        }\n        else if (lastTag === 255 /* SPAN */) {\n            // We have a span of unpacked bytes. Copy them verbatim from the source buffer.\n            var spanByteLength = tag * 8;\n            dst.set(src.subarray(srcByteOffset + 1, srcByteOffset + 1 + spanByteLength), dstByteOffset);\n            dstByteOffset += spanByteLength;\n            srcByteOffset += 1 + spanByteLength;\n            lastTag = 0x77;\n        }\n        else {\n            // Okay, a normal tag. Let's read past the tag and copy bytes that have a bit set in the tag.\n            srcByteOffset++;\n            for (var i = 1; i <= 128; i <<= 1) {\n                // We only need to actually touch `dst` if there's a nonzero byte (it's already initialized to zeroes).\n                if ((tag & i) !== 0)\n                    dst[dstByteOffset] = src[srcByteOffset++];\n                dstByteOffset++;\n            }\n            lastTag = tag;\n        }\n    }\n    return dst.buffer;\n}\nexports.unpack = unpack;\n\n//# sourceMappingURL=packing.js.map\n"]},"metadata":{},"sourceType":"script"}