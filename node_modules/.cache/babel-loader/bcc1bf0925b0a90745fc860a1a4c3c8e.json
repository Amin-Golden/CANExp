{"ast":null,"code":"const through2 = require('through2');\n\nmodule.exports = StreamSelector;\n\nfunction StreamSelector(options) {\n  if (!(this instanceof StreamSelector)) {\n    return new StreamSelector(options);\n  }\n\n  var curBuffer = null;\n  var destinationStream = null;\n  var isDeciding = false;\n  options = options || {};\n\n  if (typeof options === 'function') {\n    options = {\n      selector: options\n    };\n  }\n\n  return through2(transform, flush);\n\n  function flush(cb) {\n    if (destinationStream.flush) {\n      destinationStream.flush(cb);\n    } else {\n      destinationStream.end();\n      cb();\n    }\n  }\n\n  function transform(chunk, encoding, done) {\n    if (destinationStream) {\n      destinationStream.write(chunk, encoding, done);\n      return;\n    } // haven't found a good destination stream yet, keep trying...\n    // store data we're buffering so we can make sure to send it all when we find a stream\n    // also, some streams might not be ready on the first packet, they might need 2 to classify\n\n\n    if (!curBuffer) {\n      curBuffer = chunk;\n    } else {\n      curBuffer = Buffer.concat([curBuffer, chunk]);\n    }\n\n    if (options.minBuffer && options.minBuffer > curBuffer.byteLength) {\n      // wait for more data before deciding...\n      return done();\n    }\n\n    if (isDeciding) {\n      // keep buffering and waiting for the decision to come back.\n      return done();\n    }\n\n    if (curBuffer.byteLength < 1) {\n      // don't make them decide if we don't even have data yet...\n      return done();\n    }\n\n    isDeciding = true;\n    let stream = options.selector(curBuffer, encoding, (err, stream) => {\n      if (err) {\n        return this.emit('error', err);\n      }\n\n      if (destinationStream) {\n        return this.emit('error', new Error('Cannot specific destination stream twice. You cannot use the callback and also return a value'));\n      }\n\n      if (!stream) {\n        return this.emit('error', new Error('Selector method did not return an error or a destination stream'));\n      }\n\n      assignStream(stream, encoding, this);\n      done();\n    });\n\n    if (stream) {\n      assignStream(stream, encoding, this);\n      done();\n    }\n  }\n\n  function assignStream(stream, encoding, self) {\n    if (destinationStream === stream) {\n      return;\n    }\n\n    destinationStream = stream;\n\n    if (curBuffer) {\n      destinationStream.on('data', self.push.bind(self));\n      destinationStream.write(curBuffer, encoding);\n      curBuffer = null;\n    }\n  }\n}","map":{"version":3,"sources":["/home/amax/Autoro/cabana/node_modules/stream-selector/index.js"],"names":["through2","require","module","exports","StreamSelector","options","curBuffer","destinationStream","isDeciding","selector","transform","flush","cb","end","chunk","encoding","done","write","Buffer","concat","minBuffer","byteLength","stream","err","emit","Error","assignStream","self","on","push","bind"],"mappings":"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","sourcesContent":["const through2 = require('through2');\n\nmodule.exports = StreamSelector;\n\nfunction StreamSelector (options) {\n  if (!(this instanceof StreamSelector)) {\n    return new StreamSelector(options);\n  }\n\n  var curBuffer = null;\n  var destinationStream = null;\n  var isDeciding = false;\n  options = options || {};\n  if (typeof options === 'function') {\n    options = {\n      selector: options\n    };\n  }\n\n  return through2(transform, flush);\n\n  function flush (cb) {\n    if (destinationStream.flush) {\n      destinationStream.flush(cb);\n    } else {\n      destinationStream.end();\n      cb();\n    }\n  }\n\n  function transform (chunk, encoding, done) {\n    if (destinationStream) {\n      destinationStream.write(chunk, encoding, done);\n      return;\n    }\n    // haven't found a good destination stream yet, keep trying...\n    // store data we're buffering so we can make sure to send it all when we find a stream\n    // also, some streams might not be ready on the first packet, they might need 2 to classify\n    if (!curBuffer) {\n      curBuffer = chunk;\n    } else {\n      curBuffer = Buffer.concat([curBuffer, chunk]);\n    }\n    if (options.minBuffer && options.minBuffer > curBuffer.byteLength) {\n      // wait for more data before deciding...\n      return done();\n    }\n    if (isDeciding) {\n      // keep buffering and waiting for the decision to come back.\n      return done();\n    }\n    if (curBuffer.byteLength < 1) {\n      // don't make them decide if we don't even have data yet...\n      return done();\n    }\n    isDeciding = true;\n    let stream = options.selector(curBuffer, encoding, (err, stream) => {\n      if (err) {\n        return this.emit('error', err);\n      }\n      if (destinationStream) {\n        return this.emit('error', new Error('Cannot specific destination stream twice. You cannot use the callback and also return a value'));\n      }\n      if (!stream) {\n        return this.emit('error', new Error('Selector method did not return an error or a destination stream'));\n      }\n      assignStream(stream, encoding, this);\n      done();\n    });\n\n    if (stream) {\n      assignStream(stream, encoding, this);\n      done();\n    }\n  }\n\n  function assignStream (stream, encoding, self) {\n    if (destinationStream === stream) {\n      return;\n    }\n    destinationStream = stream;\n\n    if (curBuffer) {\n      destinationStream.on('data', self.push.bind(self));\n      destinationStream.write(curBuffer, encoding);\n      curBuffer = null;\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"script"}