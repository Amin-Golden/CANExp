{"ast":null,"code":"\"use strict\";\n/**\n * @author jdiaz5513\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar tslib_1 = require(\"tslib\");\n\nvar constants_1 = require(\"../../constants\");\n\nvar errors_1 = require(\"../../errors\");\n\nvar util_1 = require(\"../../util\");\n\nvar pointer_1 = require(\"./pointer\");\n\nvar Interface =\n/** @class */\nfunction (_super) {\n  tslib_1.__extends(Interface, _super);\n\n  function Interface(segment, byteOffset, depthLimit) {\n    if (depthLimit === void 0) {\n      depthLimit = constants_1.MAX_DEPTH;\n    }\n\n    var _this = _super.call(this, segment, byteOffset, depthLimit) || this;\n\n    throw new Error(util_1.format(errors_1.NOT_IMPLEMENTED, 'new Interface'));\n    return _this;\n  }\n\n  return Interface;\n}(pointer_1.Pointer);\n\nexports.Interface = Interface;","map":{"version":3,"sources":["serialization/pointers/interface.ts"],"names":[],"mappings":";AAAA;;AAEG;;;;;;;;AAEH,IAAA,WAAA,GAAA,OAAA,CAAA,iBAAA,CAAA;;AACA,IAAA,QAAA,GAAA,OAAA,CAAA,cAAA,CAAA;;AACA,IAAA,MAAA,GAAA,OAAA,CAAA,YAAA,CAAA;;AAEA,IAAA,SAAA,GAAA,OAAA,CAAA,WAAA,CAAA;;AAEA,IAAA,SAAA;AAAA;AAAA,UAAA,MAAA,EAAA;AAA+B,EAAA,OAAA,CAAA,SAAA,CAAA,SAAA,EAAA,MAAA;;AAE7B,WAAA,SAAA,CAAY,OAAZ,EAA8B,UAA9B,EAAkD,UAAlD,EAAwE;AAAtB,QAAA,UAAA,KAAA,KAAA,CAAA,EAAA;AAAA,MAAA,UAAA,GAAa,WAAA,CAAA,SAAb;AAAsB;;AAAxE,QAAA,KAAA,GAEE,MAAA,CAAA,IAAA,CAAA,IAAA,EAAM,OAAN,EAAe,UAAf,EAA2B,UAA3B,KAAsC,IAFxC;;AAIE,UAAM,IAAI,KAAJ,CAAU,MAAA,CAAA,MAAA,CAAO,QAAA,CAAA,eAAP,EAAwB,eAAxB,CAAV,CAAN;;AAED;;AAEH,SAAA,SAAA;AAAC,CAVD,CAA+B,SAAA,CAAA,OAA/B,CAAA;;AAAa,OAAA,CAAA,SAAA,GAAA,SAAA","sourceRoot":"../../../src","sourcesContent":["\"use strict\";\n/**\n * @author jdiaz5513\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = require(\"tslib\");\nvar constants_1 = require(\"../../constants\");\nvar errors_1 = require(\"../../errors\");\nvar util_1 = require(\"../../util\");\nvar pointer_1 = require(\"./pointer\");\nvar Interface = /** @class */ (function (_super) {\n    tslib_1.__extends(Interface, _super);\n    function Interface(segment, byteOffset, depthLimit) {\n        if (depthLimit === void 0) { depthLimit = constants_1.MAX_DEPTH; }\n        var _this = _super.call(this, segment, byteOffset, depthLimit) || this;\n        throw new Error(util_1.format(errors_1.NOT_IMPLEMENTED, 'new Interface'));\n        return _this;\n    }\n    return Interface;\n}(pointer_1.Pointer));\nexports.Interface = Interface;\n\n//# sourceMappingURL=interface.js.map\n"]},"metadata":{},"sourceType":"script"}