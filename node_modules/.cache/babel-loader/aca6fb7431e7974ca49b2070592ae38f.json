{"ast":null,"code":"'use strict';\n/* @flow */\n\n/**\n * This is a single-layer [Perceptron Classifier](http://en.wikipedia.org/wiki/Perceptron) that takes\n * arrays of numbers and predicts whether they should be classified\n * as either 0 or 1 (negative or positive examples).\n * @class\n * @example\n * // Create the model\n * var p = new PerceptronModel();\n * // Train the model with input with a diagonal boundary.\n * for (var i = 0; i < 5; i++) {\n *     p.train([1, 1], 1);\n *     p.train([0, 1], 0);\n *     p.train([1, 0], 0);\n *     p.train([0, 0], 0);\n * }\n * p.predict([0, 0]); // 0\n * p.predict([0, 1]); // 0\n * p.predict([1, 0]); // 0\n * p.predict([1, 1]); // 1\n */\n\nfunction PerceptronModel() {\n  // The weights, or coefficients of the model;\n  // weights are only populated when training with data.\n  this.weights = []; // The bias term, or intercept; it is also a weight but\n  // it's stored separately for convenience as it is always\n  // multiplied by one.\n\n  this.bias = 0;\n}\n/**\n * **Predict**: Use an array of features with the weight array and bias\n * to predict whether an example is labeled 0 or 1.\n *\n * @param {Array<number>} features an array of features as numbers\n * @returns {number} 1 if the score is over 0, otherwise 0\n */\n\n\nPerceptronModel.prototype.predict = function (features) {\n  // Only predict if previously trained\n  // on the same size feature array(s).\n  if (features.length !== this.weights.length) {\n    return null;\n  } // Calculate the sum of features times weights,\n  // with the bias added (implicitly times one).\n\n\n  var score = 0;\n\n  for (var i = 0; i < this.weights.length; i++) {\n    score += this.weights[i] * features[i];\n  }\n\n  score += this.bias; // Classify as 1 if the score is over 0, otherwise 0.\n\n  if (score > 0) {\n    return 1;\n  } else {\n    return 0;\n  }\n};\n/**\n * **Train** the classifier with a new example, which is\n * a numeric array of features and a 0 or 1 label.\n *\n * @param {Array<number>} features an array of features as numbers\n * @param {number} label either 0 or 1\n * @returns {PerceptronModel} this\n */\n\n\nPerceptronModel.prototype.train = function (features, label) {\n  // Require that only labels of 0 or 1 are considered.\n  if (label !== 0 && label !== 1) {\n    return null;\n  } // The length of the feature array determines\n  // the length of the weight array.\n  // The perceptron will continue learning as long as\n  // it keeps seeing feature arrays of the same length.\n  // When it sees a new data shape, it initializes.\n\n\n  if (features.length !== this.weights.length) {\n    this.weights = features;\n    this.bias = 1;\n  } // Make a prediction based on current weights.\n\n\n  var prediction = this.predict(features); // Update the weights if the prediction is wrong.\n\n  if (prediction !== label) {\n    var gradient = label - prediction;\n\n    for (var i = 0; i < this.weights.length; i++) {\n      this.weights[i] += gradient * features[i];\n    }\n\n    this.bias += gradient;\n  }\n\n  return this;\n};\n\nmodule.exports = PerceptronModel;","map":{"version":3,"sources":["/home/amax/Autoro/cabana/node_modules/simple-statistics/src/perceptron.js"],"names":["PerceptronModel","weights","bias","prototype","predict","features","length","score","i","train","label","prediction","gradient","module","exports"],"mappings":"AAAA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,SAASA,eAAT,GAA2B;AACvB;AACA;AACA,OAAKC,OAAL,GAAe,EAAf,CAHuB,CAIvB;AACA;AACA;;AACA,OAAKC,IAAL,GAAY,CAAZ;AACH;AAED;AACA;AACA;AACA;AACA;AACA;AACA;;;AACAF,eAAe,CAACG,SAAhB,CAA0BC,OAA1B,GAAoC,UAASC,QAAT,EAAmB;AAEnD;AACA;AACA,MAAIA,QAAQ,CAACC,MAAT,KAAoB,KAAKL,OAAL,CAAaK,MAArC,EAA6C;AAAE,WAAO,IAAP;AAAc,GAJV,CAMnD;AACA;;;AACA,MAAIC,KAAK,GAAG,CAAZ;;AACA,OAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG,KAAKP,OAAL,CAAaK,MAAjC,EAAyCE,CAAC,EAA1C,EAA8C;AAC1CD,IAAAA,KAAK,IAAI,KAAKN,OAAL,CAAaO,CAAb,IAAkBH,QAAQ,CAACG,CAAD,CAAnC;AACH;;AACDD,EAAAA,KAAK,IAAI,KAAKL,IAAd,CAZmD,CAcnD;;AACA,MAAIK,KAAK,GAAG,CAAZ,EAAe;AACX,WAAO,CAAP;AACH,GAFD,MAEO;AACH,WAAO,CAAP;AACH;AACJ,CApBD;AAsBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACAP,eAAe,CAACG,SAAhB,CAA0BM,KAA1B,GAAkC,UAASJ,QAAT,EAAmBK,KAAnB,EAA0B;AACxD;AACA,MAAIA,KAAK,KAAK,CAAV,IAAeA,KAAK,KAAK,CAA7B,EAAgC;AAAE,WAAO,IAAP;AAAc,GAFQ,CAGxD;AACA;AACA;AACA;AACA;;;AACA,MAAIL,QAAQ,CAACC,MAAT,KAAoB,KAAKL,OAAL,CAAaK,MAArC,EAA6C;AACzC,SAAKL,OAAL,GAAeI,QAAf;AACA,SAAKH,IAAL,GAAY,CAAZ;AACH,GAXuD,CAYxD;;;AACA,MAAIS,UAAU,GAAG,KAAKP,OAAL,CAAaC,QAAb,CAAjB,CAbwD,CAcxD;;AACA,MAAIM,UAAU,KAAKD,KAAnB,EAA0B;AACtB,QAAIE,QAAQ,GAAGF,KAAK,GAAGC,UAAvB;;AACA,SAAK,IAAIH,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG,KAAKP,OAAL,CAAaK,MAAjC,EAAyCE,CAAC,EAA1C,EAA8C;AAC1C,WAAKP,OAAL,CAAaO,CAAb,KAAmBI,QAAQ,GAAGP,QAAQ,CAACG,CAAD,CAAtC;AACH;;AACD,SAAKN,IAAL,IAAaU,QAAb;AACH;;AACD,SAAO,IAAP;AACH,CAvBD;;AAyBAC,MAAM,CAACC,OAAP,GAAiBd,eAAjB","sourcesContent":["'use strict';\n/* @flow */\n\n/**\n * This is a single-layer [Perceptron Classifier](http://en.wikipedia.org/wiki/Perceptron) that takes\n * arrays of numbers and predicts whether they should be classified\n * as either 0 or 1 (negative or positive examples).\n * @class\n * @example\n * // Create the model\n * var p = new PerceptronModel();\n * // Train the model with input with a diagonal boundary.\n * for (var i = 0; i < 5; i++) {\n *     p.train([1, 1], 1);\n *     p.train([0, 1], 0);\n *     p.train([1, 0], 0);\n *     p.train([0, 0], 0);\n * }\n * p.predict([0, 0]); // 0\n * p.predict([0, 1]); // 0\n * p.predict([1, 0]); // 0\n * p.predict([1, 1]); // 1\n */\nfunction PerceptronModel() {\n    // The weights, or coefficients of the model;\n    // weights are only populated when training with data.\n    this.weights = [];\n    // The bias term, or intercept; it is also a weight but\n    // it's stored separately for convenience as it is always\n    // multiplied by one.\n    this.bias = 0;\n}\n\n/**\n * **Predict**: Use an array of features with the weight array and bias\n * to predict whether an example is labeled 0 or 1.\n *\n * @param {Array<number>} features an array of features as numbers\n * @returns {number} 1 if the score is over 0, otherwise 0\n */\nPerceptronModel.prototype.predict = function(features) {\n\n    // Only predict if previously trained\n    // on the same size feature array(s).\n    if (features.length !== this.weights.length) { return null; }\n\n    // Calculate the sum of features times weights,\n    // with the bias added (implicitly times one).\n    var score = 0;\n    for (var i = 0; i < this.weights.length; i++) {\n        score += this.weights[i] * features[i];\n    }\n    score += this.bias;\n\n    // Classify as 1 if the score is over 0, otherwise 0.\n    if (score > 0) {\n        return 1;\n    } else {\n        return 0;\n    }\n};\n\n/**\n * **Train** the classifier with a new example, which is\n * a numeric array of features and a 0 or 1 label.\n *\n * @param {Array<number>} features an array of features as numbers\n * @param {number} label either 0 or 1\n * @returns {PerceptronModel} this\n */\nPerceptronModel.prototype.train = function(features, label) {\n    // Require that only labels of 0 or 1 are considered.\n    if (label !== 0 && label !== 1) { return null; }\n    // The length of the feature array determines\n    // the length of the weight array.\n    // The perceptron will continue learning as long as\n    // it keeps seeing feature arrays of the same length.\n    // When it sees a new data shape, it initializes.\n    if (features.length !== this.weights.length) {\n        this.weights = features;\n        this.bias = 1;\n    }\n    // Make a prediction based on current weights.\n    var prediction = this.predict(features);\n    // Update the weights if the prediction is wrong.\n    if (prediction !== label) {\n        var gradient = label - prediction;\n        for (var i = 0; i < this.weights.length; i++) {\n            this.weights[i] += gradient * features[i];\n        }\n        this.bias += gradient;\n    }\n    return this;\n};\n\nmodule.exports = PerceptronModel;\n"]},"metadata":{},"sourceType":"script"}