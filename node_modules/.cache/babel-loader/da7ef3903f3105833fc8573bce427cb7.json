{"ast":null,"code":"import randomcolor from 'randomcolor';\nimport DbcUtils from '../../utils/dbc';\nexport default class Signal {\n  constructor(_ref) {\n    let {\n      name,\n      startBit = 0,\n      size = 0,\n      isLittleEndian = true,\n      isSigned = false,\n      isFloat = false,\n      factor = 1,\n      offset = 0,\n      unit = '',\n      receiver = ['XXX'],\n      comment = null,\n      multiplex = null,\n      min = null,\n      max = null,\n      valueDescriptions = new Map()\n    } = _ref;\n    Object.assign(this, {\n      name,\n      startBit,\n      size,\n      isLittleEndian,\n      isSigned,\n      isFloat,\n      factor,\n      offset,\n      unit,\n      receiver,\n      comment,\n      multiplex,\n      valueDescriptions\n    });\n    const uid = Math.random().toString(36);\n\n    if (min == null) {\n      min = this.calculateMin();\n    }\n\n    if (max == null) {\n      max = this.calculateMax();\n    }\n\n    const colors = this.generateColors();\n    Object.assign(this, {\n      min,\n      max,\n      uid,\n      _colors: colors\n    });\n    Object.defineProperty(this, 'colors', {\n      get() {\n        console.error('Something is still using the old colors');\n        debugger;\n        return colors;\n      },\n\n      enumberable: false\n    });\n  }\n\n  text() {\n    const multiplex = this.multiplex ? ` ${this.multiplex}` : '';\n    const byteOrder = this.isLittleEndian ? 1 : 0;\n    const signedChar = this.isSigned ? '-' : '+';\n    return `SG_ ${this.name}${multiplex} : ` + `${this.startBit}|${this.size}@${byteOrder}${signedChar}` + ` (${this.factor},${this.offset})` + ` [${this.min}|${this.max}]` + ` \"${this.unit}\" ${this.receiver}`;\n  }\n\n  valueDescriptionText(msgId) {\n    const entryPairs = Array.from(this.valueDescriptions.entries());\n    const values = entryPairs.reduce((str, _ref2) => {\n      let [value, desc] = _ref2;\n      return `${str + value} \"${desc}\" `;\n    }, '');\n    return `VAL_ ${msgId} ${this.name} ${values};`;\n  }\n\n  lsbBitIndex() {\n    // Returns LSB bit index in matrix order (see AddSignals.js)\n    if (this.isLittleEndian) {\n      return this.startBit;\n    }\n\n    const lsbBitNumber = this.lsbBitNumber();\n    return DbcUtils.matrixBitNumber(lsbBitNumber);\n  }\n\n  lsbBitNumber() {\n    // Returns LSB bit number in big endian ordering\n    return DbcUtils.bigEndianBitIndex(this.startBit) + this.size - 1;\n  }\n\n  msbBitIndex() {\n    if (this.isLittleEndian) {\n      return this.startBit + this.size - 1;\n    }\n\n    return this.startBit;\n  }\n\n  littleEndianBitDescription(bitIndex) {\n    const bitRange = [this.startBit, this.startBit + this.size - 1];\n\n    if (bitIndex < bitRange[0] || bitIndex > bitRange[1]) {\n      return null;\n    }\n\n    const bitNumber = bitIndex - bitRange[0];\n    const isLsb = bitIndex === bitRange[0];\n    const isMsb = bitIndex === bitRange[1];\n    return {\n      bitNumber,\n      isLsb,\n      isMsb\n    };\n  }\n\n  bigEndianBitDescription(bitIndex) {\n    const start = DbcUtils.bigEndianBitIndex(this.startBit);\n    const range = [start, start + this.size - 1];\n    const bitNumber = DbcUtils.bigEndianBitIndex(bitIndex);\n\n    if (bitNumber < range[0] || bitNumber > range[1]) {\n      return null;\n    }\n\n    const isLsb = bitNumber === range[1];\n    const isMsb = bitIndex === this.startBit;\n    return {\n      bitNumber,\n      isLsb,\n      isMsb,\n      range\n    };\n  }\n\n  bitDescription(bitIndex) {\n    if (this.isLittleEndian) {\n      return this.littleEndianBitDescription(bitIndex);\n    }\n\n    return this.bigEndianBitDescription(bitIndex);\n  }\n\n  calculateRawRange() {\n    let rawRange = Math.pow(2, this.size);\n\n    if (this.isSigned) {\n      rawRange /= 2;\n    }\n\n    return [this.isSigned ? -1 * rawRange : 0, rawRange - 1];\n  }\n\n  calculateMin() {\n    const rawMin = this.calculateRawRange()[0];\n    return this.offset + rawMin * this.factor;\n  }\n\n  calculateMax() {\n    const rawMax = this.calculateRawRange()[1];\n    return this.offset + rawMax * this.factor;\n  }\n\n  getColors(messageId) {\n    let parts = messageId.split(':').map(p => (3 + Number.parseInt(p, 16)) * 3 % 253);\n    const colors = this._colors || this.generateColors();\n    let lastColor = 0;\n    return colors.map(c => {\n      parts = parts.map(p => p ^ lastColor);\n      lastColor = parts.reduce((m, v) => m ^ v, c);\n      return lastColor;\n    });\n  }\n\n  generateColors() {\n    const colors = randomcolor({\n      format: 'rgbArray'\n    });\n    return colors;\n  }\n\n  equals(otherSignal) {\n    return otherSignal.name === this.name && otherSignal.startBit === this.startBit && otherSignal.size === this.size && otherSignal.isLittleEndian === this.isLittleEndian && otherSignal.isSigned === this.isSigned && otherSignal.isFloat === this.isFloat && otherSignal.factor === this.factor && otherSignal.offset === this.offset && otherSignal.unit === this.unit && otherSignal.receiver.length === this.receiver.length && otherSignal.receiver.every((v, i) => v === this.receiver[i]) && otherSignal.comment === this.comment && otherSignal.multiplex === this.multiplex;\n  }\n\n}","map":{"version":3,"sources":["/home/amax/Autoro/cabana/src/models/can/signal.js"],"names":["randomcolor","DbcUtils","Signal","constructor","name","startBit","size","isLittleEndian","isSigned","isFloat","factor","offset","unit","receiver","comment","multiplex","min","max","valueDescriptions","Map","Object","assign","uid","Math","random","toString","calculateMin","calculateMax","colors","generateColors","_colors","defineProperty","get","console","error","enumberable","text","byteOrder","signedChar","valueDescriptionText","msgId","entryPairs","Array","from","entries","values","reduce","str","value","desc","lsbBitIndex","lsbBitNumber","matrixBitNumber","bigEndianBitIndex","msbBitIndex","littleEndianBitDescription","bitIndex","bitRange","bitNumber","isLsb","isMsb","bigEndianBitDescription","start","range","bitDescription","calculateRawRange","rawRange","pow","rawMin","rawMax","getColors","messageId","parts","split","map","p","Number","parseInt","lastColor","c","m","v","format","equals","otherSignal","length","every","i"],"mappings":"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","sourcesContent":["import randomcolor from 'randomcolor';\nimport DbcUtils from '../../utils/dbc';\n\nexport default class Signal {\n  constructor({\n    name,\n    startBit = 0,\n    size = 0,\n    isLittleEndian = true,\n    isSigned = false,\n    isFloat = false,\n    factor = 1,\n    offset = 0,\n    unit = '',\n    receiver = ['XXX'],\n    comment = null,\n    multiplex = null,\n    min = null,\n    max = null,\n    valueDescriptions = new Map()\n  }) {\n    Object.assign(this, {\n      name,\n      startBit,\n      size,\n      isLittleEndian,\n      isSigned,\n      isFloat,\n      factor,\n      offset,\n      unit,\n      receiver,\n      comment,\n      multiplex,\n      valueDescriptions\n    });\n\n    const uid = Math.random().toString(36);\n\n    if (min == null) {\n      min = this.calculateMin();\n    }\n    if (max == null) {\n      max = this.calculateMax();\n    }\n\n    const colors = this.generateColors();\n\n    Object.assign(this, {\n      min,\n      max,\n      uid,\n      _colors: colors\n    });\n\n    Object.defineProperty(this, 'colors', {\n      get() {\n        console.error('Something is still using the old colors');\n        debugger;\n        return colors;\n      },\n      enumberable: false\n    });\n  }\n\n  text() {\n    const multiplex = this.multiplex ? ` ${this.multiplex}` : '';\n    const byteOrder = this.isLittleEndian ? 1 : 0;\n    const signedChar = this.isSigned ? '-' : '+';\n\n    return (\n      `SG_ ${this.name}${multiplex} : `\n      + `${this.startBit}|${this.size}@${byteOrder}${signedChar}`\n      + ` (${this.factor},${this.offset})`\n      + ` [${this.min}|${this.max}]`\n      + ` \"${this.unit}\" ${this.receiver}`\n    );\n  }\n\n  valueDescriptionText(msgId) {\n    const entryPairs = Array.from(this.valueDescriptions.entries());\n    const values = entryPairs.reduce(\n      (str, [value, desc]) => `${str + value} \"${desc}\" `,\n      ''\n    );\n    return `VAL_ ${msgId} ${this.name} ${values};`;\n  }\n\n  lsbBitIndex() {\n    // Returns LSB bit index in matrix order (see AddSignals.js)\n\n    if (this.isLittleEndian) {\n      return this.startBit;\n    }\n    const lsbBitNumber = this.lsbBitNumber();\n\n    return DbcUtils.matrixBitNumber(lsbBitNumber);\n  }\n\n  lsbBitNumber() {\n    // Returns LSB bit number in big endian ordering\n\n    return DbcUtils.bigEndianBitIndex(this.startBit) + this.size - 1;\n  }\n\n  msbBitIndex() {\n    if (this.isLittleEndian) {\n      return this.startBit + this.size - 1;\n    }\n    return this.startBit;\n  }\n\n  littleEndianBitDescription(bitIndex) {\n    const bitRange = [this.startBit, this.startBit + this.size - 1];\n    if (bitIndex < bitRange[0] || bitIndex > bitRange[1]) {\n      return null;\n    }\n    const bitNumber = bitIndex - bitRange[0];\n    const isLsb = bitIndex === bitRange[0];\n    const isMsb = bitIndex === bitRange[1];\n    return { bitNumber, isLsb, isMsb };\n  }\n\n  bigEndianBitDescription(bitIndex) {\n    const start = DbcUtils.bigEndianBitIndex(this.startBit);\n    const range = [start, start + this.size - 1];\n    const bitNumber = DbcUtils.bigEndianBitIndex(bitIndex);\n\n    if (bitNumber < range[0] || bitNumber > range[1]) {\n      return null;\n    }\n\n    const isLsb = bitNumber === range[1];\n    const isMsb = bitIndex === this.startBit;\n    return {\n      bitNumber,\n      isLsb,\n      isMsb,\n      range\n    };\n  }\n\n  bitDescription(bitIndex) {\n    if (this.isLittleEndian) {\n      return this.littleEndianBitDescription(bitIndex);\n    }\n    return this.bigEndianBitDescription(bitIndex);\n  }\n\n  calculateRawRange() {\n    let rawRange = Math.pow(2, this.size);\n    if (this.isSigned) {\n      rawRange /= 2;\n    }\n    return [this.isSigned ? -1 * rawRange : 0, rawRange - 1];\n  }\n\n  calculateMin() {\n    const rawMin = this.calculateRawRange()[0];\n    return this.offset + rawMin * this.factor;\n  }\n\n  calculateMax() {\n    const rawMax = this.calculateRawRange()[1];\n    return this.offset + rawMax * this.factor;\n  }\n\n  getColors(messageId) {\n    let parts = messageId.split(':').map((p) => ((3 + Number.parseInt(p, 16)) * 3) % 253);\n    const colors = this._colors || this.generateColors();\n\n    let lastColor = 0;\n\n    return colors.map((c) => {\n      parts = parts.map(p => p ^ lastColor);\n      lastColor = parts.reduce((m, v) => m ^ v, c);\n      return lastColor;\n    });\n  }\n\n  generateColors() {\n    const colors = randomcolor({ format: 'rgbArray' });\n\n    return colors;\n  }\n\n  equals(otherSignal) {\n    return (\n      otherSignal.name === this.name\n      && otherSignal.startBit === this.startBit\n      && otherSignal.size === this.size\n      && otherSignal.isLittleEndian === this.isLittleEndian\n      && otherSignal.isSigned === this.isSigned\n      && otherSignal.isFloat === this.isFloat\n      && otherSignal.factor === this.factor\n      && otherSignal.offset === this.offset\n      && otherSignal.unit === this.unit\n      && otherSignal.receiver.length === this.receiver.length\n      && otherSignal.receiver.every((v, i) => v === this.receiver[i])\n      && otherSignal.comment === this.comment\n      && otherSignal.multiplex === this.multiplex\n    );\n  }\n}\n"]},"metadata":{},"sourceType":"module"}