{"ast":null,"code":"'use strict';\n/* @flow */\n\n/**\n * The [mode](http://bit.ly/W5K4Yt) is the number that appears in a list the highest number of times.\n * There can be multiple modes in a list: in the event of a tie, this\n * algorithm will return the most recently seen mode.\n *\n * This is a [measure of central tendency](https://en.wikipedia.org/wiki/Central_tendency):\n * a method of finding a typical or central value of a set of numbers.\n *\n * This runs in `O(n)` because the input is sorted.\n *\n * @param {Array<number>} sorted a sample of one or more data points\n * @returns {number} mode\n * @throws {Error} if sorted is empty\n * @example\n * modeSorted([0, 0, 1]); // => 0\n */\n\nfunction modeSorted(sorted\n/*: Array<number> */\n)\n/*:number*/\n{\n  // Handle edge cases:\n  // The mode of an empty list is undefined\n  if (sorted.length === 0) {\n    throw new Error('mode requires at least one data point');\n  } else if (sorted.length === 1) {\n    return sorted[0];\n  } // This assumes it is dealing with an array of size > 1, since size\n  // 0 and 1 are handled immediately. Hence it starts at index 1 in the\n  // array.\n\n\n  var last = sorted[0],\n      // store the mode as we find new modes\n  value = NaN,\n      // store how many times we've seen the mode\n  maxSeen = 0,\n      // how many times the current candidate for the mode\n  // has been seen\n  seenThis = 1; // end at sorted.length + 1 to fix the case in which the mode is\n  // the highest number that occurs in the sequence. the last iteration\n  // compares sorted[i], which is undefined, to the highest number\n  // in the series\n\n  for (var i = 1; i < sorted.length + 1; i++) {\n    // we're seeing a new number pass by\n    if (sorted[i] !== last) {\n      // the last number is the new mode since we saw it more\n      // often than the old one\n      if (seenThis > maxSeen) {\n        maxSeen = seenThis;\n        value = last;\n      }\n\n      seenThis = 1;\n      last = sorted[i]; // if this isn't a new number, it's one more occurrence of\n      // the potential mode\n    } else {\n      seenThis++;\n    }\n  }\n\n  return value;\n}\n\nmodule.exports = modeSorted;","map":{"version":3,"sources":["/home/amax/Autoro/cabana/node_modules/simple-statistics/src/mode_sorted.js"],"names":["modeSorted","sorted","length","Error","last","value","NaN","maxSeen","seenThis","i","module","exports"],"mappings":"AAAA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,SAASA,UAAT,CAAoBC;AAAO;AAA3B;AAAgD;AAAY;AAExD;AACA;AACA,MAAIA,MAAM,CAACC,MAAP,KAAkB,CAAtB,EAAyB;AACrB,UAAM,IAAIC,KAAJ,CAAU,uCAAV,CAAN;AACH,GAFD,MAEO,IAAIF,MAAM,CAACC,MAAP,KAAkB,CAAtB,EAAyB;AAC5B,WAAOD,MAAM,CAAC,CAAD,CAAb;AACH,GARuD,CAUxD;AACA;AACA;;;AACA,MAAIG,IAAI,GAAGH,MAAM,CAAC,CAAD,CAAjB;AAAA,MACI;AACAI,EAAAA,KAAK,GAAGC,GAFZ;AAAA,MAGI;AACAC,EAAAA,OAAO,GAAG,CAJd;AAAA,MAKI;AACA;AACAC,EAAAA,QAAQ,GAAG,CAPf,CAbwD,CAsBxD;AACA;AACA;AACA;;AACA,OAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGR,MAAM,CAACC,MAAP,GAAgB,CAApC,EAAuCO,CAAC,EAAxC,EAA4C;AACxC;AACA,QAAIR,MAAM,CAACQ,CAAD,CAAN,KAAcL,IAAlB,EAAwB;AACpB;AACA;AACA,UAAII,QAAQ,GAAGD,OAAf,EAAwB;AACpBA,QAAAA,OAAO,GAAGC,QAAV;AACAH,QAAAA,KAAK,GAAGD,IAAR;AACH;;AACDI,MAAAA,QAAQ,GAAG,CAAX;AACAJ,MAAAA,IAAI,GAAGH,MAAM,CAACQ,CAAD,CAAb,CARoB,CASxB;AACA;AACC,KAXD,MAWO;AAAED,MAAAA,QAAQ;AAAK;AACzB;;AACD,SAAOH,KAAP;AACH;;AAEDK,MAAM,CAACC,OAAP,GAAiBX,UAAjB","sourcesContent":["'use strict';\n/* @flow */\n\n/**\n * The [mode](http://bit.ly/W5K4Yt) is the number that appears in a list the highest number of times.\n * There can be multiple modes in a list: in the event of a tie, this\n * algorithm will return the most recently seen mode.\n *\n * This is a [measure of central tendency](https://en.wikipedia.org/wiki/Central_tendency):\n * a method of finding a typical or central value of a set of numbers.\n *\n * This runs in `O(n)` because the input is sorted.\n *\n * @param {Array<number>} sorted a sample of one or more data points\n * @returns {number} mode\n * @throws {Error} if sorted is empty\n * @example\n * modeSorted([0, 0, 1]); // => 0\n */\nfunction modeSorted(sorted /*: Array<number> */)/*:number*/ {\n\n    // Handle edge cases:\n    // The mode of an empty list is undefined\n    if (sorted.length === 0) {\n        throw new Error('mode requires at least one data point');\n    } else if (sorted.length === 1) {\n        return sorted[0];\n    }\n\n    // This assumes it is dealing with an array of size > 1, since size\n    // 0 and 1 are handled immediately. Hence it starts at index 1 in the\n    // array.\n    var last = sorted[0],\n        // store the mode as we find new modes\n        value = NaN,\n        // store how many times we've seen the mode\n        maxSeen = 0,\n        // how many times the current candidate for the mode\n        // has been seen\n        seenThis = 1;\n\n    // end at sorted.length + 1 to fix the case in which the mode is\n    // the highest number that occurs in the sequence. the last iteration\n    // compares sorted[i], which is undefined, to the highest number\n    // in the series\n    for (var i = 1; i < sorted.length + 1; i++) {\n        // we're seeing a new number pass by\n        if (sorted[i] !== last) {\n            // the last number is the new mode since we saw it more\n            // often than the old one\n            if (seenThis > maxSeen) {\n                maxSeen = seenThis;\n                value = last;\n            }\n            seenThis = 1;\n            last = sorted[i];\n        // if this isn't a new number, it's one more occurrence of\n        // the potential mode\n        } else { seenThis++; }\n    }\n    return value;\n}\n\nmodule.exports = modeSorted;\n"]},"metadata":{},"sourceType":"script"}