{"ast":null,"code":"import CloudLog from '../../logging/CloudLog';\nimport Signal from './signal';\nimport Frame from './frame';\nimport BoardUnit from './BoardUnit';\nimport DbcUtils from '../../utils/dbc';\nconst DBC_COMMENT_RE = /^CM_ *\"(.*)\";/;\nconst DBC_COMMENT_MULTI_LINE_RE = /^CM_ *\"(.*)/;\nconst MSG_RE = /^BO_ (\\w+) (\\w+) *: (\\w+) (\\w+)/;\nconst SIGNAL_RE = /^SG_ (\\w+) : (\\d+)\\|(\\d+)@(\\d+)([+|-]) \\(([0-9.+-eE]+),([0-9.+-eE]+)\\) \\[([0-9.+-eE]+)\\|([0-9.+-eE]+)\\] \"(.*)\" (.*)/; // Multiplexed signal\n\nconst MP_SIGNAL_RE = /^SG_ (\\w+) (\\w+) *: (\\d+)\\|(\\d+)@(\\d+)([+|-]) \\(([0-9.+-eE]+),([0-9.+-eE]+)\\) \\[([0-9.+-eE]+)\\|([0-9.+-eE]+)\\] \"(.*)\" (.*)/;\nconst VAL_RE = /^VAL_ (\\w+) (\\w+) (.*);/;\nconst VAL_TABLE_RE = /^VAL_TABLE_ (\\w+) (.*);/;\nconst MSG_TRANSMITTER_RE = /^BO_TX_BU_ ([0-9]+) *: *(.+);/;\nconst SIGNAL_COMMENT_RE = /^CM_ SG_ *(\\w+) *(\\w+) *\"(.*)\";/;\nconst SIGNAL_COMMENT_MULTI_LINE_RE = /^CM_ SG_ *(\\w+) *(\\w+) *\"(.*)/; // Message Comments (CM_ BO_ )\n\nconst MESSAGE_COMMENT_RE = /^CM_ BO_ *(\\w+) *\"(.*)\";/;\nconst MESSAGE_COMMENT_MULTI_LINE_RE = /^CM_ BO_ *(\\w+) *\"(.*)/;\nconst BOARD_UNIT_RE = /^BU_:(.*)/;\nconst BOARD_UNIT_COMMENT_RE = /^CM_ BU_ *(\\w+) *\"(.*)\";/;\nconst BOARD_UNIT_COMMENT_MULTI_LINE_RE = /^CM_ BU_ *(\\w+) *\"(.*)/; // Follow ups are used to parse multi-line comment definitions\n\nconst FOLLOW_UP_DBC_COMMENT = 'FollowUpDbcComment';\nconst FOLLOW_UP_SIGNAL_COMMENT = 'FollowUpSignalComment';\nconst FOLLOW_UP_MSG_COMMENT = 'FollowUpMsgComment';\nconst FOLLOW_UP_BOARD_UNIT_COMMENT = 'FollowUpBoardUnitComment';\n/* global BigInt */\n\nfunction floatOrInt(numericStr) {\n  if (Number.isInteger(numericStr)) {\n    return parseInt(numericStr, 10);\n  }\n\n  return parseFloat(numericStr);\n}\n\nexport function swapOrder(arr, wordSize, gSize) {\n  const swappedWords = [];\n\n  for (let i = 0; i < arr.length; i += wordSize) {\n    const word = arr.slice(i, i + wordSize);\n\n    for (let j = wordSize - gSize; j > -gSize; j -= gSize) {\n      swappedWords.push(word.slice(j, j + gSize));\n    }\n  }\n\n  return swappedWords.join('');\n}\nexport default class DBC {\n  constructor(dbcString) {\n    this.boardUnits = [];\n    this.comments = [];\n    this.messages = new Map();\n\n    if (dbcString !== undefined) {\n      this.dbcText = dbcString;\n      this.importDbcString(dbcString);\n    }\n  }\n\n  getMessageFrame(address) {\n    return this.messages.get(address);\n  }\n\n  nextNewFrameName() {\n    const messageNames = [];\n\n    for (const msg of this.messages.values()) {\n      messageNames.push(msg.name);\n    }\n\n    let msgNum = 1;\n    let msgName;\n\n    do {\n      msgName = `NEW_MSG_${msgNum}`;\n      msgNum++;\n    } while (messageNames.indexOf(msgName) !== -1);\n\n    return msgName;\n  }\n\n  updateBoardUnits() {\n    const boardUnitNames = this.boardUnits.map(bu => bu.name);\n    const missingBoardUnits = Array.from(this.messages.entries()).map(_ref => {\n      let [msgId, frame] = _ref;\n      return Object.values(frame.signals);\n    }).reduce((arr, signals) => arr.concat(signals), []).map(signal => signal.receiver).reduce((arr, receivers) => arr.concat(receivers), []).filter((recv, idx, array) => array.indexOf(recv) === idx).filter(recv => boardUnitNames.indexOf(recv) === -1).map(recv => new BoardUnit(recv));\n    this.boardUnits = this.boardUnits.concat(missingBoardUnits);\n  }\n\n  text() {\n    this.updateBoardUnits();\n    let txt = 'VERSION \"\"\\n\\n\\n';\n    txt += `NS_ :${this._newSymbols()}`;\n    txt += '\\n\\nBS_:\\n';\n    const boardUnitsText = this.boardUnits.map(bu => bu.text()).join(' ');\n    txt += `\\nBU_: ${boardUnitsText}\\n\\n\\n`;\n    const frames = [];\n\n    for (const frame of this.messages.values()) {\n      frames.push(frame);\n    }\n\n    txt += `${frames.map(f => f.text()).join('\\n\\n')}\\n\\n`;\n    const messageTxs = frames.map(f => [f.id, f.transmitters.slice(1)]).filter(_ref2 => {\n      let [addr, txs] = _ref2;\n      return txs.length > 0;\n    });\n    txt += `${messageTxs.map(_ref3 => {\n      let [addr, txs] = _ref3;\n      return `BO_TX_BU_ ${addr} : ${txs.join(',')};`;\n    }).join('\\n')}\\n\\n\\n`;\n    txt += this.boardUnits.filter(bu => bu.comment !== null).map(bu => `CM_ BU_ ${bu.name} \"${bu.comment}\";`).join('\\n');\n    txt += frames.filter(f => f.comment !== null).map(msg => `CM_ BO_ ${msg.address} \"${msg.comment}\";`).join('\\n');\n    const signalsByMsgId = frames.map(f => Object.values(f.signals).map(sig => [f.id, sig])).reduce((s1, s2) => s1.concat(s2), []);\n    txt += `${signalsByMsgId.filter(_ref4 => {\n      let [msgAddr, sig] = _ref4;\n      return sig.comment !== null;\n    }).map(_ref5 => {\n      let [msgAddr, sig] = _ref5;\n      return `CM_ SG_ ${msgAddr} ${sig.name} \"${sig.comment}\";`;\n    }).join('\\n')}\\n`;\n    txt += `${signalsByMsgId.filter(_ref6 => {\n      let [msgAddr, sig] = _ref6;\n      return sig.valueDescriptions.size > 0;\n    }).map(_ref7 => {\n      let [msgAddr, sig] = _ref7;\n      return sig.valueDescriptionText(msgAddr);\n    }).join('\\n')}\\n`;\n    txt += this.comments.map(comment => `CM_ \"${comment}\";`).join('\\n');\n    return `${txt.trim()}\\n`;\n  }\n\n  getMessageName(msgId) {\n    const msg = this.getMessageFrame(msgId);\n    if (msg && msg.frame) return msg.frame.name;\n    return null;\n  }\n\n  getSignals(msgId) {\n    const msg = this.getMessageFrame(msgId);\n    if (msg) return msg.signals;\n    return {};\n  }\n\n  createFrame(msgId) {\n    let size = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 64;\n    const msg = new Frame({\n      name: this.nextNewFrameName(),\n      id: msgId,\n      size: size\n    });\n    this.messages.set(msgId, msg);\n    return msg;\n  }\n\n  setSignals(msgId, signals, frameSize) {\n    const msg = this.getMessageFrame(msgId); // TODO conform frameSize\n\n    if (msg) {\n      const newMsg = Object.assign(Object.create(msg), msg);\n      newMsg.signals = signals;\n      this.messages.set(msgId, newMsg);\n    } else {\n      const msg = this.createFrame(msgId, frameSize);\n      msg.signals = signals;\n      this.messages.set(msgId, msg);\n      this.updateBoardUnits();\n    }\n  }\n\n  addSignal(msgId, signal) {\n    const msg = this.getMessageFrame(msgId);\n\n    if (msg) {\n      msg.signals[signal.name] = signal;\n      this.updateBoardUnits();\n    }\n  }\n\n  importDbcString(dbcString) {\n    const warnings = [];\n    const messages = new Map();\n    let boardUnits = [];\n    const valueTables = new Map();\n    let id = 0;\n    let followUp = null;\n    const lines = dbcString.split('\\n');\n\n    for (let i = 0; i < lines.length; i++) {\n      let line = lines[i].trim();\n      if (line.length === 0) continue;\n\n      if (followUp != null) {\n        const {\n          type,\n          data\n        } = followUp;\n        line = line.replace(/\" *;/, '');\n        let followUpLine = `\\n${line.substr(0, line.length)}`;\n\n        if (line.indexOf('\"') !== -1) {\n          followUp = null;\n          followUpLine = followUpLine.substr(0, followUpLine.length - 1);\n        }\n\n        if (type === FOLLOW_UP_SIGNAL_COMMENT) {\n          const signal = data;\n          signal.comment += followUpLine;\n        } else if (type === FOLLOW_UP_MSG_COMMENT) {\n          const msg = data;\n          msg.comment += followUpLine;\n        } else if (type === FOLLOW_UP_BOARD_UNIT_COMMENT) {\n          const boardUnit = data;\n          boardUnit.comment += followUpLine;\n        } else if (type === FOLLOW_UP_DBC_COMMENT) {\n          //          const comment = data;\n          const partialComment = this.comments[this.comments.length - 1];\n          this.comments[this.comments.length - 1] = partialComment + followUpLine;\n        }\n      }\n\n      if (line.indexOf('BO_ ') === 0) {\n        const matches = line.match(MSG_RE);\n\n        if (matches === null) {\n          warnings.push(`failed to parse message definition on line ${i + 1} -- ${line}`);\n          continue;\n        }\n\n        let [idString, name, size, transmitter] = matches.slice(1);\n        id = parseInt(idString, 0); // 0 radix parses hex or dec\n\n        size = parseInt(size, 10);\n        const frame = new Frame({\n          name,\n          id,\n          size,\n          transmitters: [transmitter]\n        });\n        messages.set(id, frame);\n      } else if (line.indexOf('SG_') === 0) {\n        let matches = line.match(SIGNAL_RE);\n\n        if (matches === null) {\n          matches = line.match(MP_SIGNAL_RE);\n\n          if (matches === null) {\n            warnings.push(`failed to parse signal definition on line ${i + 1} -- ${line}`);\n            continue;\n          } // for now, ignore multiplex which is matches[1]\n\n\n          matches = matches[1] + matches.slice(3);\n        } else {\n          matches = matches.slice(1);\n        }\n\n        let [name, startBit, size, isLittleEndian, isSigned, factor, offset, min, max, unit, receiverStr] = matches;\n        startBit = parseInt(startBit, 10);\n        size = parseInt(size, 10);\n        isLittleEndian = parseInt(isLittleEndian, 10) === 1;\n        isSigned = isSigned === '-';\n        factor = floatOrInt(factor);\n        offset = floatOrInt(offset);\n        min = floatOrInt(min);\n        max = floatOrInt(max);\n        const receiver = receiverStr.split(',').map(s => s.trim());\n        const signalProperties = {\n          name,\n          startBit,\n          size,\n          isLittleEndian,\n          isSigned,\n          factor,\n          offset,\n          unit,\n          min,\n          max,\n          receiver\n        };\n        const signal = new Signal(signalProperties);\n\n        if (messages.get(id) !== undefined) {\n          messages.get(id).signals[name] = signal;\n        } else {\n          CloudLog.warn(`importDbcString: could not add signal: ${name} due to missing message: ${id}`);\n        }\n      } else if (line.indexOf('VAL_ ') === 0) {\n        const matches = line.match(VAL_RE);\n\n        if (matches !== null) {\n          let [messageId, signalName, vals] = matches.slice(1);\n          vals = vals.split('\"').map(s => s.trim()).filter(s => s.length > 0);\n          messageId = parseInt(messageId, 10);\n          const msg = messages.get(messageId);\n          const signal = msg.signals[signalName];\n\n          if (signal === undefined) {\n            warnings.push(`could not find signal for value description on line ${i + 1} -- ${line}`);\n            continue;\n          }\n\n          for (let i = 0; i < vals.length; i += 2) {\n            const value = vals[i].trim();\n            const description = vals[i + 1].trim();\n            signal.valueDescriptions.set(value, description);\n          }\n        } else {\n          warnings.push(`failed to parse value description on line ${i + 1} -- ${line}`);\n        }\n      } else if (line.indexOf('VAL_TABLE_ ') === 0) {\n        const matches = line.match(VAL_TABLE_RE);\n\n        if (matches !== null) {\n          const table = new Map();\n          let [tableName, items] = matches.slice(1);\n          items = items.split('\"').map(s => s.trim()).filter(s => s.length > 0);\n\n          for (let i = 0; i < items.length; i += 2) {\n            const key = items[i];\n            const value = items[i + 1];\n            table.set(key, value);\n          }\n\n          valueTables.set(tableName, table);\n        } else {\n          warnings.push(`failed to parse value table on line ${i + 1} -- ${line}`);\n        }\n      } else if (line.indexOf('BO_TX_BU_ ') === 0) {\n        const matches = line.match(MSG_TRANSMITTER_RE);\n\n        if (matches !== null) {\n          let [messageId, transmitter] = matches.slice(1);\n          messageId = parseInt(messageId, 10);\n          const msg = messages.get(messageId);\n          msg.transmitters.push(transmitter);\n          messages.set(messageId, msg);\n        } else {\n          warnings.push(`failed to parse message transmitter definition on line ${i + 1} -- ${line}`);\n        }\n      } else if (line.indexOf('CM_ SG_ ') === 0) {\n        let matches = line.match(SIGNAL_COMMENT_RE);\n        let hasFollowUp = false;\n\n        if (matches === null) {\n          matches = line.match(SIGNAL_COMMENT_MULTI_LINE_RE);\n          hasFollowUp = true;\n        }\n\n        if (matches === null) {\n          warnings.push(`failed to parse signal comment on line ${i + 1} -- ${line}`);\n          continue;\n        }\n\n        let [messageId, signalName, comment] = matches.slice(1);\n        messageId = parseInt(messageId, 10);\n        const msg = messages.get(messageId);\n\n        if (msg === undefined) {\n          warnings.push(`failed to parse signal comment on line ${i + 1} -- ${line}:\n                                    message id ${messageId} does not exist prior to this line`);\n          continue;\n        }\n\n        const signal = msg.signals[signalName];\n\n        if (signal === undefined) {\n          warnings.push(`failed to parse signal comment on line ${i + 1} -- ${line}`);\n          continue;\n        } else {\n          signal.comment = comment;\n          messages.set(messageId, msg);\n        }\n\n        if (hasFollowUp) {\n          followUp = {\n            type: FOLLOW_UP_SIGNAL_COMMENT,\n            data: signal\n          };\n        }\n      } else if (line.indexOf('CM_ BO_ ') === 0) {\n        let matches = line.match(MESSAGE_COMMENT_RE);\n        let hasFollowUp = false;\n\n        if (matches === null) {\n          matches = line.match(MESSAGE_COMMENT_MULTI_LINE_RE);\n          hasFollowUp = true;\n\n          if (matches === null) {\n            warnings.push(`failed to message comment on line ${i + 1} -- ${line}`);\n            continue;\n          }\n        }\n\n        let [messageId, comment] = matches.slice(1);\n        messageId = parseInt(messageId, 10);\n        const msg = messages.get(messageId);\n\n        if (msg === undefined) {\n          warnings.push(`failed to find message to add comment to, msg id: ${messageId}`);\n          continue;\n        }\n\n        msg.comment = comment;\n\n        if (hasFollowUp) {\n          followUp = {\n            type: FOLLOW_UP_MSG_COMMENT,\n            data: msg\n          };\n        }\n      } else if (line.indexOf('BU_: ') === 0) {\n        const matches = line.match(BOARD_UNIT_RE);\n\n        if (matches !== null) {\n          const [boardUnitNameStr] = matches.slice(1);\n          const newBoardUnits = boardUnitNameStr.split(' ').map(s => s.trim()).filter(s => s.length > 0).map(name => new BoardUnit(name));\n          boardUnits = boardUnits.concat(newBoardUnits);\n        } else {\n          warnings.push(`failed to parse board unit definition on line ${i + 1} -- ${line}`);\n          continue;\n        }\n      } else if (line.indexOf('CM_ BU_ ') === 0) {\n        let matches = line.match(BOARD_UNIT_COMMENT_RE);\n        let hasFollowUp = false;\n\n        if (matches === null) {\n          matches = line.match(BOARD_UNIT_COMMENT_MULTI_LINE_RE);\n          hasFollowUp = true;\n\n          if (matches === null) {\n            warnings.push(`failed to parse board unit comment on line ${i + 1} -- ${line}`);\n            continue;\n          }\n        }\n\n        const [boardUnitName, comment] = matches.slice(1);\n        const boardUnit = boardUnits.find(bu => bu.name === boardUnitName);\n\n        if (boardUnit) {\n          boardUnit.comment = comment;\n        }\n\n        if (hasFollowUp) {\n          followUp = {\n            type: FOLLOW_UP_BOARD_UNIT_COMMENT,\n            data: boardUnit\n          };\n        }\n      } else if (line.indexOf('CM_ ') === 0) {\n        let matches = line.match(DBC_COMMENT_RE);\n        let hasFollowUp = false;\n\n        if (matches === null) {\n          matches = line.match(DBC_COMMENT_MULTI_LINE_RE);\n\n          if (matches === null) {\n            warnings.push(`failed to parse dbc comment on line ${i + 1} -- ${line}`);\n            continue;\n          } else {\n            hasFollowUp = true;\n          }\n        }\n\n        const [comment] = matches.slice(1);\n        this.comments.push(comment);\n\n        if (hasFollowUp) {\n          followUp = {\n            type: FOLLOW_UP_DBC_COMMENT,\n            data: comment\n          };\n        }\n      }\n    } // Disabled b/c live mode frequently calls this function\n    // and executes way too many network requests\n\n\n    if (warnings.length > 0) {// warnings.forEach((warning) => CloudLog.warn('importDbcString: ' + warning));\n      // warnings.forEach((warning) => console.log('importDbcString: ' + warning));\n    }\n\n    this.messages = messages;\n    this.boardUnits = boardUnits;\n    this.valueTables = valueTables;\n  }\n\n  valueForIntSignal(signalSpec, view) {\n    let sig_lsb, sig_msb;\n\n    if (signalSpec.isLittleEndian) {\n      sig_lsb = signalSpec.startBit;\n      sig_msb = signalSpec.startBit + signalSpec.size - 1;\n    } else {\n      sig_lsb = DbcUtils.matrixBitNumber(DbcUtils.bigEndianBitIndex(signalSpec.startBit) + signalSpec.size - 1);\n      sig_msb = signalSpec.startBit;\n    }\n\n    let ret = signalSpec.size > 32 ? 0n : 0;\n    let i = Math.floor(sig_msb / 8);\n    let bits = signalSpec.size;\n\n    while (i >= 0 && i < view.byteLength && bits > 0) {\n      let lsb = Math.floor(sig_lsb / 8) === i ? sig_lsb : i * 8;\n      let msb = Math.floor(sig_msb / 8) === i ? sig_msb : (i + 1) * 8 - 1;\n      let size = msb - lsb + 1;\n      let d = view.getUint8(i) >>> lsb - i * 8 & (1 << size) - 1;\n\n      if (signalSpec.size > 32) {\n        ret |= BigInt(d) << BigInt(bits - size);\n      } else {\n        ret |= d << bits - size;\n      }\n\n      bits -= size;\n      i = signalSpec.isLittleEndian ? i - 1 : i + 1;\n    }\n\n    if (signalSpec.size > 32) {\n      ret = signalSpec.isSigned ? BigInt.asIntN(64, ret) : ret;\n\n      if (Number.isInteger(signalSpec.factor)) {\n        return ret * BigInt(signalSpec.factor) + BigInt(signalSpec.offset);\n      } else {\n        return parseFloat(ret) * signalSpec.factor + signalSpec.offset;\n      }\n    } else {\n      if (signalSpec.isSigned) {\n        ret -= ret >> signalSpec.size - 1 & 1 ? 1 << signalSpec.size : 0;\n      }\n\n      return ret * signalSpec.factor + signalSpec.offset;\n    }\n  }\n\n  getSignalValues(messageId, data) {\n    if (!this.messages.has(messageId)) {\n      return {};\n    }\n\n    const frame = this.getMessageFrame(messageId);\n    const view = new DataView(data.buffer);\n    const signalValuesByName = {};\n    Object.values(frame.signals).forEach(signalSpec => {\n      if (isNaN(signalSpec.startBit)) {\n        return;\n      }\n\n      signalValuesByName[signalSpec.name] = this.valueForIntSignal(signalSpec, view);\n    });\n    return signalValuesByName;\n  }\n\n  getChffrMetricMappings() {\n    const metricComment = this.comments.find(comment => comment.indexOf('CHFFR_METRIC') === 0);\n\n    if (!metricComment) {\n      return null;\n    }\n\n    return metricComment.split(';').map(metric => metric.trim().split(' ')).reduce((metrics, _ref8) => {\n      let [_, messageId, signalName, metricName, factor, offset] = _ref8;\n      metrics[metricName] = {\n        messageId: parseInt(messageId, 10),\n        signalName,\n        factor: parseFloat(factor),\n        offset: parseFloat(offset)\n      };\n      return metrics;\n    }, {});\n  }\n\n  _newSymbols() {\n    return `\n    NS_DESC_\n    CM_\n    BA_DEF_\n    BA_\n    VAL_\n    CAT_DEF_\n    CAT_\n    FILTER\n    BA_DEF_DEF_\n    EV_DATA_\n    ENVVAR_DATA_\n    SGTYPE_\n    SGTYPE_VAL_\n    BA_DEF_SGTYPE_\n    BA_SGTYPE_\n    SIG_TYPE_REF_\n    VAL_TABLE_\n    SIG_GROUP_\n    SIG_VALTYPE_\n    SIGTYPE_VALTYPE_\n    BO_TX_BU_\n    BA_DEF_REL_\n    BA_REL_\n    BA_DEF_DEF_REL_\n    BU_SG_REL_\n    BU_EV_REL_\n    BU_BO_REL_\n    SG_MUL_VAL_`;\n  }\n\n}","map":{"version":3,"sources":["/home/amax/Autoro/cabana/src/models/can/dbc.js"],"names":["CloudLog","Signal","Frame","BoardUnit","DbcUtils","DBC_COMMENT_RE","DBC_COMMENT_MULTI_LINE_RE","MSG_RE","SIGNAL_RE","MP_SIGNAL_RE","VAL_RE","VAL_TABLE_RE","MSG_TRANSMITTER_RE","SIGNAL_COMMENT_RE","SIGNAL_COMMENT_MULTI_LINE_RE","MESSAGE_COMMENT_RE","MESSAGE_COMMENT_MULTI_LINE_RE","BOARD_UNIT_RE","BOARD_UNIT_COMMENT_RE","BOARD_UNIT_COMMENT_MULTI_LINE_RE","FOLLOW_UP_DBC_COMMENT","FOLLOW_UP_SIGNAL_COMMENT","FOLLOW_UP_MSG_COMMENT","FOLLOW_UP_BOARD_UNIT_COMMENT","floatOrInt","numericStr","Number","isInteger","parseInt","parseFloat","swapOrder","arr","wordSize","gSize","swappedWords","i","length","word","slice","j","push","join","DBC","constructor","dbcString","boardUnits","comments","messages","Map","undefined","dbcText","importDbcString","getMessageFrame","address","get","nextNewFrameName","messageNames","msg","values","name","msgNum","msgName","indexOf","updateBoardUnits","boardUnitNames","map","bu","missingBoardUnits","Array","from","entries","msgId","frame","Object","signals","reduce","concat","signal","receiver","receivers","filter","recv","idx","array","text","txt","_newSymbols","boardUnitsText","frames","f","messageTxs","id","transmitters","addr","txs","comment","signalsByMsgId","sig","s1","s2","msgAddr","valueDescriptions","size","valueDescriptionText","trim","getMessageName","getSignals","createFrame","set","setSignals","frameSize","newMsg","assign","create","addSignal","warnings","valueTables","followUp","lines","split","line","type","data","replace","followUpLine","substr","boardUnit","partialComment","matches","match","idString","transmitter","startBit","isLittleEndian","isSigned","factor","offset","min","max","unit","receiverStr","s","signalProperties","warn","messageId","signalName","vals","value","description","table","tableName","items","key","hasFollowUp","boardUnitNameStr","newBoardUnits","boardUnitName","find","valueForIntSignal","signalSpec","view","sig_lsb","sig_msb","matrixBitNumber","bigEndianBitIndex","ret","Math","floor","bits","byteLength","lsb","msb","d","getUint8","BigInt","asIntN","getSignalValues","has","DataView","buffer","signalValuesByName","forEach","isNaN","getChffrMetricMappings","metricComment","metric","metrics","_","metricName"],"mappings":"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","sourcesContent":["import CloudLog from '../../logging/CloudLog';\nimport Signal from './signal';\nimport Frame from './frame';\nimport BoardUnit from './BoardUnit';\nimport DbcUtils from '../../utils/dbc';\n\nconst DBC_COMMENT_RE = /^CM_ *\"(.*)\";/;\nconst DBC_COMMENT_MULTI_LINE_RE = /^CM_ *\"(.*)/;\n\nconst MSG_RE = /^BO_ (\\w+) (\\w+) *: (\\w+) (\\w+)/;\n\nconst SIGNAL_RE = /^SG_ (\\w+) : (\\d+)\\|(\\d+)@(\\d+)([+|-]) \\(([0-9.+-eE]+),([0-9.+-eE]+)\\) \\[([0-9.+-eE]+)\\|([0-9.+-eE]+)\\] \"(.*)\" (.*)/;\n// Multiplexed signal\nconst MP_SIGNAL_RE = /^SG_ (\\w+) (\\w+) *: (\\d+)\\|(\\d+)@(\\d+)([+|-]) \\(([0-9.+-eE]+),([0-9.+-eE]+)\\) \\[([0-9.+-eE]+)\\|([0-9.+-eE]+)\\] \"(.*)\" (.*)/;\n\nconst VAL_RE = /^VAL_ (\\w+) (\\w+) (.*);/;\nconst VAL_TABLE_RE = /^VAL_TABLE_ (\\w+) (.*);/;\n\nconst MSG_TRANSMITTER_RE = /^BO_TX_BU_ ([0-9]+) *: *(.+);/;\n\nconst SIGNAL_COMMENT_RE = /^CM_ SG_ *(\\w+) *(\\w+) *\"(.*)\";/;\nconst SIGNAL_COMMENT_MULTI_LINE_RE = /^CM_ SG_ *(\\w+) *(\\w+) *\"(.*)/;\n\n// Message Comments (CM_ BO_ )\nconst MESSAGE_COMMENT_RE = /^CM_ BO_ *(\\w+) *\"(.*)\";/;\nconst MESSAGE_COMMENT_MULTI_LINE_RE = /^CM_ BO_ *(\\w+) *\"(.*)/;\n\nconst BOARD_UNIT_RE = /^BU_:(.*)/;\nconst BOARD_UNIT_COMMENT_RE = /^CM_ BU_ *(\\w+) *\"(.*)\";/;\nconst BOARD_UNIT_COMMENT_MULTI_LINE_RE = /^CM_ BU_ *(\\w+) *\"(.*)/;\n\n// Follow ups are used to parse multi-line comment definitions\nconst FOLLOW_UP_DBC_COMMENT = 'FollowUpDbcComment';\nconst FOLLOW_UP_SIGNAL_COMMENT = 'FollowUpSignalComment';\nconst FOLLOW_UP_MSG_COMMENT = 'FollowUpMsgComment';\nconst FOLLOW_UP_BOARD_UNIT_COMMENT = 'FollowUpBoardUnitComment';\n\n/* global BigInt */\n\nfunction floatOrInt(numericStr) {\n  if (Number.isInteger(numericStr)) {\n    return parseInt(numericStr, 10);\n  }\n  return parseFloat(numericStr);\n}\n\nexport function swapOrder(arr, wordSize, gSize) {\n  const swappedWords = [];\n\n  for (let i = 0; i < arr.length; i += wordSize) {\n    const word = arr.slice(i, i + wordSize);\n    for (let j = wordSize - gSize; j > -gSize; j -= gSize) {\n      swappedWords.push(word.slice(j, j + gSize));\n    }\n  }\n\n  return swappedWords.join('');\n}\n\nexport default class DBC {\n  constructor(dbcString) {\n    this.boardUnits = [];\n    this.comments = [];\n    this.messages = new Map();\n\n    if (dbcString !== undefined) {\n      this.dbcText = dbcString;\n      this.importDbcString(dbcString);\n    }\n  }\n\n  getMessageFrame(address) {\n    return this.messages.get(address);\n  }\n\n  nextNewFrameName() {\n    const messageNames = [];\n\n    for (const msg of this.messages.values()) {\n      messageNames.push(msg.name);\n    }\n\n    let msgNum = 1;\n    let msgName;\n    do {\n      msgName = `NEW_MSG_${msgNum}`;\n      msgNum++;\n    } while (messageNames.indexOf(msgName) !== -1);\n\n    return msgName;\n  }\n\n  updateBoardUnits() {\n    const boardUnitNames = this.boardUnits.map((bu) => bu.name);\n    const missingBoardUnits = Array.from(this.messages.entries())\n      .map(([msgId, frame]) => Object.values(frame.signals))\n      .reduce((arr, signals) => arr.concat(signals), [])\n      .map((signal) => signal.receiver)\n      .reduce((arr, receivers) => arr.concat(receivers), [])\n      .filter((recv, idx, array) => array.indexOf(recv) === idx)\n      .filter((recv) => boardUnitNames.indexOf(recv) === -1)\n      .map((recv) => new BoardUnit(recv));\n\n    this.boardUnits = this.boardUnits.concat(missingBoardUnits);\n  }\n\n  text() {\n    this.updateBoardUnits();\n\n    let txt = 'VERSION \"\"\\n\\n\\n';\n    txt += `NS_ :${this._newSymbols()}`;\n    txt += '\\n\\nBS_:\\n';\n\n    const boardUnitsText = this.boardUnits.map((bu) => bu.text()).join(' ');\n    txt += `\\nBU_: ${boardUnitsText}\\n\\n\\n`;\n\n    const frames = [];\n    for (const frame of this.messages.values()) {\n      frames.push(frame);\n    }\n    txt += `${frames.map((f) => f.text()).join('\\n\\n')}\\n\\n`;\n\n    const messageTxs = frames\n      .map((f) => [f.id, f.transmitters.slice(1)])\n      .filter(([addr, txs]) => txs.length > 0);\n    txt += `${messageTxs\n      .map(([addr, txs]) => `BO_TX_BU_ ${addr} : ${txs.join(',')};`)\n      .join('\\n')}\\n\\n\\n`;\n\n    txt += this.boardUnits\n      .filter((bu) => bu.comment !== null)\n      .map((bu) => `CM_ BU_ ${bu.name} \"${bu.comment}\";`)\n      .join('\\n');\n\n    txt += frames\n      .filter((f) => f.comment !== null)\n      .map((msg) => `CM_ BO_ ${msg.address} \"${msg.comment}\";`)\n      .join('\\n');\n\n    const signalsByMsgId = frames\n      .map((f) => Object.values(f.signals).map((sig) => [f.id, sig]))\n      .reduce((s1, s2) => s1.concat(s2), []);\n\n    txt += `${signalsByMsgId\n      .filter(([msgAddr, sig]) => sig.comment !== null)\n      .map(\n        ([msgAddr, sig]) => `CM_ SG_ ${msgAddr} ${sig.name} \"${sig.comment}\";`\n      )\n      .join('\\n')}\\n`;\n\n    txt += `${signalsByMsgId\n      .filter(([msgAddr, sig]) => sig.valueDescriptions.size > 0)\n      .map(([msgAddr, sig]) => sig.valueDescriptionText(msgAddr))\n      .join('\\n')}\\n`;\n\n    txt += this.comments.map((comment) => `CM_ \"${comment}\";`).join('\\n');\n\n    return `${txt.trim()}\\n`;\n  }\n\n  getMessageName(msgId) {\n    const msg = this.getMessageFrame(msgId);\n    if (msg && msg.frame) return msg.frame.name;\n    return null;\n  }\n\n  getSignals(msgId) {\n    const msg = this.getMessageFrame(msgId);\n    if (msg) return msg.signals;\n    return {};\n  }\n\n  createFrame(msgId, size=64) {\n    const msg = new Frame({\n      name: this.nextNewFrameName(),\n      id: msgId,\n      size: size,\n    });\n\n    this.messages.set(msgId, msg);\n    return msg;\n  }\n\n  setSignals(msgId, signals, frameSize) {\n    const msg = this.getMessageFrame(msgId); // TODO conform frameSize\n    if (msg) {\n      const newMsg = Object.assign(Object.create(msg), msg);\n      newMsg.signals = signals;\n      this.messages.set(msgId, newMsg);\n    } else {\n      const msg = this.createFrame(msgId, frameSize);\n      msg.signals = signals;\n\n      this.messages.set(msgId, msg);\n      this.updateBoardUnits();\n    }\n  }\n\n  addSignal(msgId, signal) {\n    const msg = this.getMessageFrame(msgId);\n\n    if (msg) {\n      msg.signals[signal.name] = signal;\n      this.updateBoardUnits();\n    }\n  }\n\n  importDbcString(dbcString) {\n    const warnings = [];\n    const messages = new Map();\n    let boardUnits = [];\n    const valueTables = new Map();\n    let id = 0;\n    let followUp = null;\n\n    const lines = dbcString.split('\\n');\n    for (let i = 0; i < lines.length; i++) {\n      let line = lines[i].trim();\n\n      if (line.length === 0) continue;\n\n      if (followUp != null) {\n        const { type, data } = followUp;\n        line = line.replace(/\" *;/, '');\n        let followUpLine = `\\n${line.substr(0, line.length)}`;\n        if (line.indexOf('\"') !== -1) {\n          followUp = null;\n          followUpLine = followUpLine.substr(0, followUpLine.length - 1);\n        }\n        if (type === FOLLOW_UP_SIGNAL_COMMENT) {\n          const signal = data;\n          signal.comment += followUpLine;\n        } else if (type === FOLLOW_UP_MSG_COMMENT) {\n          const msg = data;\n          msg.comment += followUpLine;\n        } else if (type === FOLLOW_UP_BOARD_UNIT_COMMENT) {\n          const boardUnit = data;\n          boardUnit.comment += followUpLine;\n        } else if (type === FOLLOW_UP_DBC_COMMENT) {\n          //          const comment = data;\n          const partialComment = this.comments[this.comments.length - 1];\n          this.comments[this.comments.length - 1] = partialComment + followUpLine;\n        }\n      }\n\n      if (line.indexOf('BO_ ') === 0) {\n        const matches = line.match(MSG_RE);\n        if (matches === null) {\n          warnings.push(\n            `failed to parse message definition on line ${i + 1} -- ${line}`\n          );\n          continue;\n        }\n        let [idString, name, size, transmitter] = matches.slice(1);\n        id = parseInt(idString, 0); // 0 radix parses hex or dec\n        size = parseInt(size, 10);\n        const frame = new Frame({\n          name,\n          id,\n          size,\n          transmitters: [transmitter]\n        });\n        messages.set(id, frame);\n      } else if (line.indexOf('SG_') === 0) {\n        let matches = line.match(SIGNAL_RE);\n\n        if (matches === null) {\n          matches = line.match(MP_SIGNAL_RE);\n          if (matches === null) {\n            warnings.push(\n              `failed to parse signal definition on line ${i + 1} -- ${line}`\n            );\n            continue;\n          }\n          // for now, ignore multiplex which is matches[1]\n          matches = matches[1] + matches.slice(3);\n        } else {\n          matches = matches.slice(1);\n        }\n\n        let [\n          name,\n          startBit,\n          size,\n          isLittleEndian,\n          isSigned,\n          factor,\n          offset,\n          min,\n          max,\n          unit,\n          receiverStr\n        ] = matches;\n        startBit = parseInt(startBit, 10);\n        size = parseInt(size, 10);\n        isLittleEndian = parseInt(isLittleEndian, 10) === 1;\n        isSigned = isSigned === '-';\n        factor = floatOrInt(factor);\n        offset = floatOrInt(offset);\n        min = floatOrInt(min);\n        max = floatOrInt(max);\n        const receiver = receiverStr.split(',').map((s) => s.trim());\n\n        const signalProperties = {\n          name,\n          startBit,\n          size,\n          isLittleEndian,\n          isSigned,\n          factor,\n          offset,\n          unit,\n          min,\n          max,\n          receiver\n        };\n        const signal = new Signal(signalProperties);\n\n        if (messages.get(id) !== undefined) {\n          messages.get(id).signals[name] = signal;\n        } else {\n          CloudLog.warn(\n            `importDbcString: could not add signal: ${name} due to missing message: ${id}`\n          );\n        }\n      } else if (line.indexOf('VAL_ ') === 0) {\n        const matches = line.match(VAL_RE);\n\n        if (matches !== null) {\n          let [messageId, signalName, vals] = matches.slice(1);\n          vals = vals\n            .split('\"')\n            .map((s) => s.trim())\n            .filter((s) => s.length > 0);\n\n          messageId = parseInt(messageId, 10);\n          const msg = messages.get(messageId);\n          const signal = msg.signals[signalName];\n          if (signal === undefined) {\n            warnings.push(\n              `could not find signal for value description on line ${i\n                + 1} -- ${line}`\n            );\n            continue;\n          }\n          for (let i = 0; i < vals.length; i += 2) {\n            const value = vals[i].trim();\n            const description = vals[i + 1].trim();\n            signal.valueDescriptions.set(value, description);\n          }\n        } else {\n          warnings.push(\n            `failed to parse value description on line ${i + 1} -- ${line}`\n          );\n        }\n      } else if (line.indexOf('VAL_TABLE_ ') === 0) {\n        const matches = line.match(VAL_TABLE_RE);\n\n        if (matches !== null) {\n          const table = new Map();\n          let [tableName, items] = matches.slice(1);\n          items = items\n            .split('\"')\n            .map((s) => s.trim())\n            .filter((s) => s.length > 0);\n\n          for (let i = 0; i < items.length; i += 2) {\n            const key = items[i];\n            const value = items[i + 1];\n            table.set(key, value);\n          }\n          valueTables.set(tableName, table);\n        } else {\n          warnings.push(\n            `failed to parse value table on line ${i + 1} -- ${line}`\n          );\n        }\n      } else if (line.indexOf('BO_TX_BU_ ') === 0) {\n        const matches = line.match(MSG_TRANSMITTER_RE);\n\n        if (matches !== null) {\n          let [messageId, transmitter] = matches.slice(1);\n          messageId = parseInt(messageId, 10);\n\n          const msg = messages.get(messageId);\n          msg.transmitters.push(transmitter);\n          messages.set(messageId, msg);\n        } else {\n          warnings.push(\n            `failed to parse message transmitter definition on line ${i\n              + 1} -- ${line}`\n          );\n        }\n      } else if (line.indexOf('CM_ SG_ ') === 0) {\n        let matches = line.match(SIGNAL_COMMENT_RE);\n        let hasFollowUp = false;\n        if (matches === null) {\n          matches = line.match(SIGNAL_COMMENT_MULTI_LINE_RE);\n          hasFollowUp = true;\n        }\n        if (matches === null) {\n          warnings.push(\n            `failed to parse signal comment on line ${i + 1} -- ${line}`\n          );\n          continue;\n        }\n\n        let [messageId, signalName, comment] = matches.slice(1);\n\n        messageId = parseInt(messageId, 10);\n        const msg = messages.get(messageId);\n        if (msg === undefined) {\n          warnings.push(`failed to parse signal comment on line ${i\n            + 1} -- ${line}:\n                                    message id ${messageId} does not exist prior to this line`);\n          continue;\n        }\n        const signal = msg.signals[signalName];\n        if (signal === undefined) {\n          warnings.push(\n            `failed to parse signal comment on line ${i + 1} -- ${line}`\n          );\n          continue;\n        } else {\n          signal.comment = comment;\n          messages.set(messageId, msg);\n        }\n\n        if (hasFollowUp) {\n          followUp = { type: FOLLOW_UP_SIGNAL_COMMENT, data: signal };\n        }\n      } else if (line.indexOf('CM_ BO_ ') === 0) {\n        let matches = line.match(MESSAGE_COMMENT_RE);\n        let hasFollowUp = false;\n        if (matches === null) {\n          matches = line.match(MESSAGE_COMMENT_MULTI_LINE_RE);\n          hasFollowUp = true;\n          if (matches === null) {\n            warnings.push(\n              `failed to message comment on line ${i + 1} -- ${line}`\n            );\n            continue;\n          }\n        }\n\n        let [messageId, comment] = matches.slice(1);\n        messageId = parseInt(messageId, 10);\n        const msg = messages.get(messageId);\n        if (msg === undefined) {\n          warnings.push(\n            `failed to find message to add comment to, msg id: ${messageId}`\n          );\n          continue;\n        }\n        msg.comment = comment;\n\n        if (hasFollowUp) {\n          followUp = { type: FOLLOW_UP_MSG_COMMENT, data: msg };\n        }\n      } else if (line.indexOf('BU_: ') === 0) {\n        const matches = line.match(BOARD_UNIT_RE);\n\n        if (matches !== null) {\n          const [boardUnitNameStr] = matches.slice(1);\n          const newBoardUnits = boardUnitNameStr\n            .split(' ')\n            .map((s) => s.trim())\n            .filter((s) => s.length > 0)\n            .map((name) => new BoardUnit(name));\n\n          boardUnits = boardUnits.concat(newBoardUnits);\n        } else {\n          warnings.push(\n            `failed to parse board unit definition on line ${i + 1} -- ${line}`\n          );\n          continue;\n        }\n      } else if (line.indexOf('CM_ BU_ ') === 0) {\n        let matches = line.match(BOARD_UNIT_COMMENT_RE);\n        let hasFollowUp = false;\n        if (matches === null) {\n          matches = line.match(BOARD_UNIT_COMMENT_MULTI_LINE_RE);\n          hasFollowUp = true;\n          if (matches === null) {\n            warnings.push(\n              `failed to parse board unit comment on line ${i + 1} -- ${line}`\n            );\n            continue;\n          }\n        }\n\n        const [boardUnitName, comment] = matches.slice(1);\n        const boardUnit = boardUnits.find((bu) => bu.name === boardUnitName);\n        if (boardUnit) {\n          boardUnit.comment = comment;\n        }\n\n        if (hasFollowUp) {\n          followUp = { type: FOLLOW_UP_BOARD_UNIT_COMMENT, data: boardUnit };\n        }\n      } else if (line.indexOf('CM_ ') === 0) {\n        let matches = line.match(DBC_COMMENT_RE);\n        let hasFollowUp = false;\n        if (matches === null) {\n          matches = line.match(DBC_COMMENT_MULTI_LINE_RE);\n          if (matches === null) {\n            warnings.push(\n              `failed to parse dbc comment on line ${i + 1} -- ${line}`\n            );\n            continue;\n          } else {\n            hasFollowUp = true;\n          }\n        }\n\n        const [comment] = matches.slice(1);\n        this.comments.push(comment);\n        if (hasFollowUp) {\n          followUp = { type: FOLLOW_UP_DBC_COMMENT, data: comment };\n        }\n      }\n    }\n\n    // Disabled b/c live mode frequently calls this function\n    // and executes way too many network requests\n    if (warnings.length > 0) {\n      // warnings.forEach((warning) => CloudLog.warn('importDbcString: ' + warning));\n      // warnings.forEach((warning) => console.log('importDbcString: ' + warning));\n    }\n\n    this.messages = messages;\n    this.boardUnits = boardUnits;\n    this.valueTables = valueTables;\n  }\n\n  valueForIntSignal(signalSpec, view) {\n    let sig_lsb, sig_msb;\n    if (signalSpec.isLittleEndian) {\n      sig_lsb = signalSpec.startBit;\n      sig_msb = signalSpec.startBit + signalSpec.size - 1;\n    } else {\n      sig_lsb = DbcUtils.matrixBitNumber(DbcUtils.bigEndianBitIndex(signalSpec.startBit) + signalSpec.size - 1);\n      sig_msb = signalSpec.startBit;\n    }\n\n    let ret = signalSpec.size > 32 ? 0n : 0;\n    let i = Math.floor(sig_msb / 8);\n    let bits = signalSpec.size;\n    while (i >= 0 && i < view.byteLength && bits > 0) {\n      let lsb = Math.floor(sig_lsb / 8) === i ? sig_lsb : i*8;\n      let msb = Math.floor(sig_msb / 8) === i ? sig_msb : (i+1)*8 - 1;\n      let size = msb - lsb + 1;\n\n      let d = (view.getUint8(i) >>> (lsb - (i*8))) & ((1 << size) - 1);\n      if (signalSpec.size > 32) {\n        ret |= BigInt(d) << BigInt(bits - size);\n      } else {\n        ret |= d << (bits - size);\n      }\n\n      bits -= size;\n      i = signalSpec.isLittleEndian ? i-1 : i+1;\n    }\n\n    if (signalSpec.size > 32) {\n      ret = signalSpec.isSigned ? BigInt.asIntN(64, ret) : ret;\n      if (Number.isInteger(signalSpec.factor)) {\n        return ret * BigInt(signalSpec.factor) + BigInt(signalSpec.offset);\n      } else {\n        return parseFloat(ret) * signalSpec.factor + signalSpec.offset;\n      }\n    } else {\n      if (signalSpec.isSigned) {\n        ret -= ((ret >> (signalSpec.size-1)) & 1) ? (1 << signalSpec.size) : 0;\n      }\n      return ret * signalSpec.factor + signalSpec.offset;\n    }\n  }\n\n  getSignalValues(messageId, data) {\n    if (!this.messages.has(messageId)) {\n      return {};\n    }\n    const frame = this.getMessageFrame(messageId);\n    const view = new DataView(data.buffer);\n    const signalValuesByName = {};\n    Object.values(frame.signals).forEach((signalSpec) => {\n      if (isNaN(signalSpec.startBit)) {\n        return;\n      }\n      signalValuesByName[signalSpec.name] = this.valueForIntSignal(signalSpec, view);\n    });\n\n    return signalValuesByName;\n  }\n\n  getChffrMetricMappings() {\n    const metricComment = this.comments.find(\n      (comment) => comment.indexOf('CHFFR_METRIC') === 0\n    );\n    if (!metricComment) {\n      return null;\n    }\n\n    return metricComment\n      .split(';')\n      .map((metric) => metric.trim().split(' '))\n      .reduce(\n        (metrics, [_, messageId, signalName, metricName, factor, offset]) => {\n          metrics[metricName] = {\n            messageId: parseInt(messageId, 10),\n            signalName,\n            factor: parseFloat(factor),\n            offset: parseFloat(offset)\n          };\n          return metrics;\n        },\n        {}\n      );\n  }\n\n  _newSymbols() {\n    return `\n    NS_DESC_\n    CM_\n    BA_DEF_\n    BA_\n    VAL_\n    CAT_DEF_\n    CAT_\n    FILTER\n    BA_DEF_DEF_\n    EV_DATA_\n    ENVVAR_DATA_\n    SGTYPE_\n    SGTYPE_VAL_\n    BA_DEF_SGTYPE_\n    BA_SGTYPE_\n    SIG_TYPE_REF_\n    VAL_TABLE_\n    SIG_GROUP_\n    SIG_VALTYPE_\n    SIGTYPE_VALTYPE_\n    BO_TX_BU_\n    BA_DEF_REL_\n    BA_REL_\n    BA_DEF_DEF_REL_\n    BU_SG_REL_\n    BU_EV_REL_\n    BU_BO_REL_\n    SG_MUL_VAL_`;\n  }\n}\n"]},"metadata":{},"sourceType":"module"}