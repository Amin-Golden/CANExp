{"ast":null,"code":"import ArrayUtils from '../utils/array';\nimport { CAN_GRAPH_MAX_POINTS } from '../config';\n\nfunction signalColors(signal, msg) {\n  return signal.colors.map(v => v ^ msg.address ^ msg.bus);\n}\n\nfunction _calcGraphData(msg, signalUid, firstCanTime) {\n  if (!msg) return null;\n  const signal = Object.values(msg.frame.signals).find(s => s.uid === signalUid);\n\n  if (!signal) {\n    console.warn('_calcGraphData: no signal', signalUid, msg);\n    return null;\n  }\n\n  let samples = [];\n  const skip = Math.floor(msg.entries.length / CAN_GRAPH_MAX_POINTS);\n\n  if (skip === 0) {\n    samples = msg.entries;\n  } else {\n    for (let i = 0; i < msg.entries.length; i += skip) {\n      samples.push(msg.entries[i]);\n    } // Always include last message entry, which faciliates graphData comparison\n\n\n    samples.push(msg.entries[msg.entries.length - 1]);\n  }\n\n  if (!samples.length) {\n    return [];\n  }\n\n  const colors = signal.getColors(msg.id);\n  signalUid = msg.id + signalUid; // sorting these doesn't fix the phantom lines\n\n  let lastEntry = samples[0].relTime;\n  return samples.filter(e => e.signals[signal.name] !== undefined).map(entry => {\n    if (entry.relTime < lastEntry) {\n      console.log(msg);\n      console.error('Found out of order messages');\n      debugger;\n    }\n\n    if (entry.relTime - lastEntry > 2) {\n      signalUid = Math.random().toString(36);\n    }\n\n    lastEntry = entry.relTime; // console.log(entry.relTime - lastEntry);\n\n    return {\n      x: entry.time,\n      relTime: entry.relTime,\n      y: parseFloat(entry.signals[signal.name]),\n      unit: signal.unit,\n      color: `rgba(${colors.join(',')}, 0.5)`,\n      signalName: signal.name,\n      signalUid\n    };\n  });\n}\n\nfunction appendNewGraphData(plottedSignals, graphData, messages, firstCanTime) {\n  const messagesPerPlot = plottedSignals.map(plottedMessages => plottedMessages.reduce((messages, _ref) => {\n    let {\n      messageId,\n      signalUid\n    } = _ref;\n    messages.push(messageId);\n    return messages;\n  }, []));\n  const extendedPlots = messagesPerPlot.map((plottedMessageIds, index) => ({\n    plottedMessageIds,\n    index\n  })) // preserve index so we can look up graphData\n  .filter(_ref2 => {\n    let {\n      plottedMessageIds,\n      index\n    } = _ref2;\n\n    if (index < graphData.length) {\n      let maxGraphTime = 0;\n      const {\n        series\n      } = graphData[index];\n\n      if (series.length > 0) {\n        maxGraphTime = series[graphData[index].series.length - 1].relTime;\n      }\n\n      return plottedMessageIds.some(messageId => messages[messageId].entries.length > 0 && series.length === 0 || messages[messageId].entries.some(e => e.relTime > maxGraphTime));\n    }\n\n    return false;\n  }).map(_ref3 => {\n    let {\n      plottedMessageIds,\n      index\n    } = _ref3;\n    plottedMessageIds = plottedMessageIds.reduce((arr, messageId) => {\n      if (arr.indexOf(messageId) === -1) {\n        arr.push(messageId);\n      }\n\n      return arr;\n    }, []);\n    return {\n      plottedMessageIds,\n      index\n    };\n  });\n  extendedPlots.forEach(_ref4 => {\n    let {\n      plottedMessageIds,\n      index\n    } = _ref4;\n    const signalUidsByMessageId = plottedSignals[index].reduce((obj, _ref5) => {\n      let {\n        messageId,\n        signalUid\n      } = _ref5;\n\n      if (!obj[messageId]) {\n        obj[messageId] = [];\n      }\n\n      obj[messageId].push(signalUid);\n      return obj;\n    }, {});\n    const {\n      series\n    } = graphData[index];\n    const graphDataMaxMessageTimes = plottedMessageIds.reduce((obj, messageId) => {\n      const signalUids = signalUidsByMessageId[messageId];\n      const maxIndex = ArrayUtils.findIndexRight(series, entry => signalUids.indexOf(entry.signalUid) !== -1);\n\n      if (maxIndex) {\n        obj[messageId] = series[maxIndex].relTime;\n      } else if (series.length > 0) {\n        obj[messageId] = series[series.length - 1].relTime;\n      } else {\n        // Graph data is empty\n        obj[messageId] = -1;\n      }\n\n      return obj;\n    }, {});\n    let newGraphData = [];\n    plottedMessageIds.map(messageId => ({\n      messageId,\n      entries: messages[messageId].entries\n    })).filter((_ref6 // Filter to only messages with stale graphData\n    ) => {\n      let {\n        messageId,\n        entries\n      } = _ref6;\n      return entries[entries.length - 1].relTime > graphDataMaxMessageTimes[messageId];\n    }).forEach(_ref7 => {\n      let {\n        messageId,\n        entries\n      } = _ref7;\n      // Compute and append new graphData\n      const firstNewEntryIdx = entries.findIndex(entry => entry.relTime > graphDataMaxMessageTimes[messageId]);\n      const newEntries = entries.slice(firstNewEntryIdx);\n      signalUidsByMessageId[messageId].forEach(signalUid => {\n        const signalGraphData = _calcGraphData({ ...messages[messageId],\n          entries: newEntries\n        }, signalUid, firstCanTime);\n\n        newGraphData = newGraphData.concat(signalGraphData);\n      });\n    });\n    const messageIdOutOfBounds = series.length > 0 && plottedMessageIds.find(messageId => messages[messageId].entries.length > 0 && series[0].relTime < messages[messageId].entries[0].relTime);\n    graphData[index] = {\n      series: graphData[index].series.concat(newGraphData),\n      updated: Date.now()\n    };\n\n    if (messageIdOutOfBounds) {\n      const graphDataLowerBound = graphData[index].series.findIndex(e => e.relTime > messages[messageIdOutOfBounds].entries[0].relTime);\n\n      if (graphDataLowerBound) {\n        graphData[index].series = graphData[index].series.slice(graphDataLowerBound);\n      }\n    }\n  });\n  return [...graphData];\n}\n\nexport default {\n  _calcGraphData,\n  appendNewGraphData,\n  signalColors\n};","map":{"version":3,"sources":["/home/amax/Autoro/cabana/src/models/graph-data.js"],"names":["ArrayUtils","CAN_GRAPH_MAX_POINTS","signalColors","signal","msg","colors","map","v","address","bus","_calcGraphData","signalUid","firstCanTime","Object","values","frame","signals","find","s","uid","console","warn","samples","skip","Math","floor","entries","length","i","push","getColors","id","lastEntry","relTime","filter","e","name","undefined","entry","log","error","random","toString","x","time","y","parseFloat","unit","color","join","signalName","appendNewGraphData","plottedSignals","graphData","messages","messagesPerPlot","plottedMessages","reduce","messageId","extendedPlots","plottedMessageIds","index","maxGraphTime","series","some","arr","indexOf","forEach","signalUidsByMessageId","obj","graphDataMaxMessageTimes","signalUids","maxIndex","findIndexRight","newGraphData","firstNewEntryIdx","findIndex","newEntries","slice","signalGraphData","concat","messageIdOutOfBounds","updated","Date","now","graphDataLowerBound"],"mappings":"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","sourcesContent":["import ArrayUtils from '../utils/array';\nimport { CAN_GRAPH_MAX_POINTS } from '../config';\n\nfunction signalColors(signal, msg) {\n  return signal.colors.map((v) => (v ^ msg.address) ^ msg.bus);\n}\n\nfunction _calcGraphData(msg, signalUid, firstCanTime) {\n  if (!msg) return null;\n\n  const signal = Object.values(msg.frame.signals).find(\n    (s) => s.uid === signalUid\n  );\n  if (!signal) {\n    console.warn('_calcGraphData: no signal', signalUid, msg);\n    return null;\n  }\n  let samples = [];\n  const skip = Math.floor(msg.entries.length / CAN_GRAPH_MAX_POINTS);\n\n  if (skip === 0) {\n    samples = msg.entries;\n  } else {\n    for (let i = 0; i < msg.entries.length; i += skip) {\n      samples.push(msg.entries[i]);\n    }\n    // Always include last message entry, which faciliates graphData comparison\n    samples.push(msg.entries[msg.entries.length - 1]);\n  }\n  if (!samples.length) {\n    return [];\n  }\n\n  const colors = signal.getColors(msg.id);\n  signalUid = msg.id + signalUid;\n  // sorting these doesn't fix the phantom lines\n  let lastEntry = samples[0].relTime;\n  return samples\n    .filter((e) => e.signals[signal.name] !== undefined)\n    .map((entry) => {\n      if (entry.relTime < lastEntry) {\n        console.log(msg);\n        console.error('Found out of order messages');\n        debugger;\n      }\n      if (entry.relTime - lastEntry > 2) {\n        signalUid = Math.random().toString(36);\n      }\n      lastEntry = entry.relTime;\n      // console.log(entry.relTime - lastEntry);\n      return {\n        x: entry.time,\n        relTime: entry.relTime,\n        y: parseFloat(entry.signals[signal.name]),\n        unit: signal.unit,\n        color: `rgba(${colors.join(',')}, 0.5)`,\n        signalName: signal.name,\n        signalUid\n      };\n    });\n}\n\nfunction appendNewGraphData(plottedSignals, graphData, messages, firstCanTime) {\n  const messagesPerPlot = plottedSignals.map((plottedMessages) => plottedMessages.reduce((messages, { messageId, signalUid }) => {\n    messages.push(messageId);\n    return messages;\n  }, []));\n\n  const extendedPlots = messagesPerPlot\n    .map((plottedMessageIds, index) => ({ plottedMessageIds, index })) // preserve index so we can look up graphData\n    .filter(({ plottedMessageIds, index }) => {\n      if (index < graphData.length) {\n        let maxGraphTime = 0;\n        const { series } = graphData[index];\n        if (series.length > 0) {\n          maxGraphTime = series[graphData[index].series.length - 1].relTime;\n        }\n\n        return plottedMessageIds.some(\n          (messageId) => (messages[messageId].entries.length > 0 && series.length === 0)\n            || messages[messageId].entries.some((e) => e.relTime > maxGraphTime)\n        );\n      }\n      return false;\n    })\n    .map(({ plottedMessageIds, index }) => {\n      plottedMessageIds = plottedMessageIds.reduce((arr, messageId) => {\n        if (arr.indexOf(messageId) === -1) {\n          arr.push(messageId);\n        }\n        return arr;\n      }, []);\n      return { plottedMessageIds, index };\n    });\n\n  extendedPlots.forEach(({ plottedMessageIds, index }) => {\n    const signalUidsByMessageId = plottedSignals[index].reduce(\n      (obj, { messageId, signalUid }) => {\n        if (!obj[messageId]) {\n          obj[messageId] = [];\n        }\n        obj[messageId].push(signalUid);\n        return obj;\n      },\n      {}\n    );\n    const { series } = graphData[index];\n    const graphDataMaxMessageTimes = plottedMessageIds.reduce(\n      (obj, messageId) => {\n        const signalUids = signalUidsByMessageId[messageId];\n        const maxIndex = ArrayUtils.findIndexRight(\n          series,\n          (entry) => signalUids.indexOf(entry.signalUid) !== -1\n        );\n        if (maxIndex) {\n          obj[messageId] = series[maxIndex].relTime;\n        } else if (series.length > 0) {\n          obj[messageId] = series[series.length - 1].relTime;\n        } else {\n          // Graph data is empty\n          obj[messageId] = -1;\n        }\n\n        return obj;\n      },\n      {}\n    );\n\n    let newGraphData = [];\n    plottedMessageIds\n      .map((messageId) => ({ messageId, entries: messages[messageId].entries }))\n      .filter(\n        (\n          { messageId, entries } // Filter to only messages with stale graphData\n        ) => entries[entries.length - 1].relTime\n          > graphDataMaxMessageTimes[messageId]\n      )\n      .forEach(({ messageId, entries }) => {\n        // Compute and append new graphData\n        const firstNewEntryIdx = entries.findIndex(\n          (entry) => entry.relTime > graphDataMaxMessageTimes[messageId]\n        );\n\n        const newEntries = entries.slice(firstNewEntryIdx);\n        signalUidsByMessageId[messageId].forEach((signalUid) => {\n          const signalGraphData = _calcGraphData(\n            {\n              ...messages[messageId],\n              entries: newEntries\n            },\n            signalUid,\n            firstCanTime\n          );\n\n          newGraphData = newGraphData.concat(signalGraphData);\n        });\n      });\n\n    const messageIdOutOfBounds = series.length > 0\n      && plottedMessageIds.find(\n        (messageId) => messages[messageId].entries.length > 0\n          && series[0].relTime < messages[messageId].entries[0].relTime\n      );\n    graphData[index] = {\n      series: graphData[index].series.concat(newGraphData),\n      updated: Date.now()\n    };\n\n    if (messageIdOutOfBounds) {\n      const graphDataLowerBound = graphData[index].series.findIndex(\n        (e) => e.relTime > messages[messageIdOutOfBounds].entries[0].relTime\n      );\n\n      if (graphDataLowerBound) {\n        graphData[index].series = graphData[index].series.slice(\n          graphDataLowerBound\n        );\n      }\n    }\n  });\n\n  return [...graphData];\n}\n\nexport default { _calcGraphData, appendNewGraphData, signalColors };\n"]},"metadata":{},"sourceType":"module"}