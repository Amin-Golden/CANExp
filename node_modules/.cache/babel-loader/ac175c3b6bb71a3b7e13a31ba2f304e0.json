{"ast":null,"code":"'use strict';\n/* @flow */\n\n/**\n * Our default sum is the [Kahan-Babuska algorithm](https://pdfs.semanticscholar.org/1760/7d467cda1d0277ad272deb2113533131dc09.pdf).\n * This method is an improvement over the classical\n * [Kahan summation algorithm](https://en.wikipedia.org/wiki/Kahan_summation_algorithm).\n * It aims at computing the sum of a list of numbers while correcting for\n * floating-point errors. Traditionally, sums are calculated as many\n * successive additions, each one with its own floating-point roundoff. These\n * losses in precision add up as the number of numbers increases. This alternative\n * algorithm is more accurate than the simple way of calculating sums by simple\n * addition.\n *\n * This runs on `O(n)`, linear time in respect to the array.\n *\n * @param {Array<number>} x input\n * @return {number} sum of all input numbers\n * @example\n * sum([1, 2, 3]); // => 6\n */\n\nfunction sum(x\n/*: Array<number> */\n)\n/*: number */\n{\n  // If the array is empty, we needn't bother computing its sum\n  if (x.length === 0) {\n    return 0;\n  } // Initializing the sum as the first number in the array\n\n\n  var sum = x[0]; // Keeping track of the floating-point error correction\n\n  var correction = 0;\n  var transition;\n\n  for (var i = 1; i < x.length; i++) {\n    transition = sum + x[i]; // Here we need to update the correction in a different fashion\n    // if the new absolute value is greater than the absolute sum\n\n    if (Math.abs(sum) >= Math.abs(x[i])) {\n      correction += sum - transition + x[i];\n    } else {\n      correction += x[i] - transition + sum;\n    }\n\n    sum = transition;\n  } // Returning the corrected sum\n\n\n  return sum + correction;\n}\n\nmodule.exports = sum;","map":{"version":3,"sources":["/home/amax/Autoro/cabana/node_modules/simple-statistics/src/sum.js"],"names":["sum","x","length","correction","transition","i","Math","abs","module","exports"],"mappings":"AAAA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,SAASA,GAAT,CAAaC;AAAC;AAAd;AAAmC;AAAc;AAE7C;AACA,MAAIA,CAAC,CAACC,MAAF,KAAa,CAAjB,EAAoB;AAChB,WAAO,CAAP;AACH,GAL4C,CAO7C;;;AACA,MAAIF,GAAG,GAAGC,CAAC,CAAC,CAAD,CAAX,CAR6C,CAU7C;;AACA,MAAIE,UAAU,GAAG,CAAjB;AAEA,MAAIC,UAAJ;;AAEA,OAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGJ,CAAC,CAACC,MAAtB,EAA8BG,CAAC,EAA/B,EAAmC;AAC/BD,IAAAA,UAAU,GAAGJ,GAAG,GAAGC,CAAC,CAACI,CAAD,CAApB,CAD+B,CAG/B;AACA;;AACA,QAAIC,IAAI,CAACC,GAAL,CAASP,GAAT,KAAiBM,IAAI,CAACC,GAAL,CAASN,CAAC,CAACI,CAAD,CAAV,CAArB,EAAqC;AACjCF,MAAAA,UAAU,IAAMH,GAAG,GAAGI,UAAP,GAAqBH,CAAC,CAACI,CAAD,CAArC;AACH,KAFD,MAGK;AACDF,MAAAA,UAAU,IAAMF,CAAC,CAACI,CAAD,CAAD,GAAOD,UAAR,GAAsBJ,GAArC;AACH;;AAEDA,IAAAA,GAAG,GAAGI,UAAN;AACH,GA5B4C,CA8B7C;;;AACA,SAAOJ,GAAG,GAAGG,UAAb;AACH;;AAEDK,MAAM,CAACC,OAAP,GAAiBT,GAAjB","sourcesContent":["'use strict';\n/* @flow */\n\n/**\n * Our default sum is the [Kahan-Babuska algorithm](https://pdfs.semanticscholar.org/1760/7d467cda1d0277ad272deb2113533131dc09.pdf).\n * This method is an improvement over the classical\n * [Kahan summation algorithm](https://en.wikipedia.org/wiki/Kahan_summation_algorithm).\n * It aims at computing the sum of a list of numbers while correcting for\n * floating-point errors. Traditionally, sums are calculated as many\n * successive additions, each one with its own floating-point roundoff. These\n * losses in precision add up as the number of numbers increases. This alternative\n * algorithm is more accurate than the simple way of calculating sums by simple\n * addition.\n *\n * This runs on `O(n)`, linear time in respect to the array.\n *\n * @param {Array<number>} x input\n * @return {number} sum of all input numbers\n * @example\n * sum([1, 2, 3]); // => 6\n */\nfunction sum(x/*: Array<number> */)/*: number */ {\n\n    // If the array is empty, we needn't bother computing its sum\n    if (x.length === 0) {\n        return 0;\n    }\n\n    // Initializing the sum as the first number in the array\n    var sum = x[0];\n\n    // Keeping track of the floating-point error correction\n    var correction = 0;\n\n    var transition;\n\n    for (var i = 1; i < x.length; i++) {\n        transition = sum + x[i];\n\n        // Here we need to update the correction in a different fashion\n        // if the new absolute value is greater than the absolute sum\n        if (Math.abs(sum) >= Math.abs(x[i])) {\n            correction += ((sum - transition) + x[i]);\n        }\n        else {\n            correction += ((x[i] - transition) + sum);\n        }\n\n        sum = transition;\n    }\n\n    // Returning the corrected sum\n    return sum + correction;\n}\n\nmodule.exports = sum;\n"]},"metadata":{},"sourceType":"script"}