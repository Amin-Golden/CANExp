{"ast":null,"code":"\"use strict\";\n/**\n * @author jdiaz5513\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n}); // LINT: a lot of the util functions need the any type.\n\n/* tslint:disable:no-any no-unsafe-any */\n\nvar debug_1 = require(\"debug\");\n\nvar constants_1 = require(\"./constants\");\n\nvar errors_1 = require(\"./errors\");\n\nvar trace = debug_1.default('capnp:util');\ntrace('load');\n/**\n * Dump a hex string from the given buffer.\n *\n * @export\n * @param {ArrayBuffer} buffer The buffer to convert.\n * @returns {string} A hexadecimal string representing the buffer.\n */\n\nfunction bufferToHex(buffer) {\n  var a = new Uint8Array(buffer);\n  var h = [];\n\n  for (var i = 0; i < a.byteLength; i++) h.push(pad(a[i].toString(16), 2));\n\n  return \"[\" + h.join(' ') + \"]\";\n}\n\nexports.bufferToHex = bufferToHex;\n/**\n * Throw an error if the provided value cannot be represented as a 32-bit integer.\n *\n * @export\n * @param {number} value The number to check.\n * @returns {number} The same number if it is valid.\n */\n\nfunction checkInt32(value) {\n  if (value > constants_1.MAX_INT32 || value < -constants_1.MAX_INT32) throw new RangeError(errors_1.RANGE_INT32_OVERFLOW);\n  return value;\n}\n\nexports.checkInt32 = checkInt32;\n\nfunction checkUint32(value) {\n  if (value < 0 || value > constants_1.MAX_UINT32) throw new RangeError(errors_1.RANGE_UINT32_OVERFLOW);\n  return value;\n}\n\nexports.checkUint32 = checkUint32;\n/**\n * Decode a UTF-8 encoded byte array into a JavaScript string (UCS-2).\n *\n * @export\n * @param {Uint8Array} src A utf-8 encoded byte array.\n * @returns {string} A string representation of the byte array.\n */\n\nfunction decodeUtf8(src) {\n  // This ain't for the faint of heart, kids. If you suffer from seizures, heart palpitations, or have had a history of\n  // stroke you may want to look away now.\n  var l = src.byteLength;\n  var dst = '';\n  var i = 0;\n  var cp = 0;\n  var a = 0;\n  var b = 0;\n  var c = 0;\n  var d = 0;\n\n  while (i < l) {\n    a = src[i++];\n\n    if ((a & 128) === 0) {\n      cp = a;\n    } else if ((a & 224) === 192) {\n      if (i >= l) throw new RangeError(errors_1.RANGE_INVALID_UTF8);\n      b = src[i++];\n      cp = (a & 31) << 6 | b & 63;\n    } else if ((a & 240) === 224) {\n      if (i + 1 >= l) throw new RangeError(errors_1.RANGE_INVALID_UTF8);\n      b = src[i++];\n      c = src[i++];\n      cp = (a & 15) << 12 | (b & 63) << 6 | c & 63;\n    } else if ((a & 248) === 240) {\n      if (i + 2 >= l) throw new RangeError(errors_1.RANGE_INVALID_UTF8);\n      b = src[i++];\n      c = src[i++];\n      d = src[i++];\n      cp = (a & 7) << 18 | (b & 63) << 12 | (c & 63) << 6 | d & 63;\n    } else {\n      throw new RangeError(errors_1.RANGE_INVALID_UTF8);\n    }\n\n    if (cp <= 0xd7ff || cp >= 0xe000 && cp <= 0xffff) {\n      dst += String.fromCharCode(cp);\n    } else {\n      // We must reach into the astral plane and construct the surrogate pair!\n      cp -= 0x00010000;\n      var hi = (cp >>> 10) + 0xd800;\n      var lo = (cp & 0x03ff) + 0xdc00;\n      if (hi < 0xd800 || hi > 0xdbff) throw new RangeError(errors_1.RANGE_INVALID_UTF8);\n      dst += String.fromCharCode(hi, lo);\n    }\n  }\n\n  return dst;\n}\n\nexports.decodeUtf8 = decodeUtf8;\n\nfunction dumpBuffer(buffer) {\n  var b = buffer instanceof ArrayBuffer ? new Uint8Array(buffer) : new Uint8Array(buffer.buffer, buffer.byteOffset, buffer.byteLength);\n  var byteLength = Math.min(b.byteLength, constants_1.MAX_BUFFER_DUMP_BYTES);\n  var r = format('\\n=== buffer[%d] ===', byteLength);\n\n  for (var j = 0; j < byteLength; j += 16) {\n    r += \"\\n\" + pad(j.toString(16), 8) + \": \";\n    var s = '';\n    var k = void 0;\n\n    for (k = 0; k < 16 && j + k < b.byteLength; k++) {\n      var v = b[j + k];\n      r += pad(v.toString(16), 2) + \" \"; // Printable ASCII range.\n\n      s += v > 31 && v < 255 ? String.fromCharCode(v) : 'Â·';\n      if (k === 7) r += ' ';\n    }\n\n    r += \"\" + repeat((17 - k) * 3, ' ') + s;\n  }\n\n  r += '\\n';\n\n  if (byteLength !== b.byteLength) {\n    r += format('=== (truncated %d bytes) ===\\n', b.byteLength - byteLength);\n  }\n\n  return r;\n}\n\nexports.dumpBuffer = dumpBuffer;\n/**\n * Encode a JavaScript string (UCS-2) to a UTF-8 encoded string inside a Uint8Array.\n *\n * Note that the underlying buffer for the array will likely be larger than the actual contents; ignore the extra bytes.\n *\n * @export\n * @param {string} src The input string.\n * @returns {Uint8Array} A UTF-8 encoded buffer with the string's contents.\n */\n\nfunction encodeUtf8(src) {\n  var l = src.length;\n  var dst = new Uint8Array(new ArrayBuffer(l * 4));\n  var j = 0;\n\n  for (var i = 0; i < l; i++) {\n    var c = src.charCodeAt(i);\n\n    if (c <= 0x7f) {\n      dst[j++] = c;\n    } else if (c <= 0x07ff) {\n      dst[j++] = 192 | c >>> 6;\n      dst[j++] = 128 | c >>> 0 & 63;\n    } else if (c <= 0xd7ff || c >= 0xe000) {\n      dst[j++] = 224 | c >>> 12;\n      dst[j++] = 128 | c >>> 6 & 63;\n      dst[j++] = 128 | c >>> 0 & 63;\n    } else {\n      // Make sure the surrogate pair is complete.\n\n      /* istanbul ignore next */\n      if (i + 1 >= l) throw new RangeError(errors_1.RANGE_INVALID_UTF8); // I cast thee back into the astral plane.\n\n      var hi = c - 0xd800;\n      var lo = src.charCodeAt(++i) - 0xdc00;\n      var cp = (hi << 10 | lo) + 0x00010000;\n      dst[j++] = 240 | cp >>> 18;\n      dst[j++] = 128 | cp >>> 12 & 63;\n      dst[j++] = 128 | cp >>> 6 & 63;\n      dst[j++] = 128 | cp >>> 0 & 63;\n    }\n  }\n\n  return dst.subarray(0, j);\n}\n\nexports.encodeUtf8 = encodeUtf8;\n/**\n * Produce a `printf`-style string. Nice for providing arguments to `assert` without paying the cost for string\n * concatenation up front. Precision is supported for floating point numbers.\n *\n * @param {string} s The format string. Supported format specifiers: b, c, d, f, j, o, s, x, and X.\n * @param {...any} args Values to be formatted in the string. Arguments beyond what are consumed by the format string\n * are ignored.\n * @returns {string} The formatted string.\n */\n\nfunction format(s) {\n  var args = [];\n\n  for (var _i = 1; _i < arguments.length; _i++) {\n    args[_i - 1] = arguments[_i];\n  }\n\n  var n = s.length;\n  var arg;\n  var argIndex = 0;\n  var c;\n  var escaped = false;\n  var i = 0;\n  var leadingZero = false;\n  var precision;\n  var result = '';\n\n  function nextArg() {\n    return args[argIndex++];\n  }\n\n  function slurpNumber() {\n    var digits = '';\n\n    while (/\\d/.test(s[i])) {\n      digits += s[i++];\n      c = s[i];\n    }\n\n    return digits.length > 0 ? parseInt(digits, 10) : null;\n  }\n\n  for (; i < n; ++i) {\n    c = s[i];\n\n    if (escaped) {\n      escaped = false;\n\n      if (c === '.') {\n        leadingZero = false;\n        c = s[++i];\n      } else if (c === '0' && s[i + 1] === '.') {\n        leadingZero = true;\n        i += 2;\n        c = s[i];\n      } else {\n        leadingZero = true;\n      }\n\n      precision = slurpNumber();\n\n      switch (c) {\n        case 'a':\n          // number in hex with padding\n          result += '0x' + pad(parseInt(nextArg(), 10).toString(16), 8);\n          break;\n\n        case 'b':\n          // number in binary\n          result += parseInt(nextArg(), 10).toString(2);\n          break;\n\n        case 'c':\n          // character\n          arg = nextArg();\n\n          if (typeof arg === 'string' || arg instanceof String) {\n            result += arg;\n          } else {\n            result += String.fromCharCode(parseInt(arg, 10));\n          }\n\n          break;\n\n        case 'd':\n          // number in decimal\n          result += parseInt(nextArg(), 10);\n          break;\n\n        case 'f':\n          // floating point number\n          var tmp = String(parseFloat(nextArg()).toFixed(precision || 6));\n          result += leadingZero ? tmp : tmp.replace(/^0/, '');\n          break;\n\n        case 'j':\n          // JSON\n          result += JSON.stringify(nextArg());\n          break;\n\n        case 'o':\n          // number in octal\n          result += '0' + parseInt(nextArg(), 10).toString(8);\n          break;\n\n        case 's':\n          // string\n          result += nextArg();\n          break;\n\n        case 'x':\n          // lowercase hexadecimal\n          result += '0x' + parseInt(nextArg(), 10).toString(16);\n          break;\n\n        case 'X':\n          // uppercase hexadecimal\n          result += '0x' + parseInt(nextArg(), 10).toString(16).toUpperCase();\n          break;\n\n        default:\n          result += c;\n          break;\n      }\n    } else if (c === '%') {\n      escaped = true;\n    } else {\n      result += c;\n    }\n  }\n\n  return result;\n}\n\nexports.format = format;\n/**\n * Return the thing that was passed in. Yaaaaawn.\n *\n * @export\n * @template T\n * @param {T} x A thing.\n * @returns {T} The same thing.\n */\n\nfunction identity(x) {\n  return x;\n}\n\nexports.identity = identity;\n\nfunction pad(v, width, pad) {\n  if (pad === void 0) {\n    pad = '0';\n  }\n\n  return v.length >= width ? v : new Array(width - v.length + 1).join(pad) + v;\n}\n\nexports.pad = pad;\n/**\n * Add padding to a number to make it divisible by 8. Typically used to pad byte sizes so they align to a word boundary.\n *\n * @export\n * @param {number} size The number to pad.\n * @returns {number} The padded number.\n */\n\nfunction padToWord(size) {\n  return size + 7 & ~7;\n}\n\nexports.padToWord = padToWord;\n/**\n * Repeat a string n times. Shamelessly copied from lodash.repeat.\n *\n * @param {number} times Number of times to repeat.\n * @param {string} str The string to repeat.\n * @returns {string} The repeated string.\n */\n\nfunction repeat(times, str) {\n  var out = '';\n  var n = times;\n  var s = str;\n  if (n < 1 || n > Number.MAX_VALUE) return out; // https://en.wikipedia.org/wiki/Exponentiation_by_squaring\n\n  do {\n    if (n % 2) out += s;\n    n = Math.floor(n / 2);\n    if (n) s += s;\n  } while (n);\n\n  return out;\n}\n\nexports.repeat = repeat; // Set up custom debug formatters.\n\n/* tslint:disable:no-string-literal */\n\n/* istanbul ignore next */\n\ndebug_1.default.formatters['h'] = function (v) {\n  return v.toString('hex');\n};\n/* istanbul ignore next */\n\n\ndebug_1.default.formatters['x'] = function (v) {\n  return \"0x\" + v.toString(16);\n};\n/* istanbul ignore next */\n\n\ndebug_1.default.formatters['a'] = function (v) {\n  return \"0x\" + pad(v.toString(16), 8);\n};\n/* istanbul ignore next */\n\n\ndebug_1.default.formatters['X'] = function (v) {\n  return \"0x\" + v.toString(16).toUpperCase();\n};\n/* tslint:enable:no-string-literal */","map":{"version":3,"sources":["util.ts"],"names":[],"mappings":"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","sourceRoot":"../src","sourcesContent":["\"use strict\";\n/**\n * @author jdiaz5513\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\n// LINT: a lot of the util functions need the any type.\n/* tslint:disable:no-any no-unsafe-any */\nvar debug_1 = require(\"debug\");\nvar constants_1 = require(\"./constants\");\nvar errors_1 = require(\"./errors\");\nvar trace = debug_1.default('capnp:util');\ntrace('load');\n/**\n * Dump a hex string from the given buffer.\n *\n * @export\n * @param {ArrayBuffer} buffer The buffer to convert.\n * @returns {string} A hexadecimal string representing the buffer.\n */\nfunction bufferToHex(buffer) {\n    var a = new Uint8Array(buffer);\n    var h = [];\n    for (var i = 0; i < a.byteLength; i++)\n        h.push(pad(a[i].toString(16), 2));\n    return \"[\" + h.join(' ') + \"]\";\n}\nexports.bufferToHex = bufferToHex;\n/**\n * Throw an error if the provided value cannot be represented as a 32-bit integer.\n *\n * @export\n * @param {number} value The number to check.\n * @returns {number} The same number if it is valid.\n */\nfunction checkInt32(value) {\n    if (value > constants_1.MAX_INT32 || value < -constants_1.MAX_INT32)\n        throw new RangeError(errors_1.RANGE_INT32_OVERFLOW);\n    return value;\n}\nexports.checkInt32 = checkInt32;\nfunction checkUint32(value) {\n    if (value < 0 || value > constants_1.MAX_UINT32)\n        throw new RangeError(errors_1.RANGE_UINT32_OVERFLOW);\n    return value;\n}\nexports.checkUint32 = checkUint32;\n/**\n * Decode a UTF-8 encoded byte array into a JavaScript string (UCS-2).\n *\n * @export\n * @param {Uint8Array} src A utf-8 encoded byte array.\n * @returns {string} A string representation of the byte array.\n */\nfunction decodeUtf8(src) {\n    // This ain't for the faint of heart, kids. If you suffer from seizures, heart palpitations, or have had a history of\n    // stroke you may want to look away now.\n    var l = src.byteLength;\n    var dst = '';\n    var i = 0;\n    var cp = 0;\n    var a = 0;\n    var b = 0;\n    var c = 0;\n    var d = 0;\n    while (i < l) {\n        a = src[i++];\n        if ((a & 128) === 0) {\n            cp = a;\n        }\n        else if ((a & 224) === 192) {\n            if (i >= l)\n                throw new RangeError(errors_1.RANGE_INVALID_UTF8);\n            b = src[i++];\n            cp = ((a & 31) << 6) | (b & 63);\n        }\n        else if ((a & 240) === 224) {\n            if (i + 1 >= l)\n                throw new RangeError(errors_1.RANGE_INVALID_UTF8);\n            b = src[i++];\n            c = src[i++];\n            cp = ((a & 15) << 12) | ((b & 63) << 6) | (c & 63);\n        }\n        else if ((a & 248) === 240) {\n            if (i + 2 >= l)\n                throw new RangeError(errors_1.RANGE_INVALID_UTF8);\n            b = src[i++];\n            c = src[i++];\n            d = src[i++];\n            cp = ((a & 7) << 18) | ((b & 63) << 12) | ((c & 63) << 6) | (d & 63);\n        }\n        else {\n            throw new RangeError(errors_1.RANGE_INVALID_UTF8);\n        }\n        if (cp <= 0xd7ff || (cp >= 0xe000 && cp <= 0xffff)) {\n            dst += String.fromCharCode(cp);\n        }\n        else {\n            // We must reach into the astral plane and construct the surrogate pair!\n            cp -= 0x00010000;\n            var hi = (cp >>> 10) + 0xd800;\n            var lo = (cp & 0x03ff) + 0xdc00;\n            if (hi < 0xd800 || hi > 0xdbff)\n                throw new RangeError(errors_1.RANGE_INVALID_UTF8);\n            dst += String.fromCharCode(hi, lo);\n        }\n    }\n    return dst;\n}\nexports.decodeUtf8 = decodeUtf8;\nfunction dumpBuffer(buffer) {\n    var b = buffer instanceof ArrayBuffer\n        ? new Uint8Array(buffer)\n        : new Uint8Array(buffer.buffer, buffer.byteOffset, buffer.byteLength);\n    var byteLength = Math.min(b.byteLength, constants_1.MAX_BUFFER_DUMP_BYTES);\n    var r = format('\\n=== buffer[%d] ===', byteLength);\n    for (var j = 0; j < byteLength; j += 16) {\n        r += \"\\n\" + pad(j.toString(16), 8) + \": \";\n        var s = '';\n        var k = void 0;\n        for (k = 0; k < 16 && j + k < b.byteLength; k++) {\n            var v = b[j + k];\n            r += pad(v.toString(16), 2) + \" \";\n            // Printable ASCII range.\n            s += v > 31 && v < 255 ? String.fromCharCode(v) : 'Â·';\n            if (k === 7)\n                r += ' ';\n        }\n        r += \"\" + repeat((17 - k) * 3, ' ') + s;\n    }\n    r += '\\n';\n    if (byteLength !== b.byteLength) {\n        r += format('=== (truncated %d bytes) ===\\n', b.byteLength - byteLength);\n    }\n    return r;\n}\nexports.dumpBuffer = dumpBuffer;\n/**\n * Encode a JavaScript string (UCS-2) to a UTF-8 encoded string inside a Uint8Array.\n *\n * Note that the underlying buffer for the array will likely be larger than the actual contents; ignore the extra bytes.\n *\n * @export\n * @param {string} src The input string.\n * @returns {Uint8Array} A UTF-8 encoded buffer with the string's contents.\n */\nfunction encodeUtf8(src) {\n    var l = src.length;\n    var dst = new Uint8Array(new ArrayBuffer(l * 4));\n    var j = 0;\n    for (var i = 0; i < l; i++) {\n        var c = src.charCodeAt(i);\n        if (c <= 0x7f) {\n            dst[j++] = c;\n        }\n        else if (c <= 0x07ff) {\n            dst[j++] = 192 | (c >>> 6);\n            dst[j++] = 128 | ((c >>> 0) & 63);\n        }\n        else if (c <= 0xd7ff || c >= 0xe000) {\n            dst[j++] = 224 | (c >>> 12);\n            dst[j++] = 128 | ((c >>> 6) & 63);\n            dst[j++] = 128 | ((c >>> 0) & 63);\n        }\n        else {\n            // Make sure the surrogate pair is complete.\n            /* istanbul ignore next */\n            if (i + 1 >= l)\n                throw new RangeError(errors_1.RANGE_INVALID_UTF8);\n            // I cast thee back into the astral plane.\n            var hi = c - 0xd800;\n            var lo = src.charCodeAt(++i) - 0xdc00;\n            var cp = ((hi << 10) | lo) + 0x00010000;\n            dst[j++] = 240 | (cp >>> 18);\n            dst[j++] = 128 | ((cp >>> 12) & 63);\n            dst[j++] = 128 | ((cp >>> 6) & 63);\n            dst[j++] = 128 | ((cp >>> 0) & 63);\n        }\n    }\n    return dst.subarray(0, j);\n}\nexports.encodeUtf8 = encodeUtf8;\n/**\n * Produce a `printf`-style string. Nice for providing arguments to `assert` without paying the cost for string\n * concatenation up front. Precision is supported for floating point numbers.\n *\n * @param {string} s The format string. Supported format specifiers: b, c, d, f, j, o, s, x, and X.\n * @param {...any} args Values to be formatted in the string. Arguments beyond what are consumed by the format string\n * are ignored.\n * @returns {string} The formatted string.\n */\nfunction format(s) {\n    var args = [];\n    for (var _i = 1; _i < arguments.length; _i++) {\n        args[_i - 1] = arguments[_i];\n    }\n    var n = s.length;\n    var arg;\n    var argIndex = 0;\n    var c;\n    var escaped = false;\n    var i = 0;\n    var leadingZero = false;\n    var precision;\n    var result = '';\n    function nextArg() {\n        return args[argIndex++];\n    }\n    function slurpNumber() {\n        var digits = '';\n        while (/\\d/.test(s[i])) {\n            digits += s[i++];\n            c = s[i];\n        }\n        return digits.length > 0 ? parseInt(digits, 10) : null;\n    }\n    for (; i < n; ++i) {\n        c = s[i];\n        if (escaped) {\n            escaped = false;\n            if (c === '.') {\n                leadingZero = false;\n                c = s[++i];\n            }\n            else if (c === '0' && s[i + 1] === '.') {\n                leadingZero = true;\n                i += 2;\n                c = s[i];\n            }\n            else {\n                leadingZero = true;\n            }\n            precision = slurpNumber();\n            switch (c) {\n                case 'a':// number in hex with padding\n                    result += '0x' + pad(parseInt(nextArg(), 10).toString(16), 8);\n                    break;\n                case 'b':// number in binary\n                    result += parseInt(nextArg(), 10).toString(2);\n                    break;\n                case 'c':// character\n                    arg = nextArg();\n                    if (typeof arg === 'string' || arg instanceof String) {\n                        result += arg;\n                    }\n                    else {\n                        result += String.fromCharCode(parseInt(arg, 10));\n                    }\n                    break;\n                case 'd':// number in decimal\n                    result += parseInt(nextArg(), 10);\n                    break;\n                case 'f':// floating point number\n                    var tmp = String(parseFloat(nextArg()).toFixed(precision || 6));\n                    result += leadingZero ? tmp : tmp.replace(/^0/, '');\n                    break;\n                case 'j':// JSON\n                    result += JSON.stringify(nextArg());\n                    break;\n                case 'o':// number in octal\n                    result += '0' + parseInt(nextArg(), 10).toString(8);\n                    break;\n                case 's':// string\n                    result += nextArg();\n                    break;\n                case 'x':// lowercase hexadecimal\n                    result += '0x' + parseInt(nextArg(), 10).toString(16);\n                    break;\n                case 'X':// uppercase hexadecimal\n                    result += '0x' + parseInt(nextArg(), 10).toString(16).toUpperCase();\n                    break;\n                default:\n                    result += c;\n                    break;\n            }\n        }\n        else if (c === '%') {\n            escaped = true;\n        }\n        else {\n            result += c;\n        }\n    }\n    return result;\n}\nexports.format = format;\n/**\n * Return the thing that was passed in. Yaaaaawn.\n *\n * @export\n * @template T\n * @param {T} x A thing.\n * @returns {T} The same thing.\n */\nfunction identity(x) {\n    return x;\n}\nexports.identity = identity;\nfunction pad(v, width, pad) {\n    if (pad === void 0) { pad = '0'; }\n    return v.length >= width ? v : new Array(width - v.length + 1).join(pad) + v;\n}\nexports.pad = pad;\n/**\n * Add padding to a number to make it divisible by 8. Typically used to pad byte sizes so they align to a word boundary.\n *\n * @export\n * @param {number} size The number to pad.\n * @returns {number} The padded number.\n */\nfunction padToWord(size) {\n    return (size + 7) & ~7;\n}\nexports.padToWord = padToWord;\n/**\n * Repeat a string n times. Shamelessly copied from lodash.repeat.\n *\n * @param {number} times Number of times to repeat.\n * @param {string} str The string to repeat.\n * @returns {string} The repeated string.\n */\nfunction repeat(times, str) {\n    var out = '';\n    var n = times;\n    var s = str;\n    if (n < 1 || n > Number.MAX_VALUE)\n        return out;\n    // https://en.wikipedia.org/wiki/Exponentiation_by_squaring\n    do {\n        if (n % 2)\n            out += s;\n        n = Math.floor(n / 2);\n        if (n)\n            s += s;\n    } while (n);\n    return out;\n}\nexports.repeat = repeat;\n// Set up custom debug formatters.\n/* tslint:disable:no-string-literal */\n/* istanbul ignore next */\ndebug_1.default.formatters['h'] = function (v) { return v.toString('hex'); };\n/* istanbul ignore next */\ndebug_1.default.formatters['x'] = function (v) { return \"0x\" + v.toString(16); };\n/* istanbul ignore next */\ndebug_1.default.formatters['a'] = function (v) { return \"0x\" + pad(v.toString(16), 8); };\n/* istanbul ignore next */\ndebug_1.default.formatters['X'] = function (v) { return \"0x\" + v.toString(16).toUpperCase(); };\n/* tslint:enable:no-string-literal */\n\n//# sourceMappingURL=util.js.map\n"]},"metadata":{},"sourceType":"script"}