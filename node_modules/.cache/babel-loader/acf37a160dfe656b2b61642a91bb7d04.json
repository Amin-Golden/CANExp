{"ast":null,"code":"function findTimeIndex(entries, time) {\n  return entries.findIndex(e => e.time >= time);\n}\n\nfunction findRelativeTimeIndex(entries, relTime) {\n  return entries.findIndex(e => e.relTime >= relTime);\n}\n\nfunction findSegmentIndices(entries, _ref, isRelative) {\n  let [segmentTimeLow, segmentTimeHi] = _ref;\n\n  /*\n    Finds pair of indices (inclusive, exclusive) within entries array\n    whose timestamps match segmentTimeLow and segmentTimeHi.\n    if isRelative === true, then the segment times\n    are assumed to correspond to the `relTime` field of each entry.\n     Returns `[segmentIdxLow, segmentIdxHigh]`\n             (inclusive, exclusive)\n    */\n  const timeIndexFunc = isRelative === true ? findRelativeTimeIndex : findTimeIndex;\n  const segmentIdxLow = Math.max(0, timeIndexFunc(entries, segmentTimeLow));\n  const upperSegments = entries.slice(segmentIdxLow);\n  const upperSegmentIdxHi = timeIndexFunc(upperSegments, segmentTimeHi);\n  const segmentIdxHi = upperSegmentIdxHi >= 0 ? upperSegmentIdxHi + segmentIdxLow + 1 : entries.length - 1;\n  return [segmentIdxLow, Math.max(0, Math.min(segmentIdxHi, entries.length - 1))];\n}\n\nexport default {\n  findTimeIndex,\n  findRelativeTimeIndex,\n  findSegmentIndices\n};","map":{"version":3,"sources":["/home/amax/Autoro/cabana/src/models/can/entries.js"],"names":["findTimeIndex","entries","time","findIndex","e","findRelativeTimeIndex","relTime","findSegmentIndices","isRelative","segmentTimeLow","segmentTimeHi","timeIndexFunc","segmentIdxLow","Math","max","upperSegments","slice","upperSegmentIdxHi","segmentIdxHi","length","min"],"mappings":"AAAA,SAASA,aAAT,CAAuBC,OAAvB,EAAgCC,IAAhC,EAAsC;AACpC,SAAOD,OAAO,CAACE,SAAR,CAAmBC,CAAD,IAAOA,CAAC,CAACF,IAAF,IAAUA,IAAnC,CAAP;AACD;;AAED,SAASG,qBAAT,CAA+BJ,OAA/B,EAAwCK,OAAxC,EAAiD;AAC/C,SAAOL,OAAO,CAACE,SAAR,CAAmBC,CAAD,IAAOA,CAAC,CAACE,OAAF,IAAaA,OAAtC,CAAP;AACD;;AAED,SAASC,kBAAT,CACEN,OADF,QAGEO,UAHF,EAIE;AAAA,MAFA,CAACC,cAAD,EAAiBC,aAAjB,CAEA;;AACA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AAEE,QAAMC,aAAa,GAAGH,UAAU,KAAK,IAAf,GAAsBH,qBAAtB,GAA8CL,aAApE;AAEA,QAAMY,aAAa,GAAGC,IAAI,CAACC,GAAL,CAAS,CAAT,EAAYH,aAAa,CAACV,OAAD,EAAUQ,cAAV,CAAzB,CAAtB;AAEA,QAAMM,aAAa,GAAGd,OAAO,CAACe,KAAR,CAAcJ,aAAd,CAAtB;AACA,QAAMK,iBAAiB,GAAGN,aAAa,CAACI,aAAD,EAAgBL,aAAhB,CAAvC;AACA,QAAMQ,YAAY,GAAGD,iBAAiB,IAAI,CAArB,GACjBA,iBAAiB,GAAGL,aAApB,GAAoC,CADnB,GAEjBX,OAAO,CAACkB,MAAR,GAAiB,CAFrB;AAIA,SAAO,CACLP,aADK,EAELC,IAAI,CAACC,GAAL,CAAS,CAAT,EAAYD,IAAI,CAACO,GAAL,CAASF,YAAT,EAAuBjB,OAAO,CAACkB,MAAR,GAAiB,CAAxC,CAAZ,CAFK,CAAP;AAID;;AAED,eAAe;AAAEnB,EAAAA,aAAF;AAAiBK,EAAAA,qBAAjB;AAAwCE,EAAAA;AAAxC,CAAf","sourcesContent":["function findTimeIndex(entries, time) {\n  return entries.findIndex((e) => e.time >= time);\n}\n\nfunction findRelativeTimeIndex(entries, relTime) {\n  return entries.findIndex((e) => e.relTime >= relTime);\n}\n\nfunction findSegmentIndices(\n  entries,\n  [segmentTimeLow, segmentTimeHi],\n  isRelative\n) {\n  /*\n    Finds pair of indices (inclusive, exclusive) within entries array\n    whose timestamps match segmentTimeLow and segmentTimeHi.\n    if isRelative === true, then the segment times\n    are assumed to correspond to the `relTime` field of each entry.\n\n    Returns `[segmentIdxLow, segmentIdxHigh]`\n             (inclusive, exclusive)\n    */\n  const timeIndexFunc = isRelative === true ? findRelativeTimeIndex : findTimeIndex;\n\n  const segmentIdxLow = Math.max(0, timeIndexFunc(entries, segmentTimeLow));\n\n  const upperSegments = entries.slice(segmentIdxLow);\n  const upperSegmentIdxHi = timeIndexFunc(upperSegments, segmentTimeHi);\n  const segmentIdxHi = upperSegmentIdxHi >= 0\n    ? upperSegmentIdxHi + segmentIdxLow + 1\n    : entries.length - 1;\n\n  return [\n    segmentIdxLow,\n    Math.max(0, Math.min(segmentIdxHi, entries.length - 1))\n  ];\n}\n\nexport default { findTimeIndex, findRelativeTimeIndex, findSegmentIndices };\n"]},"metadata":{},"sourceType":"module"}