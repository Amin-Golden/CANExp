{"ast":null,"code":"'use strict';\n/* @flow */\n\nvar max = require('./max'),\n    min = require('./min');\n/**\n * Given an array of x, this will find the extent of the\n * x and return an array of breaks that can be used\n * to categorize the x into a number of classes. The\n * returned array will always be 1 longer than the number of\n * classes because it includes the minimum value.\n *\n * @param {Array<number>} x an array of number values\n * @param {number} nClasses number of desired classes\n * @returns {Array<number>} array of class break positions\n * @example\n * equalIntervalBreaks([1, 2, 3, 4, 5, 6], 4); //= [1, 2.25, 3.5, 4.75, 6]\n */\n\n\nfunction equalIntervalBreaks(x\n/*: Array<number> */\n, nClasses\n/*:number*/\n)\n/*: Array<number> */\n{\n  if (x.length < 2) {\n    return x;\n  }\n\n  var theMin = min(x),\n      theMax = max(x); // the first break will always be the minimum value\n  // in the xset\n\n  var breaks = [theMin]; // The size of each break is the full range of the x\n  // divided by the number of classes requested\n\n  var breakSize = (theMax - theMin) / nClasses; // In the case of nClasses = 1, this loop won't run\n  // and the returned breaks will be [min, max]\n\n  for (var i = 1; i < nClasses; i++) {\n    breaks.push(breaks[0] + breakSize * i);\n  } // the last break will always be the\n  // maximum.\n\n\n  breaks.push(theMax);\n  return breaks;\n}\n\nmodule.exports = equalIntervalBreaks;","map":{"version":3,"sources":["/home/amax/Autoro/cabana/node_modules/simple-statistics/src/equal_interval_breaks.js"],"names":["max","require","min","equalIntervalBreaks","x","nClasses","length","theMin","theMax","breaks","breakSize","i","push","module","exports"],"mappings":"AAAA;AACA;;AAEA,IAAIA,GAAG,GAAGC,OAAO,CAAC,OAAD,CAAjB;AAAA,IACIC,GAAG,GAAGD,OAAO,CAAC,OAAD,CADjB;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASE,mBAAT,CAA6BC;AAAC;AAA9B,EAAoDC;AAAQ;AAA5D;AAAwE;AAAqB;AAEzF,MAAID,CAAC,CAACE,MAAF,GAAW,CAAf,EAAkB;AACd,WAAOF,CAAP;AACH;;AAED,MAAIG,MAAM,GAAGL,GAAG,CAACE,CAAD,CAAhB;AAAA,MACII,MAAM,GAAGR,GAAG,CAACI,CAAD,CADhB,CANyF,CASzF;AACA;;AACA,MAAIK,MAAM,GAAG,CAACF,MAAD,CAAb,CAXyF,CAazF;AACA;;AACA,MAAIG,SAAS,GAAG,CAACF,MAAM,GAAGD,MAAV,IAAoBF,QAApC,CAfyF,CAiBzF;AACA;;AACA,OAAK,IAAIM,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGN,QAApB,EAA8BM,CAAC,EAA/B,EAAmC;AAC/BF,IAAAA,MAAM,CAACG,IAAP,CAAYH,MAAM,CAAC,CAAD,CAAN,GAAYC,SAAS,GAAGC,CAApC;AACH,GArBwF,CAuBzF;AACA;;;AACAF,EAAAA,MAAM,CAACG,IAAP,CAAYJ,MAAZ;AAEA,SAAOC,MAAP;AACH;;AAEDI,MAAM,CAACC,OAAP,GAAiBX,mBAAjB","sourcesContent":["'use strict';\n/* @flow */\n\nvar max = require('./max'),\n    min = require('./min');\n\n/**\n * Given an array of x, this will find the extent of the\n * x and return an array of breaks that can be used\n * to categorize the x into a number of classes. The\n * returned array will always be 1 longer than the number of\n * classes because it includes the minimum value.\n *\n * @param {Array<number>} x an array of number values\n * @param {number} nClasses number of desired classes\n * @returns {Array<number>} array of class break positions\n * @example\n * equalIntervalBreaks([1, 2, 3, 4, 5, 6], 4); //= [1, 2.25, 3.5, 4.75, 6]\n */\nfunction equalIntervalBreaks(x/*: Array<number> */, nClasses/*:number*/)/*: Array<number> */ {\n\n    if (x.length < 2) {\n        return x;\n    }\n\n    var theMin = min(x),\n        theMax = max(x); \n\n    // the first break will always be the minimum value\n    // in the xset\n    var breaks = [theMin];\n\n    // The size of each break is the full range of the x\n    // divided by the number of classes requested\n    var breakSize = (theMax - theMin) / nClasses;\n\n    // In the case of nClasses = 1, this loop won't run\n    // and the returned breaks will be [min, max]\n    for (var i = 1; i < nClasses; i++) {\n        breaks.push(breaks[0] + breakSize * i);\n    }\n\n    // the last break will always be the\n    // maximum.\n    breaks.push(theMax);\n\n    return breaks;\n}\n\nmodule.exports = equalIntervalBreaks;\n"]},"metadata":{},"sourceType":"script"}