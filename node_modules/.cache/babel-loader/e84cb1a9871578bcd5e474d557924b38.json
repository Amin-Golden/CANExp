{"ast":null,"code":"// Client-side parser for .npy files\n// See the specification: http://docs.scipy.org/doc/numpy-dev/neps/npy-format.html\nconst NumpyLoader = function NumpyLoader() {\n  function asciiDecode(buf) {\n    return String.fromCharCode.apply(null, new Uint8Array(buf));\n  }\n\n  function readUint16LE(buffer) {\n    const view = new DataView(buffer);\n    let val = view.getUint8(0);\n    val |= view.getUint8(1) << 8;\n    return val;\n  }\n\n  function fromArrayBuffer(buf) {\n    // Check the magic number\n    const magic = asciiDecode(buf.slice(0, 6));\n\n    if (magic !== '\\x93NUMPY') {\n      throw new Error('Bad magic number');\n    }\n\n    const version = new Uint8Array(buf.slice(6, 8));\n    const headerLength = readUint16LE(buf.slice(8, 10));\n    const headerStr = asciiDecode(buf.slice(10, 10 + headerLength));\n    const offsetBytes = 10 + headerLength; // rest = buf.slice(10+headerLength);  XXX -- This makes a copy!!! https://www.khronos.org/registry/typedarray/specs/latest/#5\n    // Hacky conversion of dict literal string to JS Object\n\n    const info = JSON.parse(headerStr.toLowerCase().replace('(', '[').replace('),', ']').replace(/'/g, '\"').replace(',]', ']')); // Intepret the bytes according to the specified dtype\n\n    let data;\n\n    if (info.descr === '|u1') {\n      data = new Uint8Array(buf, offsetBytes);\n    } else if (info.descr === '|i1') {\n      data = new Int8Array(buf, offsetBytes);\n    } else if (info.descr === '<u2') {\n      data = new Uint16Array(buf, offsetBytes);\n    } else if (info.descr === '<i2') {\n      data = new Int16Array(buf, offsetBytes);\n    } else if (info.descr === '<u4') {\n      data = new Uint32Array(buf, offsetBytes);\n    } else if (info.descr === '<i4') {\n      data = new Int32Array(buf, offsetBytes);\n    } else if (info.descr === '<f4') {\n      data = new Float32Array(buf, offsetBytes);\n    } else if (info.descr === '<f8') {\n      data = new Float64Array(buf, offsetBytes);\n    } else if (info.descr === '<u8') {\n      // 8 byte uint64s\n      data = new Uint8Array(buf, offsetBytes);\n    } else if (info.descr === '<i8') {\n      // 8 byte int64s\n      data = new Uint8Array(buf, offsetBytes);\n    } else if (info.descr === '|s5') {\n      // 5 byte string\n      data = new Uint8Array(buf, offsetBytes);\n    } else if (info.descr === '|s8') {\n      // 8 byte strings\n      data = new Uint8Array(buf, offsetBytes);\n    } else if (info.descr === '|s15') {\n      // 15 byte strings?\n      data = new Uint8Array(buf, offsetBytes);\n    } else {\n      throw new Error(`unknown numeric dtype ${info.descr}`);\n    }\n\n    return {\n      shape: info.shape,\n      fortran_order: info.fortran_order,\n      data\n    };\n  }\n\n  function open(file, callback) {\n    const reader = new FileReader();\n\n    reader.onload = function () {\n      // the file contents have been read as an array buffer\n      const buf = reader.result;\n      const ndarray = fromArrayBuffer(buf);\n      callback(ndarray);\n    };\n\n    reader.readAsArrayBuffer(file);\n  }\n\n  function promise(url) {\n    return new Promise((resolve, reject) => {\n      // Do the usual XHR stuff\n      const req = new XMLHttpRequest();\n\n      req.onload = function () {\n        // This is called even on 404 etc\n        // so check the status\n        if (req.status == 200) {\n          const buf = req.response; // not responseText\n\n          const ndarray = fromArrayBuffer(buf);\n          resolve(ndarray);\n        } else if (req.status == 404) {\n          console.log('yup');\n          reject({\n            is404: true\n          });\n        } else {\n          // Otherwise reject with the status text\n          // which will hopefully be a meaningful error\n          reject(Error(req.statusText));\n        }\n      }; // Handle network errors\n\n\n      req.onerror = function () {\n        reject(Error('Network Error'));\n      }; // Make the request\n\n\n      req.open('GET', url, true);\n      req.responseType = 'arraybuffer';\n      req.send(null);\n    });\n  }\n\n  return {\n    open,\n    promise,\n    fromArrayBuffer\n  };\n}();\n\nmodule.exports = NumpyLoader;","map":{"version":3,"sources":["/home/amax/Autoro/cabana/src/utils/loadnpy.js"],"names":["NumpyLoader","asciiDecode","buf","String","fromCharCode","apply","Uint8Array","readUint16LE","buffer","view","DataView","val","getUint8","fromArrayBuffer","magic","slice","Error","version","headerLength","headerStr","offsetBytes","info","JSON","parse","toLowerCase","replace","data","descr","Int8Array","Uint16Array","Int16Array","Uint32Array","Int32Array","Float32Array","Float64Array","shape","fortran_order","open","file","callback","reader","FileReader","onload","result","ndarray","readAsArrayBuffer","promise","url","Promise","resolve","reject","req","XMLHttpRequest","status","response","console","log","is404","statusText","onerror","responseType","send","module","exports"],"mappings":"AAAA;AACA;AAEA,MAAMA,WAAW,GAAI,SAASA,WAAT,GAAuB;AAC1C,WAASC,WAAT,CAAqBC,GAArB,EAA0B;AACxB,WAAOC,MAAM,CAACC,YAAP,CAAoBC,KAApB,CAA0B,IAA1B,EAAgC,IAAIC,UAAJ,CAAeJ,GAAf,CAAhC,CAAP;AACD;;AAED,WAASK,YAAT,CAAsBC,MAAtB,EAA8B;AAC5B,UAAMC,IAAI,GAAG,IAAIC,QAAJ,CAAaF,MAAb,CAAb;AACA,QAAIG,GAAG,GAAGF,IAAI,CAACG,QAAL,CAAc,CAAd,CAAV;AACAD,IAAAA,GAAG,IAAIF,IAAI,CAACG,QAAL,CAAc,CAAd,KAAoB,CAA3B;AACA,WAAOD,GAAP;AACD;;AAED,WAASE,eAAT,CAAyBX,GAAzB,EAA8B;AAC5B;AACA,UAAMY,KAAK,GAAGb,WAAW,CAACC,GAAG,CAACa,KAAJ,CAAU,CAAV,EAAa,CAAb,CAAD,CAAzB;;AACA,QAAID,KAAK,KAAK,WAAd,EAA2B;AACzB,YAAM,IAAIE,KAAJ,CAAU,kBAAV,CAAN;AACD;;AAED,UAAMC,OAAO,GAAG,IAAIX,UAAJ,CAAeJ,GAAG,CAACa,KAAJ,CAAU,CAAV,EAAa,CAAb,CAAf,CAAhB;AACA,UAAMG,YAAY,GAAGX,YAAY,CAACL,GAAG,CAACa,KAAJ,CAAU,CAAV,EAAa,EAAb,CAAD,CAAjC;AACA,UAAMI,SAAS,GAAGlB,WAAW,CAACC,GAAG,CAACa,KAAJ,CAAU,EAAV,EAAc,KAAKG,YAAnB,CAAD,CAA7B;AACA,UAAME,WAAW,GAAG,KAAKF,YAAzB,CAV4B,CAW5B;AAEA;;AACA,UAAMG,IAAI,GAAGC,IAAI,CAACC,KAAL,CACXJ,SAAS,CACNK,WADH,GAEGC,OAFH,CAEW,GAFX,EAEgB,GAFhB,EAGGA,OAHH,CAGW,IAHX,EAGiB,GAHjB,EAIGA,OAJH,CAIW,IAJX,EAIiB,GAJjB,EAKGA,OALH,CAKW,IALX,EAKiB,GALjB,CADW,CAAb,CAd4B,CAuB5B;;AACA,QAAIC,IAAJ;;AACA,QAAIL,IAAI,CAACM,KAAL,KAAe,KAAnB,EAA0B;AACxBD,MAAAA,IAAI,GAAG,IAAIpB,UAAJ,CAAeJ,GAAf,EAAoBkB,WAApB,CAAP;AACD,KAFD,MAEO,IAAIC,IAAI,CAACM,KAAL,KAAe,KAAnB,EAA0B;AAC/BD,MAAAA,IAAI,GAAG,IAAIE,SAAJ,CAAc1B,GAAd,EAAmBkB,WAAnB,CAAP;AACD,KAFM,MAEA,IAAIC,IAAI,CAACM,KAAL,KAAe,KAAnB,EAA0B;AAC/BD,MAAAA,IAAI,GAAG,IAAIG,WAAJ,CAAgB3B,GAAhB,EAAqBkB,WAArB,CAAP;AACD,KAFM,MAEA,IAAIC,IAAI,CAACM,KAAL,KAAe,KAAnB,EAA0B;AAC/BD,MAAAA,IAAI,GAAG,IAAII,UAAJ,CAAe5B,GAAf,EAAoBkB,WAApB,CAAP;AACD,KAFM,MAEA,IAAIC,IAAI,CAACM,KAAL,KAAe,KAAnB,EAA0B;AAC/BD,MAAAA,IAAI,GAAG,IAAIK,WAAJ,CAAgB7B,GAAhB,EAAqBkB,WAArB,CAAP;AACD,KAFM,MAEA,IAAIC,IAAI,CAACM,KAAL,KAAe,KAAnB,EAA0B;AAC/BD,MAAAA,IAAI,GAAG,IAAIM,UAAJ,CAAe9B,GAAf,EAAoBkB,WAApB,CAAP;AACD,KAFM,MAEA,IAAIC,IAAI,CAACM,KAAL,KAAe,KAAnB,EAA0B;AAC/BD,MAAAA,IAAI,GAAG,IAAIO,YAAJ,CAAiB/B,GAAjB,EAAsBkB,WAAtB,CAAP;AACD,KAFM,MAEA,IAAIC,IAAI,CAACM,KAAL,KAAe,KAAnB,EAA0B;AAC/BD,MAAAA,IAAI,GAAG,IAAIQ,YAAJ,CAAiBhC,GAAjB,EAAsBkB,WAAtB,CAAP;AACD,KAFM,MAEA,IAAIC,IAAI,CAACM,KAAL,KAAe,KAAnB,EAA0B;AAC/B;AACAD,MAAAA,IAAI,GAAG,IAAIpB,UAAJ,CAAeJ,GAAf,EAAoBkB,WAApB,CAAP;AACD,KAHM,MAGA,IAAIC,IAAI,CAACM,KAAL,KAAe,KAAnB,EAA0B;AAC/B;AACAD,MAAAA,IAAI,GAAG,IAAIpB,UAAJ,CAAeJ,GAAf,EAAoBkB,WAApB,CAAP;AACD,KAHM,MAGA,IAAIC,IAAI,CAACM,KAAL,KAAe,KAAnB,EAA0B;AAC/B;AACAD,MAAAA,IAAI,GAAG,IAAIpB,UAAJ,CAAeJ,GAAf,EAAoBkB,WAApB,CAAP;AACD,KAHM,MAGA,IAAIC,IAAI,CAACM,KAAL,KAAe,KAAnB,EAA0B;AAC/B;AACAD,MAAAA,IAAI,GAAG,IAAIpB,UAAJ,CAAeJ,GAAf,EAAoBkB,WAApB,CAAP;AACD,KAHM,MAGA,IAAIC,IAAI,CAACM,KAAL,KAAe,MAAnB,EAA2B;AAChC;AACAD,MAAAA,IAAI,GAAG,IAAIpB,UAAJ,CAAeJ,GAAf,EAAoBkB,WAApB,CAAP;AACD,KAHM,MAGA;AACL,YAAM,IAAIJ,KAAJ,CAAW,yBAAwBK,IAAI,CAACM,KAAM,EAA9C,CAAN;AACD;;AAED,WAAO;AACLQ,MAAAA,KAAK,EAAEd,IAAI,CAACc,KADP;AAELC,MAAAA,aAAa,EAAEf,IAAI,CAACe,aAFf;AAGLV,MAAAA;AAHK,KAAP;AAKD;;AAED,WAASW,IAAT,CAAcC,IAAd,EAAoBC,QAApB,EAA8B;AAC5B,UAAMC,MAAM,GAAG,IAAIC,UAAJ,EAAf;;AACAD,IAAAA,MAAM,CAACE,MAAP,GAAgB,YAAY;AAC1B;AACA,YAAMxC,GAAG,GAAGsC,MAAM,CAACG,MAAnB;AACA,YAAMC,OAAO,GAAG/B,eAAe,CAACX,GAAD,CAA/B;AACAqC,MAAAA,QAAQ,CAACK,OAAD,CAAR;AACD,KALD;;AAMAJ,IAAAA,MAAM,CAACK,iBAAP,CAAyBP,IAAzB;AACD;;AAED,WAASQ,OAAT,CAAiBC,GAAjB,EAAsB;AACpB,WAAO,IAAIC,OAAJ,CAAY,CAACC,OAAD,EAAUC,MAAV,KAAqB;AACtC;AACA,YAAMC,GAAG,GAAG,IAAIC,cAAJ,EAAZ;;AACAD,MAAAA,GAAG,CAACT,MAAJ,GAAa,YAAY;AACvB;AACA;AACA,YAAIS,GAAG,CAACE,MAAJ,IAAc,GAAlB,EAAuB;AACrB,gBAAMnD,GAAG,GAAGiD,GAAG,CAACG,QAAhB,CADqB,CACK;;AAC1B,gBAAMV,OAAO,GAAG/B,eAAe,CAACX,GAAD,CAA/B;AACA+C,UAAAA,OAAO,CAACL,OAAD,CAAP;AACD,SAJD,MAIO,IAAIO,GAAG,CAACE,MAAJ,IAAc,GAAlB,EAAuB;AAC5BE,UAAAA,OAAO,CAACC,GAAR,CAAY,KAAZ;AACAN,UAAAA,MAAM,CAAC;AAAEO,YAAAA,KAAK,EAAE;AAAT,WAAD,CAAN;AACD,SAHM,MAGA;AACL;AACA;AACAP,UAAAA,MAAM,CAAClC,KAAK,CAACmC,GAAG,CAACO,UAAL,CAAN,CAAN;AACD;AACF,OAfD,CAHsC,CAoBtC;;;AACAP,MAAAA,GAAG,CAACQ,OAAJ,GAAc,YAAY;AACxBT,QAAAA,MAAM,CAAClC,KAAK,CAAC,eAAD,CAAN,CAAN;AACD,OAFD,CArBsC,CAyBtC;;;AACAmC,MAAAA,GAAG,CAACd,IAAJ,CAAS,KAAT,EAAgBU,GAAhB,EAAqB,IAArB;AACAI,MAAAA,GAAG,CAACS,YAAJ,GAAmB,aAAnB;AACAT,MAAAA,GAAG,CAACU,IAAJ,CAAS,IAAT;AACD,KA7BM,CAAP;AA8BD;;AAED,SAAO;AACLxB,IAAAA,IADK;AAELS,IAAAA,OAFK;AAGLjC,IAAAA;AAHK,GAAP;AAKD,CAhIoB,EAArB;;AAkIAiD,MAAM,CAACC,OAAP,GAAiB/D,WAAjB","sourcesContent":["// Client-side parser for .npy files\n// See the specification: http://docs.scipy.org/doc/numpy-dev/neps/npy-format.html\n\nconst NumpyLoader = (function NumpyLoader() {\n  function asciiDecode(buf) {\n    return String.fromCharCode.apply(null, new Uint8Array(buf));\n  }\n\n  function readUint16LE(buffer) {\n    const view = new DataView(buffer);\n    let val = view.getUint8(0);\n    val |= view.getUint8(1) << 8;\n    return val;\n  }\n\n  function fromArrayBuffer(buf) {\n    // Check the magic number\n    const magic = asciiDecode(buf.slice(0, 6));\n    if (magic !== '\\x93NUMPY') {\n      throw new Error('Bad magic number');\n    }\n\n    const version = new Uint8Array(buf.slice(6, 8));\n    const headerLength = readUint16LE(buf.slice(8, 10));\n    const headerStr = asciiDecode(buf.slice(10, 10 + headerLength));\n    const offsetBytes = 10 + headerLength;\n    // rest = buf.slice(10+headerLength);  XXX -- This makes a copy!!! https://www.khronos.org/registry/typedarray/specs/latest/#5\n\n    // Hacky conversion of dict literal string to JS Object\n    const info = JSON.parse(\n      headerStr\n        .toLowerCase()\n        .replace('(', '[')\n        .replace('),', ']')\n        .replace(/'/g, '\"')\n        .replace(',]', ']')\n    );\n\n    // Intepret the bytes according to the specified dtype\n    let data;\n    if (info.descr === '|u1') {\n      data = new Uint8Array(buf, offsetBytes);\n    } else if (info.descr === '|i1') {\n      data = new Int8Array(buf, offsetBytes);\n    } else if (info.descr === '<u2') {\n      data = new Uint16Array(buf, offsetBytes);\n    } else if (info.descr === '<i2') {\n      data = new Int16Array(buf, offsetBytes);\n    } else if (info.descr === '<u4') {\n      data = new Uint32Array(buf, offsetBytes);\n    } else if (info.descr === '<i4') {\n      data = new Int32Array(buf, offsetBytes);\n    } else if (info.descr === '<f4') {\n      data = new Float32Array(buf, offsetBytes);\n    } else if (info.descr === '<f8') {\n      data = new Float64Array(buf, offsetBytes);\n    } else if (info.descr === '<u8') {\n      // 8 byte uint64s\n      data = new Uint8Array(buf, offsetBytes);\n    } else if (info.descr === '<i8') {\n      // 8 byte int64s\n      data = new Uint8Array(buf, offsetBytes);\n    } else if (info.descr === '|s5') {\n      // 5 byte string\n      data = new Uint8Array(buf, offsetBytes);\n    } else if (info.descr === '|s8') {\n      // 8 byte strings\n      data = new Uint8Array(buf, offsetBytes);\n    } else if (info.descr === '|s15') {\n      // 15 byte strings?\n      data = new Uint8Array(buf, offsetBytes);\n    } else {\n      throw new Error(`unknown numeric dtype ${info.descr}`);\n    }\n\n    return {\n      shape: info.shape,\n      fortran_order: info.fortran_order,\n      data\n    };\n  }\n\n  function open(file, callback) {\n    const reader = new FileReader();\n    reader.onload = function () {\n      // the file contents have been read as an array buffer\n      const buf = reader.result;\n      const ndarray = fromArrayBuffer(buf);\n      callback(ndarray);\n    };\n    reader.readAsArrayBuffer(file);\n  }\n\n  function promise(url) {\n    return new Promise((resolve, reject) => {\n      // Do the usual XHR stuff\n      const req = new XMLHttpRequest();\n      req.onload = function () {\n        // This is called even on 404 etc\n        // so check the status\n        if (req.status == 200) {\n          const buf = req.response; // not responseText\n          const ndarray = fromArrayBuffer(buf);\n          resolve(ndarray);\n        } else if (req.status == 404) {\n          console.log('yup');\n          reject({ is404: true });\n        } else {\n          // Otherwise reject with the status text\n          // which will hopefully be a meaningful error\n          reject(Error(req.statusText));\n        }\n      };\n\n      // Handle network errors\n      req.onerror = function () {\n        reject(Error('Network Error'));\n      };\n\n      // Make the request\n      req.open('GET', url, true);\n      req.responseType = 'arraybuffer';\n      req.send(null);\n    });\n  }\n\n  return {\n    open,\n    promise,\n    fromArrayBuffer\n  };\n}());\n\nmodule.exports = NumpyLoader;\n"]},"metadata":{},"sourceType":"module"}