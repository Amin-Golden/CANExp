{"ast":null,"code":"\"use strict\";\n/**\n * @author jdiaz5513\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar debug_1 = require(\"debug\");\n\nvar constants_1 = require(\"../constants\");\n\nvar errors_1 = require(\"../errors\");\n\nvar util_1 = require(\"../util\");\n\nvar arena_1 = require(\"./arena\");\n\nvar packing_1 = require(\"./packing\");\n\nvar pointers_1 = require(\"./pointers\");\n\nvar segment_1 = require(\"./segment\");\n\nvar pointer_1 = require(\"./pointers/pointer\");\n\nvar struct_1 = require(\"./pointers/struct\");\n\nvar trace = debug_1.default('capnp:message');\ntrace('load');\n\nvar Message =\n/** @class */\nfunction () {\n  /**\n   * A Cap'n Proto message.\n   *\n   * SECURITY WARNING: In nodejs do not pass a Buffer's internal array buffer into this constructor. Pass the buffer\n   * directly and everything will be fine. If not, your message will potentially be initialized with random memory\n   * contents!\n   *\n   * The constructor method creates a new Message, optionally using a provided arena for segment allocation, or a buffer\n   * to read from.\n   *\n   * @constructor {Message}\n   *\n   * @param {AnyArena|ArrayBufferView|ArrayBuffer} [src] The source for the message.\n   * A value of `undefined` will cause the message to initialize with a single segment arena only big enough for the\n   * root pointer; it will expand as you go. This is a reasonable choice for most messages.\n   *\n   * Passing an arena will cause the message to use that arena for its segment allocation. Contents will be accepted\n   * as-is.\n   *\n   * Passing an array buffer view (like `DataView`, `Uint8Array` or `Buffer`) will create a **copy** of the source\n   * buffer; beware of the potential performance cost!\n   *\n   * @param {boolean} [packed] Whether or not the message is packed. If `true` (the default), the message will be\n   * unpacked.\n   *\n   * @param {boolean} [singleSegment] If true, `src` will be treated as a message consisting of a single segment without\n   * a framing header.\n   *\n   */\n  function Message(src, packed, singleSegment) {\n    if (packed === void 0) {\n      packed = true;\n    }\n\n    if (singleSegment === void 0) {\n      singleSegment = false;\n    }\n\n    this._capnp = initMessage(src, packed, singleSegment);\n    if (src && !isAnyArena(src)) preallocateSegments(this);\n    trace('new %s', this);\n  }\n\n  Message.prototype.allocateSegment = function (byteLength) {\n    return allocateSegment(byteLength, this);\n  };\n  /**\n   * Create a pretty-printed string dump of this message; incredibly useful for debugging.\n   *\n   * WARNING: Do not call this method on large messages!\n   *\n   * @returns {string} A big steaming pile of pretty hex digits.\n   */\n\n\n  Message.prototype.dump = function () {\n    return dump(this);\n  };\n  /**\n   * Get a struct pointer for the root of this message. This is primarily used when reading a message; it will not\n   * overwrite existing data.\n   *\n   * @template T\n   * @param {StructCtor<T>} RootStruct The struct type to use as the root.\n   * @returns {T} A struct representing the root of the message.\n   */\n\n\n  Message.prototype.getRoot = function (RootStruct) {\n    return getRoot(RootStruct, this);\n  };\n  /**\n   * Get a segment by its id.\n   *\n   * This will lazily allocate the first segment if it doesn't already exist.\n   *\n   * @param {number} id The segment id.\n   * @returns {Segment} The requested segment.\n   */\n\n\n  Message.prototype.getSegment = function (id) {\n    return getSegment(id, this);\n  };\n  /**\n   * Initialize a new message using the provided struct type as the root.\n   *\n   * @template T\n   * @param {StructCtor<T>} RootStruct The struct type to use as the root.\n   * @returns {T} An initialized struct pointing to the root of the message.\n   */\n\n\n  Message.prototype.initRoot = function (RootStruct) {\n    return initRoot(RootStruct, this);\n  };\n  /**\n   * Combine the contents of this message's segments into a single array buffer and prepend a stream framing header\n   * containing information about the following segment data.\n   *\n   * @returns {ArrayBuffer} An ArrayBuffer with the contents of this message.\n   */\n\n\n  Message.prototype.toArrayBuffer = function () {\n    return toArrayBuffer(this);\n  };\n  /**\n   * Like `toArrayBuffer()`, but also applies the packing algorithm to the output. This is typically what you want to\n   * use if you're sending the message over a network link or other slow I/O interface where size matters.\n   *\n   * @returns {ArrayBuffer} A packed message.\n   */\n\n\n  Message.prototype.toPackedArrayBuffer = function () {\n    return toPackedArrayBuffer(this);\n  };\n\n  Message.prototype.toString = function () {\n    return \"Message_arena:\" + this._capnp.arena;\n  };\n\n  Message.allocateSegment = allocateSegment;\n  Message.dump = dump;\n  Message.getRoot = getRoot;\n  Message.getSegment = getSegment;\n  Message.initRoot = initRoot;\n  Message.toArrayBuffer = toArrayBuffer;\n  Message.toPackedArrayBuffer = toPackedArrayBuffer;\n  return Message;\n}();\n\nexports.Message = Message;\n\nfunction initMessage(src, packed, singleSegment) {\n  if (packed === void 0) {\n    packed = true;\n  }\n\n  if (singleSegment === void 0) {\n    singleSegment = false;\n  }\n\n  if (src === undefined) {\n    return {\n      arena: new arena_1.SingleSegmentArena(),\n      segments: [],\n      traversalLimit: constants_1.DEFAULT_TRAVERSE_LIMIT\n    };\n  }\n\n  if (isAnyArena(src)) return {\n    arena: src,\n    segments: [],\n    traversalLimit: constants_1.DEFAULT_TRAVERSE_LIMIT\n  };\n  var buf = src;\n  if (isArrayBufferView(buf)) buf = buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);\n  if (packed) buf = packing_1.unpack(buf);\n\n  if (singleSegment) {\n    return {\n      arena: new arena_1.SingleSegmentArena(buf),\n      segments: [],\n      traversalLimit: constants_1.DEFAULT_TRAVERSE_LIMIT\n    };\n  }\n\n  return {\n    arena: new arena_1.MultiSegmentArena(getFramedSegments(buf)),\n    segments: [],\n    traversalLimit: constants_1.DEFAULT_TRAVERSE_LIMIT\n  };\n}\n\nexports.initMessage = initMessage;\n/**\n * Given an _unpacked_ message with a segment framing header, this will generate an ArrayBuffer for each segment in\n * the message.\n *\n * This method is not typically called directly, but can be useful in certain cases.\n *\n * @static\n * @param {ArrayBuffer} message An unpacked message with a framing header.\n * @returns {ArrayBuffer[]} An array of buffers containing the segment data.\n */\n\nfunction getFramedSegments(message) {\n  var dv = new DataView(message);\n  var segmentCount = dv.getUint32(0, true) + 1;\n  var segments = new Array(segmentCount);\n  trace('reading %d framed segments from stream', segmentCount);\n  var byteOffset = 4 + segmentCount * 4;\n  byteOffset += byteOffset % 8;\n  if (byteOffset + segmentCount * 4 > message.byteLength) throw new Error(errors_1.MSG_INVALID_FRAME_HEADER);\n\n  for (var i = 0; i < segmentCount; i++) {\n    var byteLength = dv.getUint32(4 + i * 4, true) * 8;\n    if (byteOffset + byteLength > message.byteLength) throw new Error(errors_1.MSG_INVALID_FRAME_HEADER);\n    segments[i] = message.slice(byteOffset, byteOffset + byteLength);\n    byteOffset += byteLength;\n  }\n\n  return segments;\n}\n\nexports.getFramedSegments = getFramedSegments;\n/**\n * This method is called on messages that were constructed with existing data to prepopulate the segments array with\n * everything we can find in the arena. Each segment will have it's `byteLength` set to the size of its buffer.\n *\n * Technically speaking, the message's segments will be \"full\" after calling this function. Calling this on your own\n * may void your warranty.\n *\n * @param {Message} m The message to allocate.\n * @returns {void}\n */\n\nfunction preallocateSegments(m) {\n  var numSegments = arena_1.Arena.getNumSegments(m._capnp.arena);\n  if (numSegments < 1) throw new Error(errors_1.MSG_NO_SEGMENTS_IN_ARENA);\n  m._capnp.segments = new Array(numSegments);\n\n  for (var i = 0; i < numSegments; i++) {\n    // Set up each segment so that they're fully allocated to the extents of the existing buffers.\n    var buffer = arena_1.Arena.getBuffer(i, m._capnp.arena);\n    var segment = new segment_1.Segment(i, m, buffer, buffer.byteLength);\n    m._capnp.segments[i] = segment;\n  }\n}\n\nexports.preallocateSegments = preallocateSegments;\n\nfunction isArrayBufferView(src) {\n  return src.byteOffset !== undefined;\n}\n\nfunction isAnyArena(o) {\n  return o.kind !== undefined;\n}\n\nfunction allocateSegment(byteLength, m) {\n  trace('allocating %x bytes for %s', byteLength, m);\n  var res = arena_1.Arena.allocate(byteLength, m._capnp.segments, m._capnp.arena);\n  var s;\n\n  if (res.id === m._capnp.segments.length) {\n    // Note how we're only allowing new segments in if they're exactly the next one in the array. There is no logical\n    // reason for segments to be created out of order.\n    s = new segment_1.Segment(res.id, m, res.buffer);\n    trace('adding new segment %s', s);\n\n    m._capnp.segments.push(s);\n  } else if (res.id < 0 || res.id > m._capnp.segments.length) {\n    throw new Error(util_1.format(errors_1.MSG_SEGMENT_OUT_OF_BOUNDS, res.id, m));\n  } else {\n    s = m._capnp.segments[res.id];\n    trace('replacing segment %s with buffer (len:%d)', s, res.buffer.byteLength);\n    s.replaceBuffer(res.buffer);\n  }\n\n  return s;\n}\n\nexports.allocateSegment = allocateSegment;\n\nfunction dump(m) {\n  var r = '';\n  if (m._capnp.segments.length === 0) return '================\\nNo Segments\\n================\\n';\n\n  for (var i = 0; i < m._capnp.segments.length; i++) {\n    r += \"================\\nSegment #\" + i + \"\\n================\\n\";\n    var _a = m._capnp.segments[i],\n        buffer = _a.buffer,\n        byteLength = _a.byteLength;\n    var b = new Uint8Array(buffer, 0, byteLength);\n    r += util_1.dumpBuffer(b);\n  }\n\n  return r;\n}\n\nexports.dump = dump;\n\nfunction getRoot(RootStruct, m) {\n  var root = new RootStruct(m.getSegment(0), 0);\n  pointer_1.validate(pointers_1.PointerType.STRUCT, root);\n  var ts = pointer_1.getTargetStructSize(root); // Make sure the underlying pointer is actually big enough to hold the data and pointers as specified in the schema.\n  // If not a shallow copy of the struct contents needs to be made before returning.\n\n  if (ts.dataByteLength < RootStruct._capnp.size.dataByteLength || ts.pointerLength < RootStruct._capnp.size.pointerLength) {\n    trace('need to resize root struct %s', root);\n    struct_1.resize(RootStruct._capnp.size, root);\n  }\n\n  return root;\n}\n\nexports.getRoot = getRoot;\n\nfunction getSegment(id, m) {\n  var segmentLength = m._capnp.segments.length;\n\n  if (id === 0 && segmentLength === 0) {\n    // Segment zero is special. If we have no segments in the arena we'll want to allocate a new one and leave room\n    // for the root pointer.\n    var arenaSegments = arena_1.Arena.getNumSegments(m._capnp.arena);\n\n    if (arenaSegments === 0) {\n      allocateSegment(constants_1.DEFAULT_BUFFER_SIZE, m);\n    } else {\n      // Okay, the arena already has a buffer we can use. This is totally fine.\n      m._capnp.segments[0] = new segment_1.Segment(0, m, arena_1.Arena.getBuffer(0, m._capnp.arena));\n    }\n\n    if (!m._capnp.segments[0].hasCapacity(8)) throw new Error(errors_1.MSG_SEGMENT_TOO_SMALL); // This will leave room for the root pointer.\n\n    m._capnp.segments[0].allocate(8);\n\n    return m._capnp.segments[0];\n  }\n\n  if (id < 0 || id >= segmentLength) throw new Error(util_1.format(errors_1.MSG_SEGMENT_OUT_OF_BOUNDS, id, m));\n  return m._capnp.segments[id];\n}\n\nexports.getSegment = getSegment;\n\nfunction initRoot(RootStruct, m) {\n  var root = new RootStruct(m.getSegment(0), 0);\n  struct_1.initStruct(RootStruct._capnp.size, root);\n  trace('Initialized root pointer %s for %s.', root, m);\n  return root;\n}\n\nexports.initRoot = initRoot;\n\nfunction toArrayBuffer(m) {\n  var streamFrame = getStreamFrame(m); // Make sure the first segment is allocated.\n\n  if (m._capnp.segments.length === 0) getSegment(0, m);\n  var segments = m._capnp.segments; // Add space for the stream framing.\n\n  var totalLength = streamFrame.byteLength + segments.reduce(function (l, s) {\n    return l + util_1.padToWord(s.byteLength);\n  }, 0);\n  var out = new Uint8Array(new ArrayBuffer(totalLength));\n  var o = streamFrame.byteLength;\n  out.set(new Uint8Array(streamFrame));\n  segments.forEach(function (s) {\n    var segmentLength = util_1.padToWord(s.byteLength);\n    out.set(new Uint8Array(s.buffer, 0, segmentLength), o);\n    o += segmentLength;\n  });\n  return out.buffer;\n}\n\nexports.toArrayBuffer = toArrayBuffer;\n\nfunction toPackedArrayBuffer(m) {\n  var streamFrame = packing_1.pack(getStreamFrame(m)); // Make sure the first segment is allocated.\n\n  if (m._capnp.segments.length === 0) m.getSegment(0); // NOTE: A copy operation can be avoided here if we capture the intermediate array and use that directly in the copy\n  // loop below, rather than have `pack()` copy it to an ArrayBuffer just to have to copy it again later. If the\n  // intermediate array can be avoided altogether that's even better!\n\n  var segments = m._capnp.segments.map(function (s) {\n    return packing_1.pack(s.buffer, 0, util_1.padToWord(s.byteLength));\n  });\n\n  var totalLength = streamFrame.byteLength + segments.reduce(function (l, s) {\n    return l + s.byteLength;\n  }, 0);\n  var out = new Uint8Array(new ArrayBuffer(totalLength));\n  var o = streamFrame.byteLength;\n  out.set(new Uint8Array(streamFrame));\n  segments.forEach(function (s) {\n    out.set(new Uint8Array(s), o);\n    o += s.byteLength;\n  });\n  return out.buffer;\n}\n\nexports.toPackedArrayBuffer = toPackedArrayBuffer;\n\nfunction getStreamFrame(m) {\n  var length = m._capnp.segments.length;\n\n  if (length === 0) {\n    // Don't bother allocating the first segment, just return a single zero word for the frame header.\n    return new Float64Array(1).buffer;\n  }\n\n  var frameLength = 4 + length * 4 + (1 - length % 2) * 4;\n  var out = new DataView(new ArrayBuffer(frameLength));\n  trace('Writing message stream frame with segment count: %d.', length);\n  out.setUint32(0, length - 1, true);\n\n  m._capnp.segments.forEach(function (s, i) {\n    trace('Message segment %d word count: %d.', s.id, s.byteLength / 8);\n    out.setUint32(i * 4 + 4, s.byteLength / 8, true);\n  });\n\n  return out.buffer;\n}\n\nexports.getStreamFrame = getStreamFrame;","map":{"version":3,"sources":["serialization/message.ts"],"names":[],"mappings":"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","sourceRoot":"../../src","sourcesContent":["\"use strict\";\n/**\n * @author jdiaz5513\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar debug_1 = require(\"debug\");\nvar constants_1 = require(\"../constants\");\nvar errors_1 = require(\"../errors\");\nvar util_1 = require(\"../util\");\nvar arena_1 = require(\"./arena\");\nvar packing_1 = require(\"./packing\");\nvar pointers_1 = require(\"./pointers\");\nvar segment_1 = require(\"./segment\");\nvar pointer_1 = require(\"./pointers/pointer\");\nvar struct_1 = require(\"./pointers/struct\");\nvar trace = debug_1.default('capnp:message');\ntrace('load');\nvar Message = /** @class */ (function () {\n    /**\n     * A Cap'n Proto message.\n     *\n     * SECURITY WARNING: In nodejs do not pass a Buffer's internal array buffer into this constructor. Pass the buffer\n     * directly and everything will be fine. If not, your message will potentially be initialized with random memory\n     * contents!\n     *\n     * The constructor method creates a new Message, optionally using a provided arena for segment allocation, or a buffer\n     * to read from.\n     *\n     * @constructor {Message}\n     *\n     * @param {AnyArena|ArrayBufferView|ArrayBuffer} [src] The source for the message.\n     * A value of `undefined` will cause the message to initialize with a single segment arena only big enough for the\n     * root pointer; it will expand as you go. This is a reasonable choice for most messages.\n     *\n     * Passing an arena will cause the message to use that arena for its segment allocation. Contents will be accepted\n     * as-is.\n     *\n     * Passing an array buffer view (like `DataView`, `Uint8Array` or `Buffer`) will create a **copy** of the source\n     * buffer; beware of the potential performance cost!\n     *\n     * @param {boolean} [packed] Whether or not the message is packed. If `true` (the default), the message will be\n     * unpacked.\n     *\n     * @param {boolean} [singleSegment] If true, `src` will be treated as a message consisting of a single segment without\n     * a framing header.\n     *\n     */\n    function Message(src, packed, singleSegment) {\n        if (packed === void 0) { packed = true; }\n        if (singleSegment === void 0) { singleSegment = false; }\n        this._capnp = initMessage(src, packed, singleSegment);\n        if (src && !isAnyArena(src))\n            preallocateSegments(this);\n        trace('new %s', this);\n    }\n    Message.prototype.allocateSegment = function (byteLength) { return allocateSegment(byteLength, this); };\n    /**\n     * Create a pretty-printed string dump of this message; incredibly useful for debugging.\n     *\n     * WARNING: Do not call this method on large messages!\n     *\n     * @returns {string} A big steaming pile of pretty hex digits.\n     */\n    Message.prototype.dump = function () { return dump(this); };\n    /**\n     * Get a struct pointer for the root of this message. This is primarily used when reading a message; it will not\n     * overwrite existing data.\n     *\n     * @template T\n     * @param {StructCtor<T>} RootStruct The struct type to use as the root.\n     * @returns {T} A struct representing the root of the message.\n     */\n    Message.prototype.getRoot = function (RootStruct) { return getRoot(RootStruct, this); };\n    /**\n     * Get a segment by its id.\n     *\n     * This will lazily allocate the first segment if it doesn't already exist.\n     *\n     * @param {number} id The segment id.\n     * @returns {Segment} The requested segment.\n     */\n    Message.prototype.getSegment = function (id) { return getSegment(id, this); };\n    /**\n     * Initialize a new message using the provided struct type as the root.\n     *\n     * @template T\n     * @param {StructCtor<T>} RootStruct The struct type to use as the root.\n     * @returns {T} An initialized struct pointing to the root of the message.\n     */\n    Message.prototype.initRoot = function (RootStruct) { return initRoot(RootStruct, this); };\n    /**\n     * Combine the contents of this message's segments into a single array buffer and prepend a stream framing header\n     * containing information about the following segment data.\n     *\n     * @returns {ArrayBuffer} An ArrayBuffer with the contents of this message.\n     */\n    Message.prototype.toArrayBuffer = function () { return toArrayBuffer(this); };\n    /**\n     * Like `toArrayBuffer()`, but also applies the packing algorithm to the output. This is typically what you want to\n     * use if you're sending the message over a network link or other slow I/O interface where size matters.\n     *\n     * @returns {ArrayBuffer} A packed message.\n     */\n    Message.prototype.toPackedArrayBuffer = function () { return toPackedArrayBuffer(this); };\n    Message.prototype.toString = function () { return \"Message_arena:\" + this._capnp.arena; };\n    Message.allocateSegment = allocateSegment;\n    Message.dump = dump;\n    Message.getRoot = getRoot;\n    Message.getSegment = getSegment;\n    Message.initRoot = initRoot;\n    Message.toArrayBuffer = toArrayBuffer;\n    Message.toPackedArrayBuffer = toPackedArrayBuffer;\n    return Message;\n}());\nexports.Message = Message;\nfunction initMessage(src, packed, singleSegment) {\n    if (packed === void 0) { packed = true; }\n    if (singleSegment === void 0) { singleSegment = false; }\n    if (src === undefined) {\n        return { arena: new arena_1.SingleSegmentArena(), segments: [], traversalLimit: constants_1.DEFAULT_TRAVERSE_LIMIT };\n    }\n    if (isAnyArena(src))\n        return { arena: src, segments: [], traversalLimit: constants_1.DEFAULT_TRAVERSE_LIMIT };\n    var buf = src;\n    if (isArrayBufferView(buf))\n        buf = buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);\n    if (packed)\n        buf = packing_1.unpack(buf);\n    if (singleSegment) {\n        return {\n            arena: new arena_1.SingleSegmentArena(buf),\n            segments: [],\n            traversalLimit: constants_1.DEFAULT_TRAVERSE_LIMIT,\n        };\n    }\n    return {\n        arena: new arena_1.MultiSegmentArena(getFramedSegments(buf)),\n        segments: [],\n        traversalLimit: constants_1.DEFAULT_TRAVERSE_LIMIT,\n    };\n}\nexports.initMessage = initMessage;\n/**\n * Given an _unpacked_ message with a segment framing header, this will generate an ArrayBuffer for each segment in\n * the message.\n *\n * This method is not typically called directly, but can be useful in certain cases.\n *\n * @static\n * @param {ArrayBuffer} message An unpacked message with a framing header.\n * @returns {ArrayBuffer[]} An array of buffers containing the segment data.\n */\nfunction getFramedSegments(message) {\n    var dv = new DataView(message);\n    var segmentCount = dv.getUint32(0, true) + 1;\n    var segments = new Array(segmentCount);\n    trace('reading %d framed segments from stream', segmentCount);\n    var byteOffset = 4 + segmentCount * 4;\n    byteOffset += byteOffset % 8;\n    if (byteOffset + segmentCount * 4 > message.byteLength)\n        throw new Error(errors_1.MSG_INVALID_FRAME_HEADER);\n    for (var i = 0; i < segmentCount; i++) {\n        var byteLength = dv.getUint32(4 + i * 4, true) * 8;\n        if (byteOffset + byteLength > message.byteLength)\n            throw new Error(errors_1.MSG_INVALID_FRAME_HEADER);\n        segments[i] = message.slice(byteOffset, byteOffset + byteLength);\n        byteOffset += byteLength;\n    }\n    return segments;\n}\nexports.getFramedSegments = getFramedSegments;\n/**\n * This method is called on messages that were constructed with existing data to prepopulate the segments array with\n * everything we can find in the arena. Each segment will have it's `byteLength` set to the size of its buffer.\n *\n * Technically speaking, the message's segments will be \"full\" after calling this function. Calling this on your own\n * may void your warranty.\n *\n * @param {Message} m The message to allocate.\n * @returns {void}\n */\nfunction preallocateSegments(m) {\n    var numSegments = arena_1.Arena.getNumSegments(m._capnp.arena);\n    if (numSegments < 1)\n        throw new Error(errors_1.MSG_NO_SEGMENTS_IN_ARENA);\n    m._capnp.segments = new Array(numSegments);\n    for (var i = 0; i < numSegments; i++) {\n        // Set up each segment so that they're fully allocated to the extents of the existing buffers.\n        var buffer = arena_1.Arena.getBuffer(i, m._capnp.arena);\n        var segment = new segment_1.Segment(i, m, buffer, buffer.byteLength);\n        m._capnp.segments[i] = segment;\n    }\n}\nexports.preallocateSegments = preallocateSegments;\nfunction isArrayBufferView(src) {\n    return src.byteOffset !== undefined;\n}\nfunction isAnyArena(o) {\n    return o.kind !== undefined;\n}\nfunction allocateSegment(byteLength, m) {\n    trace('allocating %x bytes for %s', byteLength, m);\n    var res = arena_1.Arena.allocate(byteLength, m._capnp.segments, m._capnp.arena);\n    var s;\n    if (res.id === m._capnp.segments.length) {\n        // Note how we're only allowing new segments in if they're exactly the next one in the array. There is no logical\n        // reason for segments to be created out of order.\n        s = new segment_1.Segment(res.id, m, res.buffer);\n        trace('adding new segment %s', s);\n        m._capnp.segments.push(s);\n    }\n    else if (res.id < 0 || res.id > m._capnp.segments.length) {\n        throw new Error(util_1.format(errors_1.MSG_SEGMENT_OUT_OF_BOUNDS, res.id, m));\n    }\n    else {\n        s = m._capnp.segments[res.id];\n        trace('replacing segment %s with buffer (len:%d)', s, res.buffer.byteLength);\n        s.replaceBuffer(res.buffer);\n    }\n    return s;\n}\nexports.allocateSegment = allocateSegment;\nfunction dump(m) {\n    var r = '';\n    if (m._capnp.segments.length === 0)\n        return '================\\nNo Segments\\n================\\n';\n    for (var i = 0; i < m._capnp.segments.length; i++) {\n        r += \"================\\nSegment #\" + i + \"\\n================\\n\";\n        var _a = m._capnp.segments[i], buffer = _a.buffer, byteLength = _a.byteLength;\n        var b = new Uint8Array(buffer, 0, byteLength);\n        r += util_1.dumpBuffer(b);\n    }\n    return r;\n}\nexports.dump = dump;\nfunction getRoot(RootStruct, m) {\n    var root = new RootStruct(m.getSegment(0), 0);\n    pointer_1.validate(pointers_1.PointerType.STRUCT, root);\n    var ts = pointer_1.getTargetStructSize(root);\n    // Make sure the underlying pointer is actually big enough to hold the data and pointers as specified in the schema.\n    // If not a shallow copy of the struct contents needs to be made before returning.\n    if (ts.dataByteLength < RootStruct._capnp.size.dataByteLength\n        || ts.pointerLength < RootStruct._capnp.size.pointerLength) {\n        trace('need to resize root struct %s', root);\n        struct_1.resize(RootStruct._capnp.size, root);\n    }\n    return root;\n}\nexports.getRoot = getRoot;\nfunction getSegment(id, m) {\n    var segmentLength = m._capnp.segments.length;\n    if (id === 0 && segmentLength === 0) {\n        // Segment zero is special. If we have no segments in the arena we'll want to allocate a new one and leave room\n        // for the root pointer.\n        var arenaSegments = arena_1.Arena.getNumSegments(m._capnp.arena);\n        if (arenaSegments === 0) {\n            allocateSegment(constants_1.DEFAULT_BUFFER_SIZE, m);\n        }\n        else {\n            // Okay, the arena already has a buffer we can use. This is totally fine.\n            m._capnp.segments[0] = new segment_1.Segment(0, m, arena_1.Arena.getBuffer(0, m._capnp.arena));\n        }\n        if (!m._capnp.segments[0].hasCapacity(8))\n            throw new Error(errors_1.MSG_SEGMENT_TOO_SMALL);\n        // This will leave room for the root pointer.\n        m._capnp.segments[0].allocate(8);\n        return m._capnp.segments[0];\n    }\n    if (id < 0 || id >= segmentLength)\n        throw new Error(util_1.format(errors_1.MSG_SEGMENT_OUT_OF_BOUNDS, id, m));\n    return m._capnp.segments[id];\n}\nexports.getSegment = getSegment;\nfunction initRoot(RootStruct, m) {\n    var root = new RootStruct(m.getSegment(0), 0);\n    struct_1.initStruct(RootStruct._capnp.size, root);\n    trace('Initialized root pointer %s for %s.', root, m);\n    return root;\n}\nexports.initRoot = initRoot;\nfunction toArrayBuffer(m) {\n    var streamFrame = getStreamFrame(m);\n    // Make sure the first segment is allocated.\n    if (m._capnp.segments.length === 0)\n        getSegment(0, m);\n    var segments = m._capnp.segments;\n    // Add space for the stream framing.\n    var totalLength = streamFrame.byteLength + segments.reduce(function (l, s) { return l + util_1.padToWord(s.byteLength); }, 0);\n    var out = new Uint8Array(new ArrayBuffer(totalLength));\n    var o = streamFrame.byteLength;\n    out.set(new Uint8Array(streamFrame));\n    segments.forEach(function (s) {\n        var segmentLength = util_1.padToWord(s.byteLength);\n        out.set(new Uint8Array(s.buffer, 0, segmentLength), o);\n        o += segmentLength;\n    });\n    return out.buffer;\n}\nexports.toArrayBuffer = toArrayBuffer;\nfunction toPackedArrayBuffer(m) {\n    var streamFrame = packing_1.pack(getStreamFrame(m));\n    // Make sure the first segment is allocated.\n    if (m._capnp.segments.length === 0)\n        m.getSegment(0);\n    // NOTE: A copy operation can be avoided here if we capture the intermediate array and use that directly in the copy\n    // loop below, rather than have `pack()` copy it to an ArrayBuffer just to have to copy it again later. If the\n    // intermediate array can be avoided altogether that's even better!\n    var segments = m._capnp.segments.map(function (s) { return packing_1.pack(s.buffer, 0, util_1.padToWord(s.byteLength)); });\n    var totalLength = streamFrame.byteLength + segments.reduce(function (l, s) { return l + s.byteLength; }, 0);\n    var out = new Uint8Array(new ArrayBuffer(totalLength));\n    var o = streamFrame.byteLength;\n    out.set(new Uint8Array(streamFrame));\n    segments.forEach(function (s) {\n        out.set(new Uint8Array(s), o);\n        o += s.byteLength;\n    });\n    return out.buffer;\n}\nexports.toPackedArrayBuffer = toPackedArrayBuffer;\nfunction getStreamFrame(m) {\n    var length = m._capnp.segments.length;\n    if (length === 0) {\n        // Don't bother allocating the first segment, just return a single zero word for the frame header.\n        return new Float64Array(1).buffer;\n    }\n    var frameLength = 4 + length * 4 + (1 - length % 2) * 4;\n    var out = new DataView(new ArrayBuffer(frameLength));\n    trace('Writing message stream frame with segment count: %d.', length);\n    out.setUint32(0, length - 1, true);\n    m._capnp.segments.forEach(function (s, i) {\n        trace('Message segment %d word count: %d.', s.id, s.byteLength / 8);\n        out.setUint32(i * 4 + 4, s.byteLength / 8, true);\n    });\n    return out.buffer;\n}\nexports.getStreamFrame = getStreamFrame;\n\n//# sourceMappingURL=message.js.map\n"]},"metadata":{},"sourceType":"script"}