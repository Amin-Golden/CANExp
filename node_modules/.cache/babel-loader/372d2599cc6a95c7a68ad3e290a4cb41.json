{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar debug_1 = require(\"debug\");\n\nvar errors_1 = require(\"../../errors\");\n\nvar util_1 = require(\"../../util\");\n\nvar list_element_size_1 = require(\"../list-element-size\");\n\nvar object_size_1 = require(\"../object-size\");\n\nvar pointer_1 = require(\"./pointer\");\n\nvar pointer_type_1 = require(\"./pointer-type\");\n\nvar trace = debug_1.default('capnp:orphan');\ntrace('load'); // Technically speaking this class doesn't need to be generic, but the extra type checking enforced by this helps to\n// make sure you don't accidentally adopt a pointer of the wrong type.\n\n/**\n * An orphaned pointer. This object itself is technically a pointer to the original pointer's content, which was left\n * untouched in its original message. The original pointer data is encoded as attributes on the Orphan object, ready to\n * be reconstructed once another pointer is ready to adopt it.\n *\n * @export\n * @class Orphan\n * @extends {Pointer}\n * @template T\n */\n\nvar Orphan =\n/** @class */\nfunction () {\n  function Orphan(src) {\n    var c = pointer_1.getContent(src);\n    this.segment = c.segment;\n    this.byteOffset = c.byteOffset;\n    this._capnp = {}; // Read vital info from the src pointer so we can reconstruct it during adoption.\n\n    this._capnp.type = pointer_1.getTargetPointerType(src);\n\n    switch (this._capnp.type) {\n      case pointer_type_1.PointerType.STRUCT:\n        this._capnp.size = pointer_1.getTargetStructSize(src);\n        break;\n\n      case pointer_type_1.PointerType.LIST:\n        this._capnp.length = pointer_1.getTargetListLength(src);\n        this._capnp.elementSize = pointer_1.getTargetListElementSize(src);\n        if (this._capnp.elementSize === list_element_size_1.ListElementSize.COMPOSITE) this._capnp.size = pointer_1.getTargetCompositeListSize(src);\n        break;\n\n      case pointer_type_1.PointerType.OTHER:\n        this._capnp.capId = pointer_1.getCapabilityId(src);\n        break;\n\n      default:\n        // COVERAGE: Unreachable code.\n\n        /* istanbul ignore next */\n        throw new Error(errors_1.PTR_INVALID_POINTER_TYPE);\n    } // Zero out the source pointer (but not the contents!).\n\n\n    pointer_1.erasePointer(src);\n  }\n  /**\n   * Adopt (move) this orphan into the target pointer location. This will allocate far pointers in `dst` as needed.\n   *\n   * @param {T} dst The destination pointer.\n   * @returns {void}\n   */\n\n\n  Orphan.prototype._moveTo = function (dst) {\n    if (this._capnp === undefined) throw new Error(util_1.format(errors_1.PTR_ALREADY_ADOPTED, this)); // TODO: Implement copy semantics when this happens.\n\n    if (this.segment.message !== dst.segment.message) throw new Error(util_1.format(errors_1.PTR_ADOPT_WRONG_MESSAGE, this, dst)); // Recursively wipe out the destination pointer first.\n\n    pointer_1.erase(dst);\n    var res = pointer_1.initPointer(this.segment, this.byteOffset, dst);\n\n    switch (this._capnp.type) {\n      case pointer_type_1.PointerType.STRUCT:\n        pointer_1.setStructPointer(res.offsetWords, this._capnp.size, res.pointer);\n        break;\n\n      case pointer_type_1.PointerType.LIST:\n        var offsetWords = res.offsetWords;\n        if (this._capnp.elementSize === list_element_size_1.ListElementSize.COMPOSITE) offsetWords--; // The tag word gets skipped.\n\n        pointer_1.setListPointer(offsetWords, this._capnp.elementSize, this._capnp.length, res.pointer, this._capnp.size);\n        break;\n\n      case pointer_type_1.PointerType.OTHER:\n        pointer_1.setInterfacePointer(this._capnp.capId, res.pointer);\n        break;\n\n      /* istanbul ignore next */\n\n      default:\n        throw new Error(errors_1.PTR_INVALID_POINTER_TYPE);\n    }\n\n    this._capnp = undefined;\n  };\n\n  Orphan.prototype.dispose = function () {\n    // FIXME: Should this throw?\n    if (this._capnp === undefined) {\n      trace('not disposing an already disposed orphan', this);\n      return;\n    }\n\n    switch (this._capnp.type) {\n      case pointer_type_1.PointerType.STRUCT:\n        this.segment.fillZeroWords(this.byteOffset, object_size_1.getWordLength(this._capnp.size));\n        break;\n\n      case pointer_type_1.PointerType.LIST:\n        var byteLength = pointer_1.getListByteLength(this._capnp.elementSize, this._capnp.length, this._capnp.size);\n        this.segment.fillZeroWords(this.byteOffset, byteLength);\n        break;\n\n      default:\n        // Other pointer types don't actually have any content.\n        break;\n    }\n\n    this._capnp = undefined;\n  };\n\n  Orphan.prototype.toString = function () {\n    return util_1.format('Orphan_%d@%a,type:%s', this.segment.id, this.byteOffset, this._capnp && this._capnp.type);\n  };\n\n  return Orphan;\n}();\n\nexports.Orphan = Orphan;","map":{"version":3,"sources":["serialization/pointers/orphan.ts"],"names":[],"mappings":"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","sourceRoot":"../../../src","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar debug_1 = require(\"debug\");\nvar errors_1 = require(\"../../errors\");\nvar util_1 = require(\"../../util\");\nvar list_element_size_1 = require(\"../list-element-size\");\nvar object_size_1 = require(\"../object-size\");\nvar pointer_1 = require(\"./pointer\");\nvar pointer_type_1 = require(\"./pointer-type\");\nvar trace = debug_1.default('capnp:orphan');\ntrace('load');\n// Technically speaking this class doesn't need to be generic, but the extra type checking enforced by this helps to\n// make sure you don't accidentally adopt a pointer of the wrong type.\n/**\n * An orphaned pointer. This object itself is technically a pointer to the original pointer's content, which was left\n * untouched in its original message. The original pointer data is encoded as attributes on the Orphan object, ready to\n * be reconstructed once another pointer is ready to adopt it.\n *\n * @export\n * @class Orphan\n * @extends {Pointer}\n * @template T\n */\nvar Orphan = /** @class */ (function () {\n    function Orphan(src) {\n        var c = pointer_1.getContent(src);\n        this.segment = c.segment;\n        this.byteOffset = c.byteOffset;\n        this._capnp = {};\n        // Read vital info from the src pointer so we can reconstruct it during adoption.\n        this._capnp.type = pointer_1.getTargetPointerType(src);\n        switch (this._capnp.type) {\n            case pointer_type_1.PointerType.STRUCT:\n                this._capnp.size = pointer_1.getTargetStructSize(src);\n                break;\n            case pointer_type_1.PointerType.LIST:\n                this._capnp.length = pointer_1.getTargetListLength(src);\n                this._capnp.elementSize = pointer_1.getTargetListElementSize(src);\n                if (this._capnp.elementSize === list_element_size_1.ListElementSize.COMPOSITE)\n                    this._capnp.size = pointer_1.getTargetCompositeListSize(src);\n                break;\n            case pointer_type_1.PointerType.OTHER:\n                this._capnp.capId = pointer_1.getCapabilityId(src);\n                break;\n            default:\n                // COVERAGE: Unreachable code.\n                /* istanbul ignore next */\n                throw new Error(errors_1.PTR_INVALID_POINTER_TYPE);\n        }\n        // Zero out the source pointer (but not the contents!).\n        pointer_1.erasePointer(src);\n    }\n    /**\n     * Adopt (move) this orphan into the target pointer location. This will allocate far pointers in `dst` as needed.\n     *\n     * @param {T} dst The destination pointer.\n     * @returns {void}\n     */\n    Orphan.prototype._moveTo = function (dst) {\n        if (this._capnp === undefined)\n            throw new Error(util_1.format(errors_1.PTR_ALREADY_ADOPTED, this));\n        // TODO: Implement copy semantics when this happens.\n        if (this.segment.message !== dst.segment.message)\n            throw new Error(util_1.format(errors_1.PTR_ADOPT_WRONG_MESSAGE, this, dst));\n        // Recursively wipe out the destination pointer first.\n        pointer_1.erase(dst);\n        var res = pointer_1.initPointer(this.segment, this.byteOffset, dst);\n        switch (this._capnp.type) {\n            case pointer_type_1.PointerType.STRUCT:\n                pointer_1.setStructPointer(res.offsetWords, this._capnp.size, res.pointer);\n                break;\n            case pointer_type_1.PointerType.LIST:\n                var offsetWords = res.offsetWords;\n                if (this._capnp.elementSize === list_element_size_1.ListElementSize.COMPOSITE)\n                    offsetWords--; // The tag word gets skipped.\n                pointer_1.setListPointer(offsetWords, this._capnp.elementSize, this._capnp.length, res.pointer, this._capnp.size);\n                break;\n            case pointer_type_1.PointerType.OTHER:\n                pointer_1.setInterfacePointer(this._capnp.capId, res.pointer);\n                break;\n            /* istanbul ignore next */\n            default:\n                throw new Error(errors_1.PTR_INVALID_POINTER_TYPE);\n        }\n        this._capnp = undefined;\n    };\n    Orphan.prototype.dispose = function () {\n        // FIXME: Should this throw?\n        if (this._capnp === undefined) {\n            trace('not disposing an already disposed orphan', this);\n            return;\n        }\n        switch (this._capnp.type) {\n            case pointer_type_1.PointerType.STRUCT:\n                this.segment.fillZeroWords(this.byteOffset, object_size_1.getWordLength(this._capnp.size));\n                break;\n            case pointer_type_1.PointerType.LIST:\n                var byteLength = pointer_1.getListByteLength(this._capnp.elementSize, this._capnp.length, this._capnp.size);\n                this.segment.fillZeroWords(this.byteOffset, byteLength);\n                break;\n            default:\n                // Other pointer types don't actually have any content.\n                break;\n        }\n        this._capnp = undefined;\n    };\n    Orphan.prototype.toString = function () {\n        return util_1.format('Orphan_%d@%a,type:%s', this.segment.id, this.byteOffset, this._capnp && this._capnp.type);\n    };\n    return Orphan;\n}());\nexports.Orphan = Orphan;\n\n//# sourceMappingURL=orphan.js.map\n"]},"metadata":{},"sourceType":"script"}