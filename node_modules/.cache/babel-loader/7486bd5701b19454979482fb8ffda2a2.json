{"ast":null,"code":"/* global location WritableStream ReadableStream define MouseEvent MessageChannel TransformStream */\n;\n\n((name, definition) => {\n  typeof module !== 'undefined' ? module.exports = definition() : typeof define === 'function' && typeof define.amd === 'object' ? define(definition) : this[name] = definition();\n})('streamSaver', () => {\n  'use strict';\n\n  const secure = location.protocol === 'https:' || location.protocol === 'chrome-extension:' || location.hostname === 'localhost';\n  let iframe;\n  let loaded;\n  let transfarableSupport = false;\n  let streamSaver = {\n    createWriteStream,\n    supported: false,\n    version: {\n      full: '1.2.0',\n      major: 1,\n      minor: 2,\n      dot: 0\n    }\n  };\n  streamSaver.mitm = 'https://jimmywarting.github.io/StreamSaver.js/mitm.html?version=' + streamSaver.version.full;\n\n  try {\n    // Some browser has it but ain't allowed to construct a stream yet\n    streamSaver.supported = 'serviceWorker' in navigator && !!new ReadableStream() && !!new WritableStream();\n  } catch (err) {}\n\n  try {\n    const {\n      readable\n    } = new TransformStream();\n    const mc = new MessageChannel();\n    mc.port1.postMessage(readable, [readable]);\n    mc.port1.close();\n    mc.port2.close();\n    transfarableSupport = readable.locked === true;\n  } catch (err) {// Was first enabled in chrome v73\n  }\n\n  function createWriteStream(filename, queuingStrategy, size) {\n    // normalize arguments\n    if (Number.isFinite(queuingStrategy)) {\n      [size, queuingStrategy] = [queuingStrategy, size];\n    }\n\n    let channel = new MessageChannel();\n    let popup;\n\n    let setupChannel = readableStream => new Promise(resolve => {\n      const args = [{\n        filename,\n        size\n      }, '*', [channel.port2]]; // Pass along transfarable stream\n\n      if (readableStream) {\n        args[0].readableStream = readableStream;\n        args[2].push(readableStream);\n      }\n\n      channel.port1.onmessage = evt => {\n        // Service worker sent us a link from where\n        // we recive the readable link (stream)\n        if (evt.data.download) {\n          resolve(); // Signal that the writestream are ready to recive data\n\n          if (!secure) popup.close(); // don't need the popup any longer\n\n          if (window.chrome && chrome.extension && chrome.extension.getBackgroundPage && chrome.extension.getBackgroundPage() === window) {\n            chrome.tabs.create({\n              url: evt.data.download,\n              active: false\n            });\n          } else {\n            window.location = evt.data.download;\n          } // Cleanup\n\n\n          if (readableStream) {\n            // We don't need postMessages now when stream are transferable\n            channel.port1.close();\n            channel.port2.close();\n          }\n\n          channel.port1.onmessage = null;\n        }\n      };\n\n      if (secure && !iframe) {\n        iframe = document.createElement('iframe');\n        iframe.src = streamSaver.mitm;\n        iframe.hidden = true;\n        document.body.appendChild(iframe);\n      }\n\n      if (secure && !loaded) {\n        let fn;\n        iframe.addEventListener('load', fn = () => {\n          loaded = true;\n          iframe.removeEventListener('load', fn);\n          iframe.contentWindow.postMessage(...args);\n        });\n      }\n\n      if (secure && loaded) {\n        iframe.contentWindow.postMessage(...args);\n      }\n\n      if (!secure) {\n        popup = window.open(streamSaver.mitm, Math.random());\n\n        let onready = evt => {\n          if (evt.source === popup) {\n            popup.postMessage(...args);\n            window.removeEventListener('message', onready);\n          }\n        }; // Another problem that cross origin don't allow is scripting\n        // so popup.onload() don't work but postMessage still dose\n        // work cross origin\n\n\n        window.addEventListener('message', onready);\n      }\n    });\n\n    if (transfarableSupport) {\n      const ts = new TransformStream({\n        start() {\n          return new Promise(resolve => setTimeout(() => setupChannel(ts.readable).then(resolve)));\n        }\n\n      }, queuingStrategy);\n      return ts.writable;\n    }\n\n    return new WritableStream({\n      start() {\n        // is called immediately, and should perform any actions\n        // necessary to acquire access to the underlying sink.\n        // If this process is asynchronous, it can return a promise\n        // to signal success or failure.\n        return setupChannel();\n      },\n\n      write(chunk) {\n        // is called when a new chunk of data is ready to be written\n        // to the underlying sink. It can return a promise to signal\n        // success or failure of the write operation. The stream\n        // implementation guarantees that this method will be called\n        // only after previous writes have succeeded, and never after\n        // close or abort is called.\n        // TODO: Kind of important that service worker respond back when\n        // it has been written. Otherwise we can't handle backpressure\n        // EDIT: Transfarable streams solvs this...\n        channel.port1.postMessage(chunk);\n      },\n\n      close() {\n        channel.port1.postMessage('end');\n      },\n\n      abort() {\n        channel.port1.postMessage('abort');\n      }\n\n    }, queuingStrategy);\n  }\n\n  return streamSaver;\n});","map":{"version":3,"sources":["/home/amax/Autoro/cabana/node_modules/streamsaver/StreamSaver.js"],"names":["name","definition","module","exports","define","amd","secure","location","protocol","hostname","iframe","loaded","transfarableSupport","streamSaver","createWriteStream","supported","version","full","major","minor","dot","mitm","navigator","ReadableStream","WritableStream","err","readable","TransformStream","mc","MessageChannel","port1","postMessage","close","port2","locked","filename","queuingStrategy","size","Number","isFinite","channel","popup","setupChannel","readableStream","Promise","resolve","args","push","onmessage","evt","data","download","window","chrome","extension","getBackgroundPage","tabs","create","url","active","document","createElement","src","hidden","body","appendChild","fn","addEventListener","removeEventListener","contentWindow","open","Math","random","onready","source","ts","start","setTimeout","then","writable","write","chunk","abort"],"mappings":"AAAA;AACA;;AAAC,CAAC,CAACA,IAAD,EAAOC,UAAP,KAAsB;AACtB,SAAOC,MAAP,KAAkB,WAAlB,GACIA,MAAM,CAACC,OAAP,GAAiBF,UAAU,EAD/B,GAEI,OAAOG,MAAP,KAAkB,UAAlB,IAAgC,OAAOA,MAAM,CAACC,GAAd,KAAsB,QAAtD,GACED,MAAM,CAACH,UAAD,CADR,GAEE,KAAKD,IAAL,IAAaC,UAAU,EAJ7B;AAKD,CANA,EAME,aANF,EAMiB,MAAM;AACtB;;AAEA,QAAMK,MAAM,GAAGC,QAAQ,CAACC,QAAT,KAAsB,QAAtB,IACAD,QAAQ,CAACC,QAAT,KAAsB,mBADtB,IAEAD,QAAQ,CAACE,QAAT,KAAsB,WAFrC;AAGA,MAAIC,MAAJ;AACA,MAAIC,MAAJ;AACA,MAAIC,mBAAmB,GAAG,KAA1B;AACA,MAAIC,WAAW,GAAG;AAChBC,IAAAA,iBADgB;AAEhBC,IAAAA,SAAS,EAAE,KAFK;AAGhBC,IAAAA,OAAO,EAAE;AACPC,MAAAA,IAAI,EAAE,OADC;AAEPC,MAAAA,KAAK,EAAE,CAFA;AAGPC,MAAAA,KAAK,EAAE,CAHA;AAIPC,MAAAA,GAAG,EAAE;AAJE;AAHO,GAAlB;AAWAP,EAAAA,WAAW,CAACQ,IAAZ,GAAmB,qEACjBR,WAAW,CAACG,OAAZ,CAAoBC,IADtB;;AAGA,MAAI;AACF;AACAJ,IAAAA,WAAW,CAACE,SAAZ,GAAwB,mBAAmBO,SAAnB,IAAgC,CAAC,CAAC,IAAIC,cAAJ,EAAlC,IAA0D,CAAC,CAAC,IAAIC,cAAJ,EAApF;AACD,GAHD,CAGE,OAAOC,GAAP,EAAY,CAAE;;AAEhB,MAAI;AACF,UAAM;AAAEC,MAAAA;AAAF,QAAe,IAAIC,eAAJ,EAArB;AACA,UAAMC,EAAE,GAAG,IAAIC,cAAJ,EAAX;AACAD,IAAAA,EAAE,CAACE,KAAH,CAASC,WAAT,CAAqBL,QAArB,EAA+B,CAACA,QAAD,CAA/B;AACAE,IAAAA,EAAE,CAACE,KAAH,CAASE,KAAT;AACAJ,IAAAA,EAAE,CAACK,KAAH,CAASD,KAAT;AACApB,IAAAA,mBAAmB,GAAGc,QAAQ,CAACQ,MAAT,KAAoB,IAA1C;AACD,GAPD,CAOE,OAAOT,GAAP,EAAY,CACZ;AACD;;AAED,WAASX,iBAAT,CAA4BqB,QAA5B,EAAsCC,eAAtC,EAAuDC,IAAvD,EAA6D;AAC3D;AACA,QAAIC,MAAM,CAACC,QAAP,CAAgBH,eAAhB,CAAJ,EAAsC;AACpC,OAACC,IAAD,EAAOD,eAAP,IAA0B,CAACA,eAAD,EAAkBC,IAAlB,CAA1B;AACD;;AAED,QAAIG,OAAO,GAAG,IAAIX,cAAJ,EAAd;AACA,QAAIY,KAAJ;;AACA,QAAIC,YAAY,GAAGC,cAAc,IAAI,IAAIC,OAAJ,CAAYC,OAAO,IAAI;AAC1D,YAAMC,IAAI,GAAG,CAAE;AAAEX,QAAAA,QAAF;AAAYE,QAAAA;AAAZ,OAAF,EAAsB,GAAtB,EAA2B,CAAEG,OAAO,CAACP,KAAV,CAA3B,CAAb,CAD0D,CAG1D;;AACA,UAAIU,cAAJ,EAAoB;AAClBG,QAAAA,IAAI,CAAC,CAAD,CAAJ,CAAQH,cAAR,GAAyBA,cAAzB;AACAG,QAAAA,IAAI,CAAC,CAAD,CAAJ,CAAQC,IAAR,CAAaJ,cAAb;AACD;;AAEDH,MAAAA,OAAO,CAACV,KAAR,CAAckB,SAAd,GAA0BC,GAAG,IAAI;AAC/B;AACA;AACA,YAAIA,GAAG,CAACC,IAAJ,CAASC,QAAb,EAAuB;AACrBN,UAAAA,OAAO,GADc,CACX;;AACV,cAAI,CAACvC,MAAL,EAAamC,KAAK,CAACT,KAAN,GAFQ,CAEM;;AAC3B,cAAIoB,MAAM,CAACC,MAAP,IAAiBA,MAAM,CAACC,SAAxB,IACAD,MAAM,CAACC,SAAP,CAAiBC,iBADjB,IAEAF,MAAM,CAACC,SAAP,CAAiBC,iBAAjB,OAAyCH,MAF7C,EAEqD;AACnDC,YAAAA,MAAM,CAACG,IAAP,CAAYC,MAAZ,CAAmB;AAAEC,cAAAA,GAAG,EAAET,GAAG,CAACC,IAAJ,CAASC,QAAhB;AAA0BQ,cAAAA,MAAM,EAAE;AAAlC,aAAnB;AACD,WAJD,MAIO;AACLP,YAAAA,MAAM,CAAC7C,QAAP,GAAkB0C,GAAG,CAACC,IAAJ,CAASC,QAA3B;AACD,WAToB,CAWrB;;;AACA,cAAIR,cAAJ,EAAoB;AAClB;AACAH,YAAAA,OAAO,CAACV,KAAR,CAAcE,KAAd;AACAQ,YAAAA,OAAO,CAACP,KAAR,CAAcD,KAAd;AACD;;AAEDQ,UAAAA,OAAO,CAACV,KAAR,CAAckB,SAAd,GAA0B,IAA1B;AACD;AACF,OAvBD;;AAyBA,UAAI1C,MAAM,IAAI,CAACI,MAAf,EAAuB;AACrBA,QAAAA,MAAM,GAAGkD,QAAQ,CAACC,aAAT,CAAuB,QAAvB,CAAT;AACAnD,QAAAA,MAAM,CAACoD,GAAP,GAAajD,WAAW,CAACQ,IAAzB;AACAX,QAAAA,MAAM,CAACqD,MAAP,GAAgB,IAAhB;AACAH,QAAAA,QAAQ,CAACI,IAAT,CAAcC,WAAd,CAA0BvD,MAA1B;AACD;;AAED,UAAIJ,MAAM,IAAI,CAACK,MAAf,EAAuB;AACrB,YAAIuD,EAAJ;AACAxD,QAAAA,MAAM,CAACyD,gBAAP,CAAwB,MAAxB,EAAgCD,EAAE,GAAG,MAAM;AACzCvD,UAAAA,MAAM,GAAG,IAAT;AACAD,UAAAA,MAAM,CAAC0D,mBAAP,CAA2B,MAA3B,EAAmCF,EAAnC;AACAxD,UAAAA,MAAM,CAAC2D,aAAP,CAAqBtC,WAArB,CAAiC,GAAGe,IAApC;AACD,SAJD;AAKD;;AAED,UAAIxC,MAAM,IAAIK,MAAd,EAAsB;AACpBD,QAAAA,MAAM,CAAC2D,aAAP,CAAqBtC,WAArB,CAAiC,GAAGe,IAApC;AACD;;AAED,UAAI,CAACxC,MAAL,EAAa;AACXmC,QAAAA,KAAK,GAAGW,MAAM,CAACkB,IAAP,CAAYzD,WAAW,CAACQ,IAAxB,EAA8BkD,IAAI,CAACC,MAAL,EAA9B,CAAR;;AACA,YAAIC,OAAO,GAAGxB,GAAG,IAAI;AACnB,cAAIA,GAAG,CAACyB,MAAJ,KAAejC,KAAnB,EAA0B;AACxBA,YAAAA,KAAK,CAACV,WAAN,CAAkB,GAAGe,IAArB;AACAM,YAAAA,MAAM,CAACgB,mBAAP,CAA2B,SAA3B,EAAsCK,OAAtC;AACD;AACF,SALD,CAFW,CASX;AACA;AACA;;;AACArB,QAAAA,MAAM,CAACe,gBAAP,CAAwB,SAAxB,EAAmCM,OAAnC;AACD;AACF,KApEoC,CAArC;;AAsEA,QAAI7D,mBAAJ,EAAyB;AACvB,YAAM+D,EAAE,GAAG,IAAIhD,eAAJ,CAAoB;AAC7BiD,QAAAA,KAAK,GAAI;AACP,iBAAO,IAAIhC,OAAJ,CAAYC,OAAO,IACxBgC,UAAU,CAAC,MAAMnC,YAAY,CAACiC,EAAE,CAACjD,QAAJ,CAAZ,CAA0BoD,IAA1B,CAA+BjC,OAA/B,CAAP,CADL,CAAP;AAGD;;AAL4B,OAApB,EAMRT,eANQ,CAAX;AAQA,aAAOuC,EAAE,CAACI,QAAV;AACD;;AAED,WAAO,IAAIvD,cAAJ,CAAmB;AACxBoD,MAAAA,KAAK,GAAI;AACP;AACA;AACA;AACA;AACA,eAAOlC,YAAY,EAAnB;AACD,OAPuB;;AAQxBsC,MAAAA,KAAK,CAAEC,KAAF,EAAS;AACZ;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACAzC,QAAAA,OAAO,CAACV,KAAR,CAAcC,WAAd,CAA0BkD,KAA1B;AACD,OApBuB;;AAqBxBjD,MAAAA,KAAK,GAAI;AACPQ,QAAAA,OAAO,CAACV,KAAR,CAAcC,WAAd,CAA0B,KAA1B;AACD,OAvBuB;;AAwBxBmD,MAAAA,KAAK,GAAI;AACP1C,QAAAA,OAAO,CAACV,KAAR,CAAcC,WAAd,CAA0B,OAA1B;AACD;;AA1BuB,KAAnB,EA2BJK,eA3BI,CAAP;AA4BD;;AAED,SAAOvB,WAAP;AACD,CAtKA","sourcesContent":["/* global location WritableStream ReadableStream define MouseEvent MessageChannel TransformStream */\n;((name, definition) => {\n  typeof module !== 'undefined'\n    ? module.exports = definition()\n    : typeof define === 'function' && typeof define.amd === 'object'\n      ? define(definition)\n      : this[name] = definition()\n})('streamSaver', () => {\n  'use strict'\n\n  const secure = location.protocol === 'https:' ||\n                 location.protocol === 'chrome-extension:' ||\n                 location.hostname === 'localhost'\n  let iframe\n  let loaded\n  let transfarableSupport = false\n  let streamSaver = {\n    createWriteStream,\n    supported: false,\n    version: {\n      full: '1.2.0',\n      major: 1,\n      minor: 2,\n      dot: 0\n    }\n  }\n\n  streamSaver.mitm = 'https://jimmywarting.github.io/StreamSaver.js/mitm.html?version=' +\n    streamSaver.version.full\n\n  try {\n    // Some browser has it but ain't allowed to construct a stream yet\n    streamSaver.supported = 'serviceWorker' in navigator && !!new ReadableStream() && !!new WritableStream()\n  } catch (err) {}\n\n  try {\n    const { readable } = new TransformStream()\n    const mc = new MessageChannel()\n    mc.port1.postMessage(readable, [readable])\n    mc.port1.close()\n    mc.port2.close()\n    transfarableSupport = readable.locked === true\n  } catch (err) {\n    // Was first enabled in chrome v73\n  }\n\n  function createWriteStream (filename, queuingStrategy, size) {\n    // normalize arguments\n    if (Number.isFinite(queuingStrategy)) {\n      [size, queuingStrategy] = [queuingStrategy, size]\n    }\n\n    let channel = new MessageChannel()\n    let popup\n    let setupChannel = readableStream => new Promise(resolve => {\n      const args = [ { filename, size }, '*', [ channel.port2 ] ]\n\n      // Pass along transfarable stream\n      if (readableStream) {\n        args[0].readableStream = readableStream\n        args[2].push(readableStream)\n      }\n\n      channel.port1.onmessage = evt => {\n        // Service worker sent us a link from where\n        // we recive the readable link (stream)\n        if (evt.data.download) {\n          resolve() // Signal that the writestream are ready to recive data\n          if (!secure) popup.close() // don't need the popup any longer\n          if (window.chrome && chrome.extension &&\n              chrome.extension.getBackgroundPage &&\n              chrome.extension.getBackgroundPage() === window) {\n            chrome.tabs.create({ url: evt.data.download, active: false })\n          } else {\n            window.location = evt.data.download\n          }\n\n          // Cleanup\n          if (readableStream) {\n            // We don't need postMessages now when stream are transferable\n            channel.port1.close()\n            channel.port2.close()\n          }\n\n          channel.port1.onmessage = null\n        }\n      }\n\n      if (secure && !iframe) {\n        iframe = document.createElement('iframe')\n        iframe.src = streamSaver.mitm\n        iframe.hidden = true\n        document.body.appendChild(iframe)\n      }\n\n      if (secure && !loaded) {\n        let fn\n        iframe.addEventListener('load', fn = () => {\n          loaded = true\n          iframe.removeEventListener('load', fn)\n          iframe.contentWindow.postMessage(...args)\n        })\n      }\n\n      if (secure && loaded) {\n        iframe.contentWindow.postMessage(...args)\n      }\n\n      if (!secure) {\n        popup = window.open(streamSaver.mitm, Math.random())\n        let onready = evt => {\n          if (evt.source === popup) {\n            popup.postMessage(...args)\n            window.removeEventListener('message', onready)\n          }\n        }\n\n        // Another problem that cross origin don't allow is scripting\n        // so popup.onload() don't work but postMessage still dose\n        // work cross origin\n        window.addEventListener('message', onready)\n      }\n    })\n\n    if (transfarableSupport) {\n      const ts = new TransformStream({\n        start () {\n          return new Promise(resolve =>\n            setTimeout(() => setupChannel(ts.readable).then(resolve))\n          )\n        }\n      }, queuingStrategy)\n\n      return ts.writable\n    }\n\n    return new WritableStream({\n      start () {\n        // is called immediately, and should perform any actions\n        // necessary to acquire access to the underlying sink.\n        // If this process is asynchronous, it can return a promise\n        // to signal success or failure.\n        return setupChannel()\n      },\n      write (chunk) {\n        // is called when a new chunk of data is ready to be written\n        // to the underlying sink. It can return a promise to signal\n        // success or failure of the write operation. The stream\n        // implementation guarantees that this method will be called\n        // only after previous writes have succeeded, and never after\n        // close or abort is called.\n\n        // TODO: Kind of important that service worker respond back when\n        // it has been written. Otherwise we can't handle backpressure\n        // EDIT: Transfarable streams solvs this...\n        channel.port1.postMessage(chunk)\n      },\n      close () {\n        channel.port1.postMessage('end')\n      },\n      abort () {\n        channel.port1.postMessage('abort')\n      }\n    }, queuingStrategy)\n  }\n\n  return streamSaver\n})\n"]},"metadata":{},"sourceType":"script"}