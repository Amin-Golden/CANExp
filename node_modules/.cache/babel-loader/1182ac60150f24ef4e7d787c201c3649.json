{"ast":null,"code":"\"use strict\";\n/**\n * @author jdiaz5513\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar tslib_1 = require(\"tslib\");\n\nvar debug_1 = require(\"debug\");\n\nvar constants_1 = require(\"../constants\");\n\nvar util_1 = require(\"../util\");\n\nvar uint64_1 = require(\"./uint64\");\n\nvar trace = debug_1.default('capnp:int64');\ntrace('load');\n/**\n * Represents a signed 64-bit integer stored using a Uint8Array in little-endian format.\n *\n * You may convert this to a primitive number by calling `toNumber()` but be wary of precision loss!\n *\n * The value passed in as the source buffer is expected to be in little-endian format.\n */\n\nvar Int64 =\n/** @class */\nfunction (_super) {\n  tslib_1.__extends(Int64, _super);\n\n  function Int64() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  Int64.fromArrayBuffer = function (source, offset, noCopy) {\n    if (offset === void 0) {\n      offset = 0;\n    }\n\n    if (noCopy === void 0) {\n      noCopy = false;\n    }\n\n    if (noCopy) return new this(new Uint8Array(source, offset, 8));\n    return new this(new Uint8Array(source.slice(offset, offset + 8)));\n  };\n\n  Int64.fromDataView = function (source, offset, noCopy) {\n    if (offset === void 0) {\n      offset = 0;\n    }\n\n    if (noCopy === void 0) {\n      noCopy = false;\n    }\n\n    if (noCopy) return new this(new Uint8Array(source.buffer, source.byteOffset + offset, 8));\n    return new this(new Uint8Array(source.buffer.slice(source.byteOffset + offset, source.byteLength + offset + 8)));\n  };\n\n  Int64.fromNumber = function (source) {\n    var ret = new this(new Uint8Array(8));\n    ret.setValue(source);\n    return ret;\n  };\n  /**\n   * Parse a hexadecimal string in **big endian format** as an Int64 value.\n   *\n   * The value will be negative if the string is either preceded with a `-` sign, or already in the negative 2's\n   * complement form.\n   *\n   * @static\n   * @param {string} source The source string.\n   * @returns {Int64} The string parsed as a 64-bit signed integer.\n   */\n\n\n  Int64.fromHexString = function (source) {\n    if (source.substr(0, 2) === '0x') source = source.substr(2);\n    if (source.length < 1) return Int64.fromNumber(0);\n    var neg = source[0] === '-';\n    if (neg) source = source.substr(1);\n    source = util_1.pad(source, 16);\n    if (source.length !== 16) throw new RangeError('Source string must contain at most 16 hexadecimal digits.');\n    var bytes = source.toLowerCase().replace(/[^\\da-f]/g, '');\n    var buf = new Uint8Array(new ArrayBuffer(8));\n\n    for (var i = 0; i < 8; i++) buf[7 - i] = parseInt(bytes.substr(i * 2, 2), 16);\n\n    var val = new Int64(buf);\n    if (neg) val.negate();\n    return val;\n  };\n\n  Int64.fromUint8Array = function (source, offset, noCopy) {\n    if (offset === void 0) {\n      offset = 0;\n    }\n\n    if (noCopy === void 0) {\n      noCopy = false;\n    }\n\n    if (noCopy) return new this(source.subarray(offset, offset + 8));\n    return new this(new Uint8Array(source.buffer.slice(source.byteOffset + offset, source.byteOffset + offset + 8)));\n  };\n\n  Int64.prototype.equals = function (other) {\n    return _super.prototype.equals.call(this, other);\n  };\n\n  Int64.prototype.inspect = function () {\n    return \"[Int64 \" + this.toString(10) + \" 0x\" + this.toHexString() + \"]\";\n  };\n\n  Int64.prototype.negate = function () {\n    for (var b = this.buffer, carry = 1, i = 0; i < 8; i++) {\n      var v = (b[i] ^ 0xff) + carry;\n      b[i] = v & 0xff;\n      carry = v >> 8;\n    }\n  };\n\n  Int64.prototype.setValue = function (loWord, hiWord) {\n    var negate = false;\n    var lo = loWord;\n    var hi = hiWord;\n\n    if (hi === undefined) {\n      hi = lo;\n      negate = hi < 0;\n      hi = Math.abs(hi);\n      lo = hi % constants_1.VAL32;\n      hi = hi / constants_1.VAL32;\n      if (hi > constants_1.VAL32) throw new RangeError(loWord + \" is outside Int64 range\");\n      hi = hi >>> 0;\n    }\n\n    for (var i = 0; i < 8; i++) {\n      this.buffer[i] = lo & 0xff;\n      lo = i === 3 ? hi : lo >>> 8;\n    }\n\n    if (negate) this.negate();\n  };\n\n  Int64.prototype.toHexString = function () {\n    var b = this.buffer;\n    var negate = b[7] & 0x80;\n    if (negate) this.negate();\n    var hex = '';\n\n    for (var i = 7; i >= 0; i--) {\n      var v = b[i].toString(16);\n      if (v.length === 1) v = '0' + v;\n      hex += v;\n    }\n\n    if (negate) {\n      this.negate();\n      hex = '-' + hex;\n    }\n\n    return hex;\n  };\n  /**\n   * Convert to a native javascript number.\n   *\n   * WARNING: do not expect this number to be accurate to integer precision for large (positive or negative) numbers!\n   *\n   * @param {boolean} allowImprecise If `true`, no check is performed to verify the returned value is accurate;\n   * otherwise out-of-range values are clamped to +/-Infinity.\n   * @returns {number} A numeric representation of this integer.\n   */\n\n\n  Int64.prototype.toNumber = function (allowImprecise) {\n    var b = this.buffer;\n    var negate = b[7] & 0x80;\n    var x = 0;\n    var carry = 1;\n    var i = 0;\n    var m = 1;\n\n    while (i < 8) {\n      var v = b[i];\n\n      if (negate) {\n        v = (v ^ 0xff) + carry;\n        carry = v >> 8;\n        v = v & 0xff;\n      }\n\n      x += v * m;\n      m *= 256;\n      i++;\n    }\n\n    if (!allowImprecise && x >= constants_1.MAX_SAFE_INTEGER) {\n      trace('Coercing out of range value %d to Infinity.', x);\n      return negate ? -Infinity : Infinity;\n    }\n\n    return negate ? -x : x;\n  };\n\n  return Int64;\n}(uint64_1.Uint64);\n\nexports.Int64 = Int64;","map":{"version":3,"sources":["types/int64.ts"],"names":[],"mappings":"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","sourceRoot":"../../src","sourcesContent":["\"use strict\";\n/**\n * @author jdiaz5513\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = require(\"tslib\");\nvar debug_1 = require(\"debug\");\nvar constants_1 = require(\"../constants\");\nvar util_1 = require(\"../util\");\nvar uint64_1 = require(\"./uint64\");\nvar trace = debug_1.default('capnp:int64');\ntrace('load');\n/**\n * Represents a signed 64-bit integer stored using a Uint8Array in little-endian format.\n *\n * You may convert this to a primitive number by calling `toNumber()` but be wary of precision loss!\n *\n * The value passed in as the source buffer is expected to be in little-endian format.\n */\nvar Int64 = /** @class */ (function (_super) {\n    tslib_1.__extends(Int64, _super);\n    function Int64() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Int64.fromArrayBuffer = function (source, offset, noCopy) {\n        if (offset === void 0) { offset = 0; }\n        if (noCopy === void 0) { noCopy = false; }\n        if (noCopy)\n            return new this(new Uint8Array(source, offset, 8));\n        return new this(new Uint8Array(source.slice(offset, offset + 8)));\n    };\n    Int64.fromDataView = function (source, offset, noCopy) {\n        if (offset === void 0) { offset = 0; }\n        if (noCopy === void 0) { noCopy = false; }\n        if (noCopy)\n            return new this(new Uint8Array(source.buffer, source.byteOffset + offset, 8));\n        return new this(new Uint8Array(source.buffer.slice(source.byteOffset + offset, source.byteLength + offset + 8)));\n    };\n    Int64.fromNumber = function (source) {\n        var ret = new this(new Uint8Array(8));\n        ret.setValue(source);\n        return ret;\n    };\n    /**\n     * Parse a hexadecimal string in **big endian format** as an Int64 value.\n     *\n     * The value will be negative if the string is either preceded with a `-` sign, or already in the negative 2's\n     * complement form.\n     *\n     * @static\n     * @param {string} source The source string.\n     * @returns {Int64} The string parsed as a 64-bit signed integer.\n     */\n    Int64.fromHexString = function (source) {\n        if (source.substr(0, 2) === '0x')\n            source = source.substr(2);\n        if (source.length < 1)\n            return Int64.fromNumber(0);\n        var neg = source[0] === '-';\n        if (neg)\n            source = source.substr(1);\n        source = util_1.pad(source, 16);\n        if (source.length !== 16)\n            throw new RangeError('Source string must contain at most 16 hexadecimal digits.');\n        var bytes = source.toLowerCase().replace(/[^\\da-f]/g, '');\n        var buf = new Uint8Array(new ArrayBuffer(8));\n        for (var i = 0; i < 8; i++)\n            buf[7 - i] = parseInt(bytes.substr(i * 2, 2), 16);\n        var val = new Int64(buf);\n        if (neg)\n            val.negate();\n        return val;\n    };\n    Int64.fromUint8Array = function (source, offset, noCopy) {\n        if (offset === void 0) { offset = 0; }\n        if (noCopy === void 0) { noCopy = false; }\n        if (noCopy)\n            return new this(source.subarray(offset, offset + 8));\n        return new this(new Uint8Array(source.buffer.slice(source.byteOffset + offset, source.byteOffset + offset + 8)));\n    };\n    Int64.prototype.equals = function (other) {\n        return _super.prototype.equals.call(this, other);\n    };\n    Int64.prototype.inspect = function () {\n        return \"[Int64 \" + this.toString(10) + \" 0x\" + this.toHexString() + \"]\";\n    };\n    Int64.prototype.negate = function () {\n        for (var b = this.buffer, carry = 1, i = 0; i < 8; i++) {\n            var v = (b[i] ^ 0xff) + carry;\n            b[i] = v & 0xff;\n            carry = v >> 8;\n        }\n    };\n    Int64.prototype.setValue = function (loWord, hiWord) {\n        var negate = false;\n        var lo = loWord;\n        var hi = hiWord;\n        if (hi === undefined) {\n            hi = lo;\n            negate = hi < 0;\n            hi = Math.abs(hi);\n            lo = hi % constants_1.VAL32;\n            hi = hi / constants_1.VAL32;\n            if (hi > constants_1.VAL32)\n                throw new RangeError(loWord + \" is outside Int64 range\");\n            hi = hi >>> 0;\n        }\n        for (var i = 0; i < 8; i++) {\n            this.buffer[i] = lo & 0xff;\n            lo = i === 3 ? hi : lo >>> 8;\n        }\n        if (negate)\n            this.negate();\n    };\n    Int64.prototype.toHexString = function () {\n        var b = this.buffer;\n        var negate = b[7] & 0x80;\n        if (negate)\n            this.negate();\n        var hex = '';\n        for (var i = 7; i >= 0; i--) {\n            var v = b[i].toString(16);\n            if (v.length === 1)\n                v = '0' + v;\n            hex += v;\n        }\n        if (negate) {\n            this.negate();\n            hex = '-' + hex;\n        }\n        return hex;\n    };\n    /**\n     * Convert to a native javascript number.\n     *\n     * WARNING: do not expect this number to be accurate to integer precision for large (positive or negative) numbers!\n     *\n     * @param {boolean} allowImprecise If `true`, no check is performed to verify the returned value is accurate;\n     * otherwise out-of-range values are clamped to +/-Infinity.\n     * @returns {number} A numeric representation of this integer.\n     */\n    Int64.prototype.toNumber = function (allowImprecise) {\n        var b = this.buffer;\n        var negate = b[7] & 0x80;\n        var x = 0;\n        var carry = 1;\n        var i = 0;\n        var m = 1;\n        while (i < 8) {\n            var v = b[i];\n            if (negate) {\n                v = (v ^ 0xff) + carry;\n                carry = v >> 8;\n                v = v & 0xff;\n            }\n            x += v * m;\n            m *= 256;\n            i++;\n        }\n        if (!allowImprecise && x >= constants_1.MAX_SAFE_INTEGER) {\n            trace('Coercing out of range value %d to Infinity.', x);\n            return negate ? -Infinity : Infinity;\n        }\n        return negate ? -x : x;\n    };\n    return Int64;\n}(uint64_1.Uint64));\nexports.Int64 = Int64;\n\n//# sourceMappingURL=int64.js.map\n"]},"metadata":{},"sourceType":"script"}