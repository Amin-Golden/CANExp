{"ast":null,"code":"\"use strict\";\n/**\n * @author jdiaz5513\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar debug_1 = require(\"debug\");\n\nvar constants_1 = require(\"../constants\");\n\nvar errors_1 = require(\"../errors\");\n\nvar types_1 = require(\"../types\");\n\nvar util_1 = require(\"../util\");\n\nvar pointers_1 = require(\"./pointers\");\n\nvar trace = debug_1.default('capnp:segment');\ntrace('load');\n\nvar Segment =\n/** @class */\nfunction () {\n  function Segment(id, message, buffer, byteLength) {\n    if (byteLength === void 0) {\n      byteLength = 0;\n    }\n\n    this[Symbol.toStringTag] = 'Segment';\n    this.id = id;\n    this.message = message;\n    this.buffer = buffer;\n    this._dv = new DataView(buffer);\n    this.byteOffset = 0;\n    this.byteLength = byteLength;\n  }\n  /**\n   * Attempt to allocate the requested number of bytes in this segment. If this segment is full this method will return\n   * a pointer to freshly allocated space in another segment from the same message.\n   *\n   * @param {number} byteLength The number of bytes to allocate, will be rounded up to the nearest word.\n   * @returns {Pointer} A pointer to the newly allocated space.\n   */\n\n\n  Segment.prototype.allocate = function (byteLength) {\n    trace('allocate(%d)', byteLength);\n    var segment = this;\n    byteLength = util_1.padToWord(byteLength);\n    if (byteLength > constants_1.MAX_SEGMENT_LENGTH - 8) throw new Error(util_1.format(errors_1.SEG_SIZE_OVERFLOW, byteLength));\n    if (!segment.hasCapacity(byteLength)) segment = segment.message.allocateSegment(byteLength);\n    var byteOffset = segment.byteLength;\n    segment.byteLength = segment.byteLength + byteLength;\n    trace('Allocated %x bytes in %s (requested segment: %s).', byteLength, this, segment);\n    return new pointers_1.Pointer(segment, byteOffset);\n  };\n  /**\n   * Quickly copy a word (8 bytes) from `srcSegment` into this one at the given offset.\n   *\n   * @param {number} byteOffset The offset to write the word to.\n   * @param {Segment} srcSegment The segment to copy the word from.\n   * @param {number} srcByteOffset The offset from the start of `srcSegment` to copy from.\n   * @returns {void}\n   */\n\n\n  Segment.prototype.copyWord = function (byteOffset, srcSegment, srcByteOffset) {\n    var value = srcSegment._dv.getFloat64(srcByteOffset, constants_1.NATIVE_LITTLE_ENDIAN);\n\n    this._dv.setFloat64(byteOffset, value, constants_1.NATIVE_LITTLE_ENDIAN);\n  };\n  /**\n   * Quickly copy words from `srcSegment` into this one.\n   *\n   * @param {number} byteOffset The offset to start copying into.\n   * @param {Segment} srcSegment The segment to copy from.\n   * @param {number} srcByteOffset The start offset to copy from.\n   * @param {number} wordLength The number of words to copy.\n   * @returns {void}\n   */\n\n\n  Segment.prototype.copyWords = function (byteOffset, srcSegment, srcByteOffset, wordLength) {\n    var dst = new Float64Array(this.buffer, byteOffset, wordLength);\n    var src = new Float64Array(srcSegment.buffer, srcByteOffset, wordLength);\n    dst.set(src);\n  };\n  /**\n   * Quickly fill a number of words in the buffer with zeroes.\n   *\n   * @param {number} byteOffset The first byte to set to zero.\n   * @param {number} wordLength The number of words (not bytes!) to zero out.\n   * @returns {void}\n   */\n\n\n  Segment.prototype.fillZeroWords = function (byteOffset, wordLength) {\n    new Float64Array(this.buffer, byteOffset, wordLength).fill(0);\n  };\n  /**\n   * Get the total number of bytes available in this segment (the size of its underlying buffer).\n   *\n   * @returns {number} The total number of bytes this segment can hold.\n   */\n\n\n  Segment.prototype.getCapacity = function () {\n    return this.buffer.byteLength;\n  };\n  /**\n   * Read a float32 value out of this segment.\n   *\n   * @param {number} byteOffset The offset in bytes to the value.\n   * @returns {number} The value.\n   */\n\n\n  Segment.prototype.getFloat32 = function (byteOffset) {\n    return this._dv.getFloat32(byteOffset, true);\n  };\n  /**\n   * Read a float64 value out of this segment.\n   *\n   * @param {number} byteOffset The offset in bytes to the value.\n   * @returns {number} The value.\n   */\n\n\n  Segment.prototype.getFloat64 = function (byteOffset) {\n    return this._dv.getFloat64(byteOffset, true);\n  };\n  /**\n   * Read an int16 value out of this segment.\n   *\n   * @param {number} byteOffset The offset in bytes to the value.\n   * @returns {number} The value.\n   */\n\n\n  Segment.prototype.getInt16 = function (byteOffset) {\n    return this._dv.getInt16(byteOffset, true);\n  };\n  /**\n   * Read an int32 value out of this segment.\n   *\n   * @param {number} byteOffset The offset in bytes to the value.\n   * @returns {number} The value.\n   */\n\n\n  Segment.prototype.getInt32 = function (byteOffset) {\n    return this._dv.getInt32(byteOffset, true);\n  };\n  /**\n   * Read an int64 value out of this segment.\n   *\n   * @param {number} byteOffset The offset in bytes to the value.\n   * @returns {number} The value.\n   */\n\n\n  Segment.prototype.getInt64 = function (byteOffset) {\n    return new types_1.Int64(new Uint8Array(this.buffer.slice(byteOffset, byteOffset + 8)));\n  };\n  /**\n   * Read an int8 value out of this segment.\n   *\n   * @param {number} byteOffset The offset in bytes to the value.\n   * @returns {number} The value.\n   */\n\n\n  Segment.prototype.getInt8 = function (byteOffset) {\n    return this._dv.getInt8(byteOffset);\n  };\n  /**\n   * Read a uint16 value out of this segment.\n   *\n   * @param {number} byteOffset The offset in bytes to the value.\n   * @returns {number} The value.\n   */\n\n\n  Segment.prototype.getUint16 = function (byteOffset) {\n    return this._dv.getUint16(byteOffset, true);\n  };\n  /**\n   * Read a uint32 value out of this segment.\n   *\n   * @param {number} byteOffset The offset in bytes to the value.\n   * @returns {number} The value.\n   */\n\n\n  Segment.prototype.getUint32 = function (byteOffset) {\n    return this._dv.getUint32(byteOffset, true);\n  };\n  /**\n   * Read a uint8 value out of this segment.\n   * NOTE: this does not copy the memory region, so updates to the underlying buffer will affect the Uint64 value!\n   *\n   * @param {number} byteOffset The offset in bytes to the value.\n   * @returns {number} The value.\n   */\n\n\n  Segment.prototype.getUint64 = function (byteOffset) {\n    return new types_1.Uint64(new Uint8Array(this.buffer.slice(byteOffset, byteOffset + 8)));\n  };\n  /**\n   * Read a uint8 value out of this segment.\n   *\n   * @param {number} byteOffset The offset in bytes to the value.\n   * @returns {number} The value.\n   */\n\n\n  Segment.prototype.getUint8 = function (byteOffset) {\n    return this._dv.getUint8(byteOffset);\n  };\n\n  Segment.prototype.hasCapacity = function (byteLength) {\n    trace('hasCapacity(%d)', byteLength); // capacity - allocated >= requested\n\n    return this.buffer.byteLength - this.byteLength >= byteLength;\n  };\n  /**\n   * Quickly check the word at the given offset to see if it is equal to zero.\n   *\n   * PERF_V8: Fastest way to do this is by reading the whole word as a `number` (float64) in the _native_ endian format\n   * and see if it's zero.\n   *\n   * Benchmark: http://jsben.ch/#/Pjooc\n   *\n   * @param {number} byteOffset The offset to the word.\n   * @returns {boolean} `true` if the word is zero.\n   */\n\n\n  Segment.prototype.isWordZero = function (byteOffset) {\n    return this._dv.getFloat64(byteOffset, constants_1.NATIVE_LITTLE_ENDIAN) === 0;\n  };\n  /**\n   * Swap out this segment's underlying buffer with a new one. It's assumed that the new buffer has the same content but\n   * more free space, otherwise all existing pointers to this segment will be hilariously broken.\n   *\n   * @param {ArrayBuffer} buffer The new buffer to use.\n   * @returns {void}\n   */\n\n\n  Segment.prototype.replaceBuffer = function (buffer) {\n    trace('replaceBuffer(%p)', buffer);\n    if (this.buffer === buffer) return;\n    if (buffer.byteLength < this.byteLength) throw new Error(errors_1.SEG_REPLACEMENT_BUFFER_TOO_SMALL);\n    this._dv = new DataView(buffer);\n    this.buffer = buffer;\n  };\n  /**\n   * Write a float32 value to the specified offset.\n   *\n   * @param {number} byteOffset The offset from the beginning of the buffer.\n   * @param {number} val The value to store.\n   * @returns {void}\n   */\n\n\n  Segment.prototype.setFloat32 = function (byteOffset, val) {\n    this._dv.setFloat32(byteOffset, val, true);\n  };\n  /**\n   * Write an float64 value to the specified offset.\n   *\n   * @param {number} byteOffset The offset from the beginning of the buffer.\n   * @param {number} val The value to store.\n   * @returns {void}\n   */\n\n\n  Segment.prototype.setFloat64 = function (byteOffset, val) {\n    this._dv.setFloat64(byteOffset, val, true);\n  };\n  /**\n   * Write an int16 value to the specified offset.\n   *\n   * @param {number} byteOffset The offset from the beginning of the buffer.\n   * @param {number} val The value to store.\n   * @returns {void}\n   */\n\n\n  Segment.prototype.setInt16 = function (byteOffset, val) {\n    this._dv.setInt16(byteOffset, val, true);\n  };\n  /**\n   * Write an int32 value to the specified offset.\n   *\n   * @param {number} byteOffset The offset from the beginning of the buffer.\n   * @param {number} val The value to store.\n   * @returns {void}\n   */\n\n\n  Segment.prototype.setInt32 = function (byteOffset, val) {\n    this._dv.setInt32(byteOffset, val, true);\n  };\n  /**\n   * Write an int8 value to the specified offset.\n   *\n   * @param {number} byteOffset The offset from the beginning of the buffer.\n   * @param {number} val The value to store.\n   * @returns {void}\n   */\n\n\n  Segment.prototype.setInt8 = function (byteOffset, val) {\n    this._dv.setInt8(byteOffset, val);\n  };\n  /**\n   * Write an int64 value to the specified offset.\n   *\n   * @param {number} byteOffset The offset from the beginning of the buffer.\n   * @param {Int64} val The value to store.\n   * @returns {void}\n   */\n\n\n  Segment.prototype.setInt64 = function (byteOffset, val) {\n    this._dv.setUint8(byteOffset, val.buffer[0]);\n\n    this._dv.setUint8(byteOffset + 1, val.buffer[1]);\n\n    this._dv.setUint8(byteOffset + 2, val.buffer[2]);\n\n    this._dv.setUint8(byteOffset + 3, val.buffer[3]);\n\n    this._dv.setUint8(byteOffset + 4, val.buffer[4]);\n\n    this._dv.setUint8(byteOffset + 5, val.buffer[5]);\n\n    this._dv.setUint8(byteOffset + 6, val.buffer[6]);\n\n    this._dv.setUint8(byteOffset + 7, val.buffer[7]);\n  };\n  /**\n   * Write a uint16 value to the specified offset.\n   *\n   * @param {number} byteOffset The offset from the beginning of the buffer.\n   * @param {number} val The value to store.\n   * @returns {void}\n   */\n\n\n  Segment.prototype.setUint16 = function (byteOffset, val) {\n    this._dv.setUint16(byteOffset, val, true);\n  };\n  /**\n   * Write a uint32 value to the specified offset.\n   *\n   * @param {number} byteOffset The offset from the beginning of the buffer.\n   * @param {number} val The value to store.\n   * @returns {void}\n   */\n\n\n  Segment.prototype.setUint32 = function (byteOffset, val) {\n    this._dv.setUint32(byteOffset, val, true);\n  };\n  /**\n   * Write a uint64 value to the specified offset.\n   * TODO: benchmark other ways to perform this write operation.\n   *\n   * @param {number} byteOffset The offset from the beginning of the buffer.\n   * @param {Uint64} val The value to store.\n   * @returns {void}\n   */\n\n\n  Segment.prototype.setUint64 = function (byteOffset, val) {\n    this._dv.setUint8(byteOffset + 0, val.buffer[0]);\n\n    this._dv.setUint8(byteOffset + 1, val.buffer[1]);\n\n    this._dv.setUint8(byteOffset + 2, val.buffer[2]);\n\n    this._dv.setUint8(byteOffset + 3, val.buffer[3]);\n\n    this._dv.setUint8(byteOffset + 4, val.buffer[4]);\n\n    this._dv.setUint8(byteOffset + 5, val.buffer[5]);\n\n    this._dv.setUint8(byteOffset + 6, val.buffer[6]);\n\n    this._dv.setUint8(byteOffset + 7, val.buffer[7]);\n  };\n  /**\n   * Write a uint8 (byte) value to the specified offset.\n   *\n   * @param {number} byteOffset The offset from the beginning of the buffer.\n   * @param {number} val The value to store.\n   * @returns {void}\n   */\n\n\n  Segment.prototype.setUint8 = function (byteOffset, val) {\n    this._dv.setUint8(byteOffset, val);\n  };\n  /**\n   * Write a zero word (8 bytes) to the specified offset. This is slightly faster than calling `setUint64` or\n   * `setFloat64` with a zero value.\n   *\n   * Benchmark: http://jsben.ch/#/dUdPI\n   *\n   * @param {number} byteOffset The offset of the word to set to zero.\n   * @returns {void}\n   */\n\n\n  Segment.prototype.setWordZero = function (byteOffset) {\n    this._dv.setFloat64(byteOffset, 0, constants_1.NATIVE_LITTLE_ENDIAN);\n  };\n\n  Segment.prototype.toString = function () {\n    return util_1.format('Segment_id:%d,off:%a,len:%a,cap:%a', this.id, this.byteLength, this.byteOffset, this.buffer.byteLength);\n  };\n\n  return Segment;\n}();\n\nexports.Segment = Segment;","map":{"version":3,"sources":["serialization/segment.ts"],"names":[],"mappings":"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","sourceRoot":"../../src","sourcesContent":["\"use strict\";\n/**\n * @author jdiaz5513\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar debug_1 = require(\"debug\");\nvar constants_1 = require(\"../constants\");\nvar errors_1 = require(\"../errors\");\nvar types_1 = require(\"../types\");\nvar util_1 = require(\"../util\");\nvar pointers_1 = require(\"./pointers\");\nvar trace = debug_1.default('capnp:segment');\ntrace('load');\nvar Segment = /** @class */ (function () {\n    function Segment(id, message, buffer, byteLength) {\n        if (byteLength === void 0) { byteLength = 0; }\n        this[Symbol.toStringTag] = 'Segment';\n        this.id = id;\n        this.message = message;\n        this.buffer = buffer;\n        this._dv = new DataView(buffer);\n        this.byteOffset = 0;\n        this.byteLength = byteLength;\n    }\n    /**\n     * Attempt to allocate the requested number of bytes in this segment. If this segment is full this method will return\n     * a pointer to freshly allocated space in another segment from the same message.\n     *\n     * @param {number} byteLength The number of bytes to allocate, will be rounded up to the nearest word.\n     * @returns {Pointer} A pointer to the newly allocated space.\n     */\n    Segment.prototype.allocate = function (byteLength) {\n        trace('allocate(%d)', byteLength);\n        var segment = this;\n        byteLength = util_1.padToWord(byteLength);\n        if (byteLength > constants_1.MAX_SEGMENT_LENGTH - 8)\n            throw new Error(util_1.format(errors_1.SEG_SIZE_OVERFLOW, byteLength));\n        if (!segment.hasCapacity(byteLength))\n            segment = segment.message.allocateSegment(byteLength);\n        var byteOffset = segment.byteLength;\n        segment.byteLength = segment.byteLength + byteLength;\n        trace('Allocated %x bytes in %s (requested segment: %s).', byteLength, this, segment);\n        return new pointers_1.Pointer(segment, byteOffset);\n    };\n    /**\n     * Quickly copy a word (8 bytes) from `srcSegment` into this one at the given offset.\n     *\n     * @param {number} byteOffset The offset to write the word to.\n     * @param {Segment} srcSegment The segment to copy the word from.\n     * @param {number} srcByteOffset The offset from the start of `srcSegment` to copy from.\n     * @returns {void}\n     */\n    Segment.prototype.copyWord = function (byteOffset, srcSegment, srcByteOffset) {\n        var value = srcSegment._dv.getFloat64(srcByteOffset, constants_1.NATIVE_LITTLE_ENDIAN);\n        this._dv.setFloat64(byteOffset, value, constants_1.NATIVE_LITTLE_ENDIAN);\n    };\n    /**\n     * Quickly copy words from `srcSegment` into this one.\n     *\n     * @param {number} byteOffset The offset to start copying into.\n     * @param {Segment} srcSegment The segment to copy from.\n     * @param {number} srcByteOffset The start offset to copy from.\n     * @param {number} wordLength The number of words to copy.\n     * @returns {void}\n     */\n    Segment.prototype.copyWords = function (byteOffset, srcSegment, srcByteOffset, wordLength) {\n        var dst = new Float64Array(this.buffer, byteOffset, wordLength);\n        var src = new Float64Array(srcSegment.buffer, srcByteOffset, wordLength);\n        dst.set(src);\n    };\n    /**\n     * Quickly fill a number of words in the buffer with zeroes.\n     *\n     * @param {number} byteOffset The first byte to set to zero.\n     * @param {number} wordLength The number of words (not bytes!) to zero out.\n     * @returns {void}\n     */\n    Segment.prototype.fillZeroWords = function (byteOffset, wordLength) {\n        new Float64Array(this.buffer, byteOffset, wordLength).fill(0);\n    };\n    /**\n     * Get the total number of bytes available in this segment (the size of its underlying buffer).\n     *\n     * @returns {number} The total number of bytes this segment can hold.\n     */\n    Segment.prototype.getCapacity = function () {\n        return this.buffer.byteLength;\n    };\n    /**\n     * Read a float32 value out of this segment.\n     *\n     * @param {number} byteOffset The offset in bytes to the value.\n     * @returns {number} The value.\n     */\n    Segment.prototype.getFloat32 = function (byteOffset) {\n        return this._dv.getFloat32(byteOffset, true);\n    };\n    /**\n     * Read a float64 value out of this segment.\n     *\n     * @param {number} byteOffset The offset in bytes to the value.\n     * @returns {number} The value.\n     */\n    Segment.prototype.getFloat64 = function (byteOffset) {\n        return this._dv.getFloat64(byteOffset, true);\n    };\n    /**\n     * Read an int16 value out of this segment.\n     *\n     * @param {number} byteOffset The offset in bytes to the value.\n     * @returns {number} The value.\n     */\n    Segment.prototype.getInt16 = function (byteOffset) {\n        return this._dv.getInt16(byteOffset, true);\n    };\n    /**\n     * Read an int32 value out of this segment.\n     *\n     * @param {number} byteOffset The offset in bytes to the value.\n     * @returns {number} The value.\n     */\n    Segment.prototype.getInt32 = function (byteOffset) {\n        return this._dv.getInt32(byteOffset, true);\n    };\n    /**\n     * Read an int64 value out of this segment.\n     *\n     * @param {number} byteOffset The offset in bytes to the value.\n     * @returns {number} The value.\n     */\n    Segment.prototype.getInt64 = function (byteOffset) {\n        return new types_1.Int64(new Uint8Array(this.buffer.slice(byteOffset, byteOffset + 8)));\n    };\n    /**\n     * Read an int8 value out of this segment.\n     *\n     * @param {number} byteOffset The offset in bytes to the value.\n     * @returns {number} The value.\n     */\n    Segment.prototype.getInt8 = function (byteOffset) {\n        return this._dv.getInt8(byteOffset);\n    };\n    /**\n     * Read a uint16 value out of this segment.\n     *\n     * @param {number} byteOffset The offset in bytes to the value.\n     * @returns {number} The value.\n     */\n    Segment.prototype.getUint16 = function (byteOffset) {\n        return this._dv.getUint16(byteOffset, true);\n    };\n    /**\n     * Read a uint32 value out of this segment.\n     *\n     * @param {number} byteOffset The offset in bytes to the value.\n     * @returns {number} The value.\n     */\n    Segment.prototype.getUint32 = function (byteOffset) {\n        return this._dv.getUint32(byteOffset, true);\n    };\n    /**\n     * Read a uint8 value out of this segment.\n     * NOTE: this does not copy the memory region, so updates to the underlying buffer will affect the Uint64 value!\n     *\n     * @param {number} byteOffset The offset in bytes to the value.\n     * @returns {number} The value.\n     */\n    Segment.prototype.getUint64 = function (byteOffset) {\n        return new types_1.Uint64(new Uint8Array(this.buffer.slice(byteOffset, byteOffset + 8)));\n    };\n    /**\n     * Read a uint8 value out of this segment.\n     *\n     * @param {number} byteOffset The offset in bytes to the value.\n     * @returns {number} The value.\n     */\n    Segment.prototype.getUint8 = function (byteOffset) {\n        return this._dv.getUint8(byteOffset);\n    };\n    Segment.prototype.hasCapacity = function (byteLength) {\n        trace('hasCapacity(%d)', byteLength);\n        // capacity - allocated >= requested\n        return this.buffer.byteLength - this.byteLength >= byteLength;\n    };\n    /**\n     * Quickly check the word at the given offset to see if it is equal to zero.\n     *\n     * PERF_V8: Fastest way to do this is by reading the whole word as a `number` (float64) in the _native_ endian format\n     * and see if it's zero.\n     *\n     * Benchmark: http://jsben.ch/#/Pjooc\n     *\n     * @param {number} byteOffset The offset to the word.\n     * @returns {boolean} `true` if the word is zero.\n     */\n    Segment.prototype.isWordZero = function (byteOffset) {\n        return this._dv.getFloat64(byteOffset, constants_1.NATIVE_LITTLE_ENDIAN) === 0;\n    };\n    /**\n     * Swap out this segment's underlying buffer with a new one. It's assumed that the new buffer has the same content but\n     * more free space, otherwise all existing pointers to this segment will be hilariously broken.\n     *\n     * @param {ArrayBuffer} buffer The new buffer to use.\n     * @returns {void}\n     */\n    Segment.prototype.replaceBuffer = function (buffer) {\n        trace('replaceBuffer(%p)', buffer);\n        if (this.buffer === buffer)\n            return;\n        if (buffer.byteLength < this.byteLength)\n            throw new Error(errors_1.SEG_REPLACEMENT_BUFFER_TOO_SMALL);\n        this._dv = new DataView(buffer);\n        this.buffer = buffer;\n    };\n    /**\n     * Write a float32 value to the specified offset.\n     *\n     * @param {number} byteOffset The offset from the beginning of the buffer.\n     * @param {number} val The value to store.\n     * @returns {void}\n     */\n    Segment.prototype.setFloat32 = function (byteOffset, val) {\n        this._dv.setFloat32(byteOffset, val, true);\n    };\n    /**\n     * Write an float64 value to the specified offset.\n     *\n     * @param {number} byteOffset The offset from the beginning of the buffer.\n     * @param {number} val The value to store.\n     * @returns {void}\n     */\n    Segment.prototype.setFloat64 = function (byteOffset, val) {\n        this._dv.setFloat64(byteOffset, val, true);\n    };\n    /**\n     * Write an int16 value to the specified offset.\n     *\n     * @param {number} byteOffset The offset from the beginning of the buffer.\n     * @param {number} val The value to store.\n     * @returns {void}\n     */\n    Segment.prototype.setInt16 = function (byteOffset, val) {\n        this._dv.setInt16(byteOffset, val, true);\n    };\n    /**\n     * Write an int32 value to the specified offset.\n     *\n     * @param {number} byteOffset The offset from the beginning of the buffer.\n     * @param {number} val The value to store.\n     * @returns {void}\n     */\n    Segment.prototype.setInt32 = function (byteOffset, val) {\n        this._dv.setInt32(byteOffset, val, true);\n    };\n    /**\n     * Write an int8 value to the specified offset.\n     *\n     * @param {number} byteOffset The offset from the beginning of the buffer.\n     * @param {number} val The value to store.\n     * @returns {void}\n     */\n    Segment.prototype.setInt8 = function (byteOffset, val) {\n        this._dv.setInt8(byteOffset, val);\n    };\n    /**\n     * Write an int64 value to the specified offset.\n     *\n     * @param {number} byteOffset The offset from the beginning of the buffer.\n     * @param {Int64} val The value to store.\n     * @returns {void}\n     */\n    Segment.prototype.setInt64 = function (byteOffset, val) {\n        this._dv.setUint8(byteOffset, val.buffer[0]);\n        this._dv.setUint8(byteOffset + 1, val.buffer[1]);\n        this._dv.setUint8(byteOffset + 2, val.buffer[2]);\n        this._dv.setUint8(byteOffset + 3, val.buffer[3]);\n        this._dv.setUint8(byteOffset + 4, val.buffer[4]);\n        this._dv.setUint8(byteOffset + 5, val.buffer[5]);\n        this._dv.setUint8(byteOffset + 6, val.buffer[6]);\n        this._dv.setUint8(byteOffset + 7, val.buffer[7]);\n    };\n    /**\n     * Write a uint16 value to the specified offset.\n     *\n     * @param {number} byteOffset The offset from the beginning of the buffer.\n     * @param {number} val The value to store.\n     * @returns {void}\n     */\n    Segment.prototype.setUint16 = function (byteOffset, val) {\n        this._dv.setUint16(byteOffset, val, true);\n    };\n    /**\n     * Write a uint32 value to the specified offset.\n     *\n     * @param {number} byteOffset The offset from the beginning of the buffer.\n     * @param {number} val The value to store.\n     * @returns {void}\n     */\n    Segment.prototype.setUint32 = function (byteOffset, val) {\n        this._dv.setUint32(byteOffset, val, true);\n    };\n    /**\n     * Write a uint64 value to the specified offset.\n     * TODO: benchmark other ways to perform this write operation.\n     *\n     * @param {number} byteOffset The offset from the beginning of the buffer.\n     * @param {Uint64} val The value to store.\n     * @returns {void}\n     */\n    Segment.prototype.setUint64 = function (byteOffset, val) {\n        this._dv.setUint8(byteOffset + 0, val.buffer[0]);\n        this._dv.setUint8(byteOffset + 1, val.buffer[1]);\n        this._dv.setUint8(byteOffset + 2, val.buffer[2]);\n        this._dv.setUint8(byteOffset + 3, val.buffer[3]);\n        this._dv.setUint8(byteOffset + 4, val.buffer[4]);\n        this._dv.setUint8(byteOffset + 5, val.buffer[5]);\n        this._dv.setUint8(byteOffset + 6, val.buffer[6]);\n        this._dv.setUint8(byteOffset + 7, val.buffer[7]);\n    };\n    /**\n     * Write a uint8 (byte) value to the specified offset.\n     *\n     * @param {number} byteOffset The offset from the beginning of the buffer.\n     * @param {number} val The value to store.\n     * @returns {void}\n     */\n    Segment.prototype.setUint8 = function (byteOffset, val) {\n        this._dv.setUint8(byteOffset, val);\n    };\n    /**\n     * Write a zero word (8 bytes) to the specified offset. This is slightly faster than calling `setUint64` or\n     * `setFloat64` with a zero value.\n     *\n     * Benchmark: http://jsben.ch/#/dUdPI\n     *\n     * @param {number} byteOffset The offset of the word to set to zero.\n     * @returns {void}\n     */\n    Segment.prototype.setWordZero = function (byteOffset) {\n        this._dv.setFloat64(byteOffset, 0, constants_1.NATIVE_LITTLE_ENDIAN);\n    };\n    Segment.prototype.toString = function () {\n        return util_1.format('Segment_id:%d,off:%a,len:%a,cap:%a', this.id, this.byteLength, this.byteOffset, this.buffer.byteLength);\n    };\n    return Segment;\n}());\nexports.Segment = Segment;\n\n//# sourceMappingURL=segment.js.map\n"]},"metadata":{},"sourceType":"script"}