{"ast":null,"code":"\"use strict\";\n/**\n * @author jdiaz5513\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar tslib_1 = require(\"tslib\");\n\nvar debug_1 = require(\"debug\");\n\nvar constants_1 = require(\"../../constants\");\n\nvar types_1 = require(\"../../types\");\n\nvar util_1 = require(\"../../util\");\n\nvar list_element_size_1 = require(\"../list-element-size\");\n\nvar object_size_1 = require(\"../object-size\");\n\nvar data_1 = require(\"./data\");\n\nvar list_1 = require(\"./list\");\n\nvar pointer_1 = require(\"./pointer\");\n\nvar pointer_type_1 = require(\"./pointer-type\");\n\nvar text_1 = require(\"./text\");\n\nvar errors_1 = require(\"../../errors\");\n\nvar trace = debug_1.default('capnp:struct');\ntrace('load'); // Used to apply bit masks (default values).\n\nvar TMP_WORD = new DataView(new ArrayBuffer(8));\n\nvar Struct =\n/** @class */\nfunction (_super) {\n  tslib_1.__extends(Struct, _super);\n  /**\n   * Create a new pointer to a struct.\n   *\n   * @constructor {Struct}\n   * @param {Segment} segment The segment the pointer resides in.\n   * @param {number} byteOffset The offset from the beginning of the segment to the beginning of the pointer data.\n   * @param {any} [depthLimit=MAX_DEPTH] The nesting depth limit for this object.\n   * @param {number} [compositeIndex] If set, then this pointer is actually a reference to a composite list\n   * (`this._getPointerTargetType() === PointerType.LIST`), and this number is used as the index of the struct within\n   * the list. It is not valid to call `initStruct()` on a composite struct â€“ the struct contents are initialized when\n   * the list pointer is initialized.\n   */\n\n\n  function Struct(segment, byteOffset, depthLimit, compositeIndex) {\n    if (depthLimit === void 0) {\n      depthLimit = constants_1.MAX_DEPTH;\n    }\n\n    var _this = _super.call(this, segment, byteOffset, depthLimit) || this;\n\n    _this._capnp.compositeIndex = compositeIndex;\n    _this._capnp.compositeList = compositeIndex !== undefined;\n    return _this;\n  }\n\n  Struct.toString = function () {\n    return this._capnp.displayName;\n  };\n\n  Struct.prototype.toString = function () {\n    return \"Struct_\" + _super.prototype.toString.call(this) + (\"\" + (this._capnp.compositeIndex === undefined ? '' : \",ci:\" + this._capnp.compositeIndex));\n  };\n\n  Struct._capnp = {\n    displayName: 'Struct'\n  };\n  Struct.getAs = getAs;\n  Struct.getBit = getBit;\n  Struct.getData = getData;\n  Struct.getFloat32 = getFloat32;\n  Struct.getFloat64 = getFloat64;\n  Struct.getUint8 = getUint8;\n  Struct.getUint16 = getUint16;\n  Struct.getUint32 = getUint32;\n  Struct.getUint64 = getUint64;\n  Struct.getInt8 = getInt8;\n  Struct.getInt16 = getInt16;\n  Struct.getInt32 = getInt32;\n  Struct.getInt64 = getInt64;\n  Struct.getList = getList;\n  Struct.getPointer = getPointer;\n  Struct.getPointerAs = getPointerAs;\n  Struct.getStruct = getStruct;\n  Struct.getText = getText;\n  Struct.initData = initData;\n  Struct.initList = initList;\n  Struct.initStruct = initStruct;\n  Struct.initStructAt = initStructAt;\n  Struct.setBit = setBit;\n  Struct.setFloat32 = setFloat32;\n  Struct.setFloat64 = setFloat64;\n  Struct.setUint8 = setUint8;\n  Struct.setUint16 = setUint16;\n  Struct.setUint32 = setUint32;\n  Struct.setUint64 = setUint64;\n  Struct.setInt8 = setInt8;\n  Struct.setInt16 = setInt16;\n  Struct.setInt32 = setInt32;\n  Struct.setInt64 = setInt64;\n  Struct.setText = setText;\n  Struct.testWhich = testWhich;\n  return Struct;\n}(pointer_1.Pointer);\n\nexports.Struct = Struct;\n/**\n * Initialize a struct with the provided object size. This will allocate new space for the struct contents, ideally in\n * the same segment as this pointer.\n *\n * @param {ObjectSize} size An object describing the size of the struct's data and pointer sections.\n * @param {Struct} s The struct to initialize.\n * @returns {void}\n */\n\nfunction initStruct(size, s) {\n  if (s._capnp.compositeIndex !== undefined) throw new Error(util_1.format(errors_1.PTR_INIT_COMPOSITE_STRUCT, s)); // Make sure to clear existing contents before overwriting the pointer data (erase is a noop if already empty).\n\n  pointer_1.erase(s);\n  var c = s.segment.allocate(object_size_1.getByteLength(size));\n  var res = pointer_1.initPointer(c.segment, c.byteOffset, s);\n  pointer_1.setStructPointer(res.offsetWords, size, res.pointer);\n}\n\nexports.initStruct = initStruct;\n\nfunction initStructAt(index, StructClass, p) {\n  var s = getPointerAs(index, StructClass, p);\n  initStruct(StructClass._capnp.size, s);\n  return s;\n}\n\nexports.initStructAt = initStructAt;\n/**\n * Make a shallow copy of a struct's contents and update the pointer to point to the new content. The data and pointer\n * sections will be resized to the provided size.\n *\n * WARNING: This method can cause data loss if `dstSize` is smaller than the original size!\n *\n * @param {ObjectSize} dstSize The desired size for the struct contents.\n * @param {Struct} s The struct to resize.\n * @returns {void}\n */\n\nfunction resize(dstSize, s) {\n  var srcSize = getSize(s);\n  var srcContent = pointer_1.getContent(s);\n  var dstContent = s.segment.allocate(object_size_1.getByteLength(dstSize)); // Only copy the data section for now. The pointer section will need to be rewritten.\n\n  dstContent.segment.copyWords(dstContent.byteOffset, srcContent.segment, srcContent.byteOffset, Math.min(object_size_1.getDataWordLength(srcSize), object_size_1.getDataWordLength(dstSize)));\n  var res = pointer_1.initPointer(dstContent.segment, dstContent.byteOffset, s);\n  pointer_1.setStructPointer(res.offsetWords, dstSize, res.pointer); // Iterate through the new pointer section and update the offsets so they point to the right place. This is a bit\n  // more complicated than it appears due to the fact that the original pointers could have been far pointers, and\n  // the new pointers might need to be allocated as far pointers if the segment is full.\n\n  for (var i = 0; i < Math.min(srcSize.pointerLength, dstSize.pointerLength); i++) {\n    var srcPtr = new pointer_1.Pointer(srcContent.segment, srcContent.byteOffset + srcSize.dataByteLength + i * 8);\n    var srcPtrTarget = pointer_1.followFars(srcPtr);\n    var srcPtrContent = pointer_1.getContent(srcPtr);\n    var dstPtr = new pointer_1.Pointer(dstContent.segment, dstContent.byteOffset + dstSize.dataByteLength + i * 8); // For composite lists the offset needs to point to the tag word, not the first element which is what getContent\n    // returns.\n\n    if (pointer_1.getTargetPointerType(srcPtr) === pointer_type_1.PointerType.LIST && pointer_1.getTargetListElementSize(srcPtr) === list_element_size_1.ListElementSize.COMPOSITE) {\n      srcPtrContent.byteOffset -= 8;\n    }\n\n    var r = pointer_1.initPointer(srcPtrContent.segment, srcPtrContent.byteOffset, dstPtr); // Read the old pointer data, but discard the original offset.\n\n    var a = srcPtrTarget.segment.getUint8(srcPtrTarget.byteOffset) & 0x03;\n    var b = srcPtrTarget.segment.getUint32(srcPtrTarget.byteOffset + 4);\n    r.pointer.segment.setUint32(r.pointer.byteOffset, a | r.offsetWords << 2);\n    r.pointer.segment.setUint32(r.pointer.byteOffset + 4, b);\n  } // Zero out the old data and pointer sections.\n\n\n  srcContent.segment.fillZeroWords(srcContent.byteOffset, object_size_1.getWordLength(srcSize));\n}\n\nexports.resize = resize;\n\nfunction adopt(src, s) {\n  if (s._capnp.compositeIndex !== undefined) throw new Error(util_1.format(errors_1.PTR_ADOPT_COMPOSITE_STRUCT, s));\n  pointer_1.Pointer.adopt(src, s);\n}\n\nexports.adopt = adopt;\n\nfunction disown(s) {\n  if (s._capnp.compositeIndex !== undefined) throw new Error(util_1.format(errors_1.PTR_DISOWN_COMPOSITE_STRUCT, s));\n  return pointer_1.Pointer.disown(s);\n}\n\nexports.disown = disown;\n/**\n * Convert a struct to a struct of the provided class. Particularly useful when casting to nested group types.\n *\n * @protected\n * @template T\n * @param {StructCtor<T>} StructClass The struct class to convert to. Not particularly useful if `Struct`.\n * @param {Struct} s The struct to convert.\n * @returns {T} A new instance of the desired struct class pointing to the same location.\n */\n\nfunction getAs(StructClass, s) {\n  return new StructClass(s.segment, s.byteOffset, s._capnp.depthLimit, s._capnp.compositeIndex);\n}\n\nexports.getAs = getAs;\n/**\n * Read a boolean (bit) value out of a struct.\n *\n * @protected\n * @param {number} bitOffset The offset in **bits** from the start of the data section.\n * @param {Struct} s The struct to read from.\n * @param {DataView} [defaultMask] The default value as a DataView.\n * @returns {boolean} The value.\n */\n\nfunction getBit(bitOffset, s, defaultMask) {\n  var byteOffset = Math.floor(bitOffset / 8);\n  var bitMask = 1 << bitOffset % 8;\n  checkDataBounds(byteOffset, 1, s);\n  var ds = getDataSection(s);\n  var v = ds.segment.getUint8(ds.byteOffset + byteOffset);\n  if (defaultMask === undefined) return (v & bitMask) !== 0;\n  var defaultValue = defaultMask.getUint8(0);\n  return ((v ^ defaultValue) & bitMask) !== 0;\n}\n\nexports.getBit = getBit;\n\nfunction getData(index, s) {\n  checkPointerBounds(index, s);\n  var ps = getPointerSection(s);\n  ps.byteOffset += index * 8;\n  var l = new data_1.Data(ps.segment, ps.byteOffset, s._capnp.depthLimit - 1);\n\n  if (pointer_1.isNull(l)) {\n    list_1.List.initList(list_element_size_1.ListElementSize.BYTE, 0, l);\n  }\n\n  return l;\n}\n\nexports.getData = getData;\n\nfunction getDataSection(s) {\n  return pointer_1.getContent(s);\n}\n\nexports.getDataSection = getDataSection;\n/**\n * Read a float32 value out of a struct.\n *\n * @param {number} byteOffset The offset in bytes from the start of the data section.\n * @param {Struct} s The struct to read from.\n * @param {DataView} [defaultMask] The default value as a DataView.\n * @returns {number} The value.\n */\n\nfunction getFloat32(byteOffset, s, defaultMask) {\n  checkDataBounds(byteOffset, 4, s);\n  var ds = getDataSection(s);\n  if (defaultMask === undefined) return ds.segment.getFloat32(ds.byteOffset + byteOffset);\n  var v = ds.segment.getUint32(ds.byteOffset + byteOffset) ^ defaultMask.getUint32(0, true);\n  TMP_WORD.setUint32(0, v, constants_1.NATIVE_LITTLE_ENDIAN);\n  return TMP_WORD.getFloat32(0, constants_1.NATIVE_LITTLE_ENDIAN);\n}\n\nexports.getFloat32 = getFloat32;\n/**\n * Read a float64 value out of this segment.\n *\n * @param {number} byteOffset The offset in bytes from the start of the data section.\n * @param {Struct} s The struct to read from.\n * @param {DataView} [defaultMask] The default value as a DataView.\n * @returns {number} The value.\n */\n\nfunction getFloat64(byteOffset, s, defaultMask) {\n  checkDataBounds(byteOffset, 8, s);\n  var ds = getDataSection(s);\n\n  if (defaultMask !== undefined) {\n    var lo = ds.segment.getUint32(ds.byteOffset + byteOffset) ^ defaultMask.getUint32(0, true);\n    var hi = ds.segment.getUint32(ds.byteOffset + byteOffset + 4) ^ defaultMask.getUint32(4, true);\n    TMP_WORD.setUint32(0, lo, constants_1.NATIVE_LITTLE_ENDIAN);\n    TMP_WORD.setUint32(4, hi, constants_1.NATIVE_LITTLE_ENDIAN);\n    return TMP_WORD.getFloat64(0, constants_1.NATIVE_LITTLE_ENDIAN);\n  }\n\n  return ds.segment.getFloat64(ds.byteOffset + byteOffset);\n}\n\nexports.getFloat64 = getFloat64;\n/**\n * Read an int16 value out of this segment.\n *\n * @param {number} byteOffset The offset in bytes from the start of the data section.\n * @param {Struct} s The struct to read from.\n * @param {DataView} [defaultMask] The default value as a DataView.\n * @returns {number} The value.\n */\n\nfunction getInt16(byteOffset, s, defaultMask) {\n  checkDataBounds(byteOffset, 2, s);\n  var ds = getDataSection(s);\n  if (defaultMask === undefined) return ds.segment.getInt16(ds.byteOffset + byteOffset);\n  var v = ds.segment.getUint16(ds.byteOffset + byteOffset) ^ defaultMask.getUint16(0, true);\n  TMP_WORD.setUint16(0, v, constants_1.NATIVE_LITTLE_ENDIAN);\n  return TMP_WORD.getInt16(0, constants_1.NATIVE_LITTLE_ENDIAN);\n}\n\nexports.getInt16 = getInt16;\n/**\n * Read an int32 value out of this segment.\n *\n * @param {number} byteOffset The offset in bytes from the start of the data section.\n * @param {Struct} s The struct to read from.\n * @param {DataView} [defaultMask] The default value as a DataView.\n * @returns {number} The value.\n */\n\nfunction getInt32(byteOffset, s, defaultMask) {\n  checkDataBounds(byteOffset, 4, s);\n  var ds = getDataSection(s);\n  if (defaultMask === undefined) return ds.segment.getInt32(ds.byteOffset + byteOffset);\n  var v = ds.segment.getUint32(ds.byteOffset + byteOffset) ^ defaultMask.getUint16(0, true);\n  TMP_WORD.setUint32(0, v, constants_1.NATIVE_LITTLE_ENDIAN);\n  return TMP_WORD.getInt32(0, constants_1.NATIVE_LITTLE_ENDIAN);\n}\n\nexports.getInt32 = getInt32;\n/**\n * Read an int64 value out of this segment.\n *\n * @param {number} byteOffset The offset in bytes from the start of the data section.\n * @param {Struct} s The struct to read from.\n * @param {DataView} [defaultMask] The default value as a DataView.\n * @returns {number} The value.\n */\n\nfunction getInt64(byteOffset, s, defaultMask) {\n  checkDataBounds(byteOffset, 8, s);\n  var ds = getDataSection(s);\n  if (defaultMask === undefined) return ds.segment.getInt64(ds.byteOffset + byteOffset);\n  var lo = ds.segment.getUint32(ds.byteOffset + byteOffset) ^ defaultMask.getUint32(0, true);\n  var hi = ds.segment.getUint32(ds.byteOffset + byteOffset + 4) ^ defaultMask.getUint32(4, true);\n  TMP_WORD.setUint32(0, lo, constants_1.NATIVE_LITTLE_ENDIAN);\n  TMP_WORD.setUint32(4, hi, constants_1.NATIVE_LITTLE_ENDIAN);\n  return new types_1.Int64(new Uint8Array(TMP_WORD.buffer.slice(0)));\n}\n\nexports.getInt64 = getInt64;\n/**\n * Read an int8 value out of this segment.\n *\n * @param {number} byteOffset The offset in bytes from the start of the data section.\n * @param {Struct} s The struct to read from.\n * @param {DataView} [defaultMask] The default value as a DataView.\n * @returns {number} The value.\n */\n\nfunction getInt8(byteOffset, s, defaultMask) {\n  checkDataBounds(byteOffset, 1, s);\n  var ds = getDataSection(s);\n  if (defaultMask === undefined) return ds.segment.getInt8(ds.byteOffset + byteOffset);\n  var v = ds.segment.getUint8(ds.byteOffset + byteOffset) ^ defaultMask.getUint8(0);\n  TMP_WORD.setUint8(0, v);\n  return TMP_WORD.getInt8(0);\n}\n\nexports.getInt8 = getInt8;\n\nfunction getList(index, ListClass, s) {\n  checkPointerBounds(index, s);\n  var ps = getPointerSection(s);\n  ps.byteOffset += index * 8;\n  var l = new ListClass(ps.segment, ps.byteOffset, s._capnp.depthLimit - 1);\n\n  if (pointer_1.isNull(l)) {\n    list_1.List.initList(ListClass._capnp.size, 0, l, ListClass._capnp.compositeSize);\n  } else if (ListClass._capnp.compositeSize !== undefined) {\n    // If this is a composite list we need to be sure the composite elements are big enough to hold everything as\n    // specified in the schema. If the new schema has added fields we'll need to \"resize\" (shallow-copy) the list so\n    // it has room for the new fields.\n    var srcSize = pointer_1.getTargetCompositeListSize(l);\n    var dstSize = ListClass._capnp.compositeSize;\n\n    if (dstSize.dataByteLength > srcSize.dataByteLength || dstSize.pointerLength > srcSize.pointerLength) {\n      var srcContent = pointer_1.getContent(l);\n      var srcLength = pointer_1.getTargetListLength(l);\n      trace('resizing composite list %s due to protocol upgrade, new size: %d', l, object_size_1.getByteLength(dstSize) * srcLength); // Allocate an extra 8 bytes for the tag.\n\n      var dstContent = l.segment.allocate(object_size_1.getByteLength(dstSize) * srcLength + 8);\n      var res = pointer_1.initPointer(dstContent.segment, dstContent.byteOffset, l);\n      pointer_1.setListPointer(res.offsetWords, ListClass._capnp.size, srcLength, res.pointer, dstSize); // Write the new tag word.\n\n      pointer_1.setStructPointer(srcLength, dstSize, dstContent); // Seek ahead past the tag word before copying the content.\n\n      dstContent.byteOffset += 8;\n\n      for (var i = 0; i < srcLength; i++) {\n        var srcElementOffset = srcContent.byteOffset + i * object_size_1.getByteLength(srcSize);\n        var dstElementOffset = dstContent.byteOffset + i * object_size_1.getByteLength(dstSize); // Copy the data section.\n\n        dstContent.segment.copyWords(dstElementOffset, srcContent.segment, srcElementOffset, object_size_1.getWordLength(srcSize)); // Iterate through the pointers and update the offsets so they point to the right place.\n\n        for (var j = 0; j < srcSize.pointerLength; j++) {\n          var srcPtr = new pointer_1.Pointer(srcContent.segment, srcElementOffset + srcSize.dataByteLength + j * 8);\n          var dstPtr = new pointer_1.Pointer(dstContent.segment, dstElementOffset + dstSize.dataByteLength + j * 8);\n          var srcPtrTarget = pointer_1.followFars(srcPtr);\n          var srcPtrContent = pointer_1.getContent(srcPtr);\n\n          if (pointer_1.getTargetPointerType(srcPtr) === pointer_type_1.PointerType.LIST && pointer_1.getTargetListElementSize(srcPtr) === list_element_size_1.ListElementSize.COMPOSITE) {\n            srcPtrContent.byteOffset -= 8;\n          }\n\n          var r = pointer_1.initPointer(srcPtrContent.segment, srcPtrContent.byteOffset, dstPtr); // Read the old pointer data, but discard the original offset.\n\n          var a = srcPtrTarget.segment.getUint8(srcPtrTarget.byteOffset) & 0x03;\n          var b = srcPtrTarget.segment.getUint32(srcPtrTarget.byteOffset + 4);\n          r.pointer.segment.setUint32(r.pointer.byteOffset, a | r.offsetWords << 2);\n          r.pointer.segment.setUint32(r.pointer.byteOffset + 4, b);\n        }\n      } // Zero out the old content.\n\n\n      srcContent.segment.fillZeroWords(srcContent.byteOffset, object_size_1.getWordLength(srcSize) * srcLength);\n    }\n  }\n\n  return l;\n}\n\nexports.getList = getList;\n\nfunction getPointer(index, s) {\n  checkPointerBounds(index, s);\n  var ps = getPointerSection(s);\n  ps.byteOffset += index * 8;\n  return new pointer_1.Pointer(ps.segment, ps.byteOffset, s._capnp.depthLimit - 1);\n}\n\nexports.getPointer = getPointer;\n\nfunction getPointerAs(index, PointerClass, s) {\n  checkPointerBounds(index, s);\n  var ps = getPointerSection(s);\n  ps.byteOffset += index * 8;\n  return new PointerClass(ps.segment, ps.byteOffset, s._capnp.depthLimit - 1);\n}\n\nexports.getPointerAs = getPointerAs;\n\nfunction getPointerSection(s) {\n  var ps = pointer_1.getContent(s);\n  ps.byteOffset += util_1.padToWord(getSize(s).dataByteLength);\n  return ps;\n}\n\nexports.getPointerSection = getPointerSection;\n\nfunction getSize(s) {\n  if (s._capnp.compositeIndex !== undefined) {\n    // For composite lists the object size is stored in a tag word right before the content.\n    var c = pointer_1.getContent(s, true);\n    c.byteOffset -= 8;\n    return pointer_1.getStructSize(c);\n  }\n\n  return pointer_1.getTargetStructSize(s);\n}\n\nexports.getSize = getSize;\n\nfunction getStruct(index, StructClass, s) {\n  var t = getPointerAs(index, StructClass, s);\n\n  if (pointer_1.isNull(t)) {\n    initStruct(StructClass._capnp.size, t);\n  } else {\n    pointer_1.validate(pointer_type_1.PointerType.STRUCT, t);\n    var ts = pointer_1.getTargetStructSize(t); // This can happen when reading a struct that was constructed with an older version of the same schema, and new\n    // fields were added to the struct. A shallow copy of the struct will be made so that there's enough room for the\n    // data and pointer sections. This will unfortunately leave a \"hole\" of zeroes in the message, but that hole will\n    // at least compress well.\n\n    if (ts.dataByteLength < StructClass._capnp.size.dataByteLength || ts.pointerLength < StructClass._capnp.size.pointerLength) {\n      trace('need to resize child struct %s', t);\n      resize(StructClass._capnp.size, t);\n    }\n  }\n\n  return t;\n}\n\nexports.getStruct = getStruct;\n\nfunction getText(index, s) {\n  return text_1.Text.fromPointer(getPointer(index, s)).get(0);\n}\n\nexports.getText = getText;\n/**\n * Read an uint16 value out of a struct..\n *\n * @param {number} byteOffset The offset in bytes from the start of the data section.\n * @param {Struct} s The struct to read from.\n * @param {DataView} [defaultMask] The default value as a DataView.\n * @returns {number} The value.\n */\n\nfunction getUint16(byteOffset, s, defaultMask) {\n  checkDataBounds(byteOffset, 2, s);\n  var ds = getDataSection(s);\n  if (defaultMask === undefined) return ds.segment.getUint16(ds.byteOffset + byteOffset);\n  return ds.segment.getUint16(ds.byteOffset + byteOffset) ^ defaultMask.getUint16(0, true);\n}\n\nexports.getUint16 = getUint16;\n/**\n * Read an uint32 value out of a struct.\n *\n * @param {number} byteOffset The offset in bytes from the start of the data section.\n * @param {Struct} s The struct to read from.\n * @param {DataView} [defaultMask] The default value as a DataView.\n * @returns {number} The value.\n */\n\nfunction getUint32(byteOffset, s, defaultMask) {\n  checkDataBounds(byteOffset, 4, s);\n  var ds = getDataSection(s);\n  if (defaultMask === undefined) return ds.segment.getUint32(ds.byteOffset + byteOffset);\n  return ds.segment.getUint32(ds.byteOffset + byteOffset) ^ defaultMask.getUint32(0, true);\n}\n\nexports.getUint32 = getUint32;\n/**\n * Read an uint64 value out of a struct.\n *\n * @param {number} byteOffset The offset in bytes from the start of the data section.\n * @param {Struct} s The struct to read from.\n * @param {DataView} [defaultMask] The default value as a DataView.\n * @returns {number} The value.\n */\n\nfunction getUint64(byteOffset, s, defaultMask) {\n  checkDataBounds(byteOffset, 8, s);\n  var ds = getDataSection(s);\n  if (defaultMask === undefined) return ds.segment.getUint64(ds.byteOffset + byteOffset);\n  var lo = ds.segment.getUint32(ds.byteOffset + byteOffset) ^ defaultMask.getUint32(0, true);\n  var hi = ds.segment.getUint32(ds.byteOffset + byteOffset + 4) ^ defaultMask.getUint32(4, true);\n  TMP_WORD.setUint32(0, lo, constants_1.NATIVE_LITTLE_ENDIAN);\n  TMP_WORD.setUint32(4, hi, constants_1.NATIVE_LITTLE_ENDIAN);\n  return new types_1.Uint64(new Uint8Array(TMP_WORD.buffer.slice(0)));\n}\n\nexports.getUint64 = getUint64;\n/**\n * Read an uint8 value out of a struct.\n *\n * @param {number} byteOffset The offset in bytes from the start of the data section.\n * @param {Struct} s The struct to read from.\n * @param {DataView} [defaultMask] The default value as a DataView.\n * @returns {number} The value.\n */\n\nfunction getUint8(byteOffset, s, defaultMask) {\n  checkDataBounds(byteOffset, 1, s);\n  var ds = getDataSection(s);\n  if (defaultMask === undefined) return ds.segment.getUint8(ds.byteOffset + byteOffset);\n  return ds.segment.getUint8(ds.byteOffset + byteOffset) ^ defaultMask.getUint8(0);\n}\n\nexports.getUint8 = getUint8;\n\nfunction initData(index, length, s) {\n  checkPointerBounds(index, s);\n  var ps = getPointerSection(s);\n  ps.byteOffset += index * 8;\n  var l = new data_1.Data(ps.segment, ps.byteOffset, s._capnp.depthLimit - 1);\n  pointer_1.erase(l);\n  list_1.List.initList(list_element_size_1.ListElementSize.BYTE, length, l);\n  return l;\n}\n\nexports.initData = initData;\n\nfunction initList(index, ListClass, length, s) {\n  checkPointerBounds(index, s);\n  var ps = getPointerSection(s);\n  ps.byteOffset += index * 8;\n  var l = new ListClass(ps.segment, ps.byteOffset, s._capnp.depthLimit - 1);\n  pointer_1.erase(l);\n  list_1.List.initList(ListClass._capnp.size, length, l, ListClass._capnp.compositeSize);\n  return l;\n}\n\nexports.initList = initList;\n/**\n * Write a boolean (bit) value to the struct.\n *\n * @protected\n * @param {number} bitOffset The offset in **bits** from the start of the data section.\n * @param {boolean} value The value to write (writes a 0 for `false`, 1 for `true`).\n * @param {Struct} s The struct to write to.\n * @param {DataView} [defaultMask] The default value as a DataView.\n * @returns {void}\n */\n\nfunction setBit(bitOffset, value, s, defaultMask) {\n  var byteOffset = Math.floor(bitOffset / 8);\n  var bitMask = 1 << bitOffset % 8;\n  checkDataBounds(byteOffset, 1, s);\n  var ds = getDataSection(s);\n  var b = ds.segment.getUint8(ds.byteOffset + byteOffset); // If the default mask bit is set, that means `true` values are actually written as `0`.\n\n  if (defaultMask !== undefined) value = (defaultMask.getUint8(0) & bitMask) !== 0 ? !value : value;\n  ds.segment.setUint8(ds.byteOffset + byteOffset, value ? b | bitMask : b & ~bitMask);\n}\n\nexports.setBit = setBit;\n/**\n * Write a primitive float32 value to the struct.\n *\n * @protected\n * @param {number} byteOffset The offset in bytes from the start of the data section.\n * @param {number} value The value to write.\n * @param {Struct} s The struct to write to.\n * @param {DataView} [defaultMask] The default value as a DataView.\n * @returns {void}\n */\n\nfunction setFloat32(byteOffset, value, s, defaultMask) {\n  checkDataBounds(byteOffset, 4, s);\n  var ds = getDataSection(s);\n\n  if (defaultMask !== undefined) {\n    TMP_WORD.setFloat32(0, value, constants_1.NATIVE_LITTLE_ENDIAN);\n    var v = TMP_WORD.getUint32(0, constants_1.NATIVE_LITTLE_ENDIAN) ^ defaultMask.getUint32(0, true);\n    ds.segment.setUint32(ds.byteOffset + byteOffset, v);\n    return;\n  }\n\n  ds.segment.setFloat32(ds.byteOffset + byteOffset, value);\n}\n\nexports.setFloat32 = setFloat32;\n/**\n * Write a primitive float64 value to the struct.\n *\n * @protected\n * @param {number} byteOffset The offset in bytes from the start of the data section.\n * @param {number} value The value to write.\n * @param {Struct} s The struct to write to.\n * @param {DataView} [defaultMask] The default value as a DataView.\n * @returns {void}\n */\n\nfunction setFloat64(byteOffset, value, s, defaultMask) {\n  checkDataBounds(byteOffset, 8, s);\n  var ds = getDataSection(s);\n\n  if (defaultMask !== undefined) {\n    TMP_WORD.setFloat64(0, value, constants_1.NATIVE_LITTLE_ENDIAN);\n    var lo = TMP_WORD.getUint32(0, constants_1.NATIVE_LITTLE_ENDIAN) ^ defaultMask.getUint32(0, true);\n    var hi = TMP_WORD.getUint32(4, constants_1.NATIVE_LITTLE_ENDIAN) ^ defaultMask.getUint32(4, true);\n    ds.segment.setUint32(ds.byteOffset + byteOffset, lo);\n    ds.segment.setUint32(ds.byteOffset + byteOffset + 4, hi);\n    return;\n  }\n\n  ds.segment.setFloat64(ds.byteOffset + byteOffset, value);\n}\n\nexports.setFloat64 = setFloat64;\n/**\n * Write a primitive int16 value to the struct.\n *\n * @protected\n * @param {number} byteOffset The offset in bytes from the start of the data section.\n * @param {number} value The value to write.\n * @param {Struct} s The struct to write to.\n * @param {DataView} [defaultMask] The default value as a DataView.\n * @returns {void}\n */\n\nfunction setInt16(byteOffset, value, s, defaultMask) {\n  checkDataBounds(byteOffset, 2, s);\n  var ds = getDataSection(s);\n\n  if (defaultMask !== undefined) {\n    TMP_WORD.setInt16(0, value, constants_1.NATIVE_LITTLE_ENDIAN);\n    var v = TMP_WORD.getUint16(0, constants_1.NATIVE_LITTLE_ENDIAN) ^ defaultMask.getUint16(0, true);\n    ds.segment.setUint16(ds.byteOffset + byteOffset, v);\n    return;\n  }\n\n  ds.segment.setInt16(ds.byteOffset + byteOffset, value);\n}\n\nexports.setInt16 = setInt16;\n/**\n * Write a primitive int32 value to the struct.\n *\n * @protected\n * @param {number} byteOffset The offset in bytes from the start of the data section.\n * @param {number} value The value to write.\n * @param {Struct} s The struct to write to.\n * @param {DataView} [defaultMask] The default value as a DataView.\n * @returns {void}\n */\n\nfunction setInt32(byteOffset, value, s, defaultMask) {\n  checkDataBounds(byteOffset, 4, s);\n  var ds = getDataSection(s);\n\n  if (defaultMask !== undefined) {\n    TMP_WORD.setInt32(0, value, constants_1.NATIVE_LITTLE_ENDIAN);\n    var v = TMP_WORD.getUint32(0, constants_1.NATIVE_LITTLE_ENDIAN) ^ defaultMask.getUint32(0, true);\n    ds.segment.setUint32(ds.byteOffset + byteOffset, v);\n    return;\n  }\n\n  ds.segment.setInt32(ds.byteOffset + byteOffset, value);\n}\n\nexports.setInt32 = setInt32;\n/**\n * Write a primitive int64 value to the struct.\n *\n * @protected\n * @param {number} byteOffset The offset in bytes from the start of the data section.\n * @param {number} value The value to write.\n * @param {Struct} s The struct to write to.\n * @param {DataView} [defaultMask] The default value as a DataView.\n * @returns {void}\n */\n\nfunction setInt64(byteOffset, value, s, defaultMask) {\n  checkDataBounds(byteOffset, 8, s);\n  var ds = getDataSection(s);\n\n  if (defaultMask !== undefined) {\n    // PERF: We could cast the Int64 to a DataView to apply the mask using four 32-bit reads, but we already have a\n    // typed array so avoiding the object allocation turns out to be slightly faster. Int64 is guaranteed to be in\n    // little-endian format by design.\n    for (var i = 0; i < 8; i++) {\n      ds.segment.setUint8(ds.byteOffset + byteOffset + i, value.buffer[i] ^ defaultMask.getUint8(i));\n    }\n\n    return;\n  }\n\n  ds.segment.setInt64(ds.byteOffset + byteOffset, value);\n}\n\nexports.setInt64 = setInt64;\n/**\n * Write a primitive int8 value to the struct.\n *\n * @protected\n * @param {number} byteOffset The offset in bytes from the start of the data section.\n * @param {number} value The value to write.\n * @param {Struct} s The struct to write to.\n * @param {DataView} [defaultMask] The default value as a DataView.\n * @returns {void}\n */\n\nfunction setInt8(byteOffset, value, s, defaultMask) {\n  checkDataBounds(byteOffset, 1, s);\n  var ds = getDataSection(s);\n\n  if (defaultMask !== undefined) {\n    TMP_WORD.setInt8(0, value);\n    var v = TMP_WORD.getUint8(0) ^ defaultMask.getUint8(0);\n    ds.segment.setUint8(ds.byteOffset + byteOffset, v);\n    return;\n  }\n\n  ds.segment.setInt8(ds.byteOffset + byteOffset, value);\n}\n\nexports.setInt8 = setInt8;\n\nfunction setPointer(index, value, s) {\n  pointer_1.copyFrom(value, getPointer(index, s));\n}\n\nexports.setPointer = setPointer;\n\nfunction setText(index, value, s) {\n  text_1.Text.fromPointer(getPointer(index, s)).set(0, value);\n}\n\nexports.setText = setText;\n/**\n * Write a primitive uint16 value to the struct.\n *\n * @protected\n * @param {number} byteOffset The offset in bytes from the start of the data section.\n * @param {number} value The value to write.\n * @param {Struct} s The struct to write to.\n * @param {DataView} [defaultMask] The default value as a DataView.\n * @returns {void}\n */\n\nfunction setUint16(byteOffset, value, s, defaultMask) {\n  checkDataBounds(byteOffset, 2, s);\n  var ds = getDataSection(s);\n  if (defaultMask !== undefined) value ^= defaultMask.getUint16(0, true);\n  ds.segment.setUint16(ds.byteOffset + byteOffset, value);\n}\n\nexports.setUint16 = setUint16;\n/**\n * Write a primitive uint32 value to the struct.\n *\n * @protected\n * @param {number} byteOffset The offset in bytes from the start of the data section.\n * @param {number} value The value to write.\n * @param {Struct} s The struct to write to.\n * @param {DataView} [defaultMask] The default value as a DataView.\n * @returns {void}\n */\n\nfunction setUint32(byteOffset, value, s, defaultMask) {\n  checkDataBounds(byteOffset, 4, s);\n  var ds = getDataSection(s);\n  if (defaultMask !== undefined) value ^= defaultMask.getUint32(0, true);\n  ds.segment.setUint32(ds.byteOffset + byteOffset, value);\n}\n\nexports.setUint32 = setUint32;\n/**\n * Write a primitive uint64 value to the struct.\n *\n * @protected\n * @param {number} byteOffset The offset in bytes from the start of the data section.\n * @param {number} value The value to write.\n * @param {Struct} s The struct to write to.\n * @param {DataView} [defaultMask] The default value as a DataView.\n * @returns {void}\n */\n\nfunction setUint64(byteOffset, value, s, defaultMask) {\n  checkDataBounds(byteOffset, 8, s);\n  var ds = getDataSection(s);\n\n  if (defaultMask !== undefined) {\n    // PERF: We could cast the Uint64 to a DataView to apply the mask using four 32-bit reads, but we already have a\n    // typed array so avoiding the object allocation turns out to be slightly faster. Uint64 is guaranteed to be in\n    // little-endian format by design.\n    for (var i = 0; i < 8; i++) {\n      ds.segment.setUint8(ds.byteOffset + byteOffset + i, value.buffer[i] ^ defaultMask.getUint8(i));\n    }\n\n    return;\n  }\n\n  ds.segment.setUint64(ds.byteOffset + byteOffset, value);\n}\n\nexports.setUint64 = setUint64;\n/**\n * Write a primitive uint8 value to the struct.\n *\n * @protected\n * @param {number} byteOffset The offset in bytes from the start of the data section.\n * @param {number} value The value to write.\n * @param {Struct} s The struct to write to.\n * @param {DataView} [defaultMask] The default value as a DataView.\n * @returns {void}\n */\n\nfunction setUint8(byteOffset, value, s, defaultMask) {\n  checkDataBounds(byteOffset, 1, s);\n  var ds = getDataSection(s);\n  if (defaultMask !== undefined) value ^= defaultMask.getUint8(0);\n  ds.segment.setUint8(ds.byteOffset + byteOffset, value);\n}\n\nexports.setUint8 = setUint8;\n\nfunction testWhich(name, found, wanted, s) {\n  if (found !== wanted) throw new Error(util_1.format(errors_1.PTR_INVALID_UNION_ACCESS, s, name, found, wanted));\n}\n\nexports.testWhich = testWhich;\n\nfunction checkDataBounds(byteOffset, byteLength, s) {\n  var dataByteLength = getSize(s).dataByteLength;\n\n  if (byteOffset < 0 || byteLength < 0 || byteOffset + byteLength > dataByteLength) {\n    throw new Error(util_1.format(errors_1.PTR_STRUCT_DATA_OUT_OF_BOUNDS, s, byteLength, byteOffset, dataByteLength));\n  }\n}\n\nexports.checkDataBounds = checkDataBounds;\n\nfunction checkPointerBounds(index, s) {\n  var pointerLength = getSize(s).pointerLength;\n\n  if (index < 0 || index >= pointerLength) {\n    throw new Error(util_1.format(errors_1.PTR_STRUCT_POINTER_OUT_OF_BOUNDS, s, index, pointerLength));\n  }\n}\n\nexports.checkPointerBounds = checkPointerBounds;","map":{"version":3,"sources":["serialization/pointers/struct.ts"],"names":[],"mappings":"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","sourceRoot":"../../../src","sourcesContent":["\"use strict\";\n/**\n * @author jdiaz5513\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = require(\"tslib\");\nvar debug_1 = require(\"debug\");\nvar constants_1 = require(\"../../constants\");\nvar types_1 = require(\"../../types\");\nvar util_1 = require(\"../../util\");\nvar list_element_size_1 = require(\"../list-element-size\");\nvar object_size_1 = require(\"../object-size\");\nvar data_1 = require(\"./data\");\nvar list_1 = require(\"./list\");\nvar pointer_1 = require(\"./pointer\");\nvar pointer_type_1 = require(\"./pointer-type\");\nvar text_1 = require(\"./text\");\nvar errors_1 = require(\"../../errors\");\nvar trace = debug_1.default('capnp:struct');\ntrace('load');\n// Used to apply bit masks (default values).\nvar TMP_WORD = new DataView(new ArrayBuffer(8));\nvar Struct = /** @class */ (function (_super) {\n    tslib_1.__extends(Struct, _super);\n    /**\n     * Create a new pointer to a struct.\n     *\n     * @constructor {Struct}\n     * @param {Segment} segment The segment the pointer resides in.\n     * @param {number} byteOffset The offset from the beginning of the segment to the beginning of the pointer data.\n     * @param {any} [depthLimit=MAX_DEPTH] The nesting depth limit for this object.\n     * @param {number} [compositeIndex] If set, then this pointer is actually a reference to a composite list\n     * (`this._getPointerTargetType() === PointerType.LIST`), and this number is used as the index of the struct within\n     * the list. It is not valid to call `initStruct()` on a composite struct â€“ the struct contents are initialized when\n     * the list pointer is initialized.\n     */\n    function Struct(segment, byteOffset, depthLimit, compositeIndex) {\n        if (depthLimit === void 0) { depthLimit = constants_1.MAX_DEPTH; }\n        var _this = _super.call(this, segment, byteOffset, depthLimit) || this;\n        _this._capnp.compositeIndex = compositeIndex;\n        _this._capnp.compositeList = compositeIndex !== undefined;\n        return _this;\n    }\n    Struct.toString = function () {\n        return this._capnp.displayName;\n    };\n    Struct.prototype.toString = function () {\n        return \"Struct_\" + _super.prototype.toString.call(this) +\n            (\"\" + (this._capnp.compositeIndex === undefined ? '' : \",ci:\" + this._capnp.compositeIndex));\n    };\n    Struct._capnp = {\n        displayName: 'Struct',\n    };\n    Struct.getAs = getAs;\n    Struct.getBit = getBit;\n    Struct.getData = getData;\n    Struct.getFloat32 = getFloat32;\n    Struct.getFloat64 = getFloat64;\n    Struct.getUint8 = getUint8;\n    Struct.getUint16 = getUint16;\n    Struct.getUint32 = getUint32;\n    Struct.getUint64 = getUint64;\n    Struct.getInt8 = getInt8;\n    Struct.getInt16 = getInt16;\n    Struct.getInt32 = getInt32;\n    Struct.getInt64 = getInt64;\n    Struct.getList = getList;\n    Struct.getPointer = getPointer;\n    Struct.getPointerAs = getPointerAs;\n    Struct.getStruct = getStruct;\n    Struct.getText = getText;\n    Struct.initData = initData;\n    Struct.initList = initList;\n    Struct.initStruct = initStruct;\n    Struct.initStructAt = initStructAt;\n    Struct.setBit = setBit;\n    Struct.setFloat32 = setFloat32;\n    Struct.setFloat64 = setFloat64;\n    Struct.setUint8 = setUint8;\n    Struct.setUint16 = setUint16;\n    Struct.setUint32 = setUint32;\n    Struct.setUint64 = setUint64;\n    Struct.setInt8 = setInt8;\n    Struct.setInt16 = setInt16;\n    Struct.setInt32 = setInt32;\n    Struct.setInt64 = setInt64;\n    Struct.setText = setText;\n    Struct.testWhich = testWhich;\n    return Struct;\n}(pointer_1.Pointer));\nexports.Struct = Struct;\n/**\n * Initialize a struct with the provided object size. This will allocate new space for the struct contents, ideally in\n * the same segment as this pointer.\n *\n * @param {ObjectSize} size An object describing the size of the struct's data and pointer sections.\n * @param {Struct} s The struct to initialize.\n * @returns {void}\n */\nfunction initStruct(size, s) {\n    if (s._capnp.compositeIndex !== undefined)\n        throw new Error(util_1.format(errors_1.PTR_INIT_COMPOSITE_STRUCT, s));\n    // Make sure to clear existing contents before overwriting the pointer data (erase is a noop if already empty).\n    pointer_1.erase(s);\n    var c = s.segment.allocate(object_size_1.getByteLength(size));\n    var res = pointer_1.initPointer(c.segment, c.byteOffset, s);\n    pointer_1.setStructPointer(res.offsetWords, size, res.pointer);\n}\nexports.initStruct = initStruct;\nfunction initStructAt(index, StructClass, p) {\n    var s = getPointerAs(index, StructClass, p);\n    initStruct(StructClass._capnp.size, s);\n    return s;\n}\nexports.initStructAt = initStructAt;\n/**\n * Make a shallow copy of a struct's contents and update the pointer to point to the new content. The data and pointer\n * sections will be resized to the provided size.\n *\n * WARNING: This method can cause data loss if `dstSize` is smaller than the original size!\n *\n * @param {ObjectSize} dstSize The desired size for the struct contents.\n * @param {Struct} s The struct to resize.\n * @returns {void}\n */\nfunction resize(dstSize, s) {\n    var srcSize = getSize(s);\n    var srcContent = pointer_1.getContent(s);\n    var dstContent = s.segment.allocate(object_size_1.getByteLength(dstSize));\n    // Only copy the data section for now. The pointer section will need to be rewritten.\n    dstContent.segment.copyWords(dstContent.byteOffset, srcContent.segment, srcContent.byteOffset, Math.min(object_size_1.getDataWordLength(srcSize), object_size_1.getDataWordLength(dstSize)));\n    var res = pointer_1.initPointer(dstContent.segment, dstContent.byteOffset, s);\n    pointer_1.setStructPointer(res.offsetWords, dstSize, res.pointer);\n    // Iterate through the new pointer section and update the offsets so they point to the right place. This is a bit\n    // more complicated than it appears due to the fact that the original pointers could have been far pointers, and\n    // the new pointers might need to be allocated as far pointers if the segment is full.\n    for (var i = 0; i < Math.min(srcSize.pointerLength, dstSize.pointerLength); i++) {\n        var srcPtr = new pointer_1.Pointer(srcContent.segment, srcContent.byteOffset + srcSize.dataByteLength + i * 8);\n        var srcPtrTarget = pointer_1.followFars(srcPtr);\n        var srcPtrContent = pointer_1.getContent(srcPtr);\n        var dstPtr = new pointer_1.Pointer(dstContent.segment, dstContent.byteOffset + dstSize.dataByteLength + i * 8);\n        // For composite lists the offset needs to point to the tag word, not the first element which is what getContent\n        // returns.\n        if (pointer_1.getTargetPointerType(srcPtr) === pointer_type_1.PointerType.LIST &&\n            pointer_1.getTargetListElementSize(srcPtr) === list_element_size_1.ListElementSize.COMPOSITE) {\n            srcPtrContent.byteOffset -= 8;\n        }\n        var r = pointer_1.initPointer(srcPtrContent.segment, srcPtrContent.byteOffset, dstPtr);\n        // Read the old pointer data, but discard the original offset.\n        var a = srcPtrTarget.segment.getUint8(srcPtrTarget.byteOffset) & 0x03;\n        var b = srcPtrTarget.segment.getUint32(srcPtrTarget.byteOffset + 4);\n        r.pointer.segment.setUint32(r.pointer.byteOffset, a | (r.offsetWords << 2));\n        r.pointer.segment.setUint32(r.pointer.byteOffset + 4, b);\n    }\n    // Zero out the old data and pointer sections.\n    srcContent.segment.fillZeroWords(srcContent.byteOffset, object_size_1.getWordLength(srcSize));\n}\nexports.resize = resize;\nfunction adopt(src, s) {\n    if (s._capnp.compositeIndex !== undefined)\n        throw new Error(util_1.format(errors_1.PTR_ADOPT_COMPOSITE_STRUCT, s));\n    pointer_1.Pointer.adopt(src, s);\n}\nexports.adopt = adopt;\nfunction disown(s) {\n    if (s._capnp.compositeIndex !== undefined)\n        throw new Error(util_1.format(errors_1.PTR_DISOWN_COMPOSITE_STRUCT, s));\n    return pointer_1.Pointer.disown(s);\n}\nexports.disown = disown;\n/**\n * Convert a struct to a struct of the provided class. Particularly useful when casting to nested group types.\n *\n * @protected\n * @template T\n * @param {StructCtor<T>} StructClass The struct class to convert to. Not particularly useful if `Struct`.\n * @param {Struct} s The struct to convert.\n * @returns {T} A new instance of the desired struct class pointing to the same location.\n */\nfunction getAs(StructClass, s) {\n    return new StructClass(s.segment, s.byteOffset, s._capnp.depthLimit, s._capnp.compositeIndex);\n}\nexports.getAs = getAs;\n/**\n * Read a boolean (bit) value out of a struct.\n *\n * @protected\n * @param {number} bitOffset The offset in **bits** from the start of the data section.\n * @param {Struct} s The struct to read from.\n * @param {DataView} [defaultMask] The default value as a DataView.\n * @returns {boolean} The value.\n */\nfunction getBit(bitOffset, s, defaultMask) {\n    var byteOffset = Math.floor(bitOffset / 8);\n    var bitMask = 1 << bitOffset % 8;\n    checkDataBounds(byteOffset, 1, s);\n    var ds = getDataSection(s);\n    var v = ds.segment.getUint8(ds.byteOffset + byteOffset);\n    if (defaultMask === undefined)\n        return (v & bitMask) !== 0;\n    var defaultValue = defaultMask.getUint8(0);\n    return ((v ^ defaultValue) & bitMask) !== 0;\n}\nexports.getBit = getBit;\nfunction getData(index, s) {\n    checkPointerBounds(index, s);\n    var ps = getPointerSection(s);\n    ps.byteOffset += index * 8;\n    var l = new data_1.Data(ps.segment, ps.byteOffset, s._capnp.depthLimit - 1);\n    if (pointer_1.isNull(l)) {\n        list_1.List.initList(list_element_size_1.ListElementSize.BYTE, 0, l);\n    }\n    return l;\n}\nexports.getData = getData;\nfunction getDataSection(s) {\n    return pointer_1.getContent(s);\n}\nexports.getDataSection = getDataSection;\n/**\n * Read a float32 value out of a struct.\n *\n * @param {number} byteOffset The offset in bytes from the start of the data section.\n * @param {Struct} s The struct to read from.\n * @param {DataView} [defaultMask] The default value as a DataView.\n * @returns {number} The value.\n */\nfunction getFloat32(byteOffset, s, defaultMask) {\n    checkDataBounds(byteOffset, 4, s);\n    var ds = getDataSection(s);\n    if (defaultMask === undefined)\n        return ds.segment.getFloat32(ds.byteOffset + byteOffset);\n    var v = ds.segment.getUint32(ds.byteOffset + byteOffset) ^ defaultMask.getUint32(0, true);\n    TMP_WORD.setUint32(0, v, constants_1.NATIVE_LITTLE_ENDIAN);\n    return TMP_WORD.getFloat32(0, constants_1.NATIVE_LITTLE_ENDIAN);\n}\nexports.getFloat32 = getFloat32;\n/**\n * Read a float64 value out of this segment.\n *\n * @param {number} byteOffset The offset in bytes from the start of the data section.\n * @param {Struct} s The struct to read from.\n * @param {DataView} [defaultMask] The default value as a DataView.\n * @returns {number} The value.\n */\nfunction getFloat64(byteOffset, s, defaultMask) {\n    checkDataBounds(byteOffset, 8, s);\n    var ds = getDataSection(s);\n    if (defaultMask !== undefined) {\n        var lo = ds.segment.getUint32(ds.byteOffset + byteOffset) ^ defaultMask.getUint32(0, true);\n        var hi = ds.segment.getUint32(ds.byteOffset + byteOffset + 4) ^ defaultMask.getUint32(4, true);\n        TMP_WORD.setUint32(0, lo, constants_1.NATIVE_LITTLE_ENDIAN);\n        TMP_WORD.setUint32(4, hi, constants_1.NATIVE_LITTLE_ENDIAN);\n        return TMP_WORD.getFloat64(0, constants_1.NATIVE_LITTLE_ENDIAN);\n    }\n    return ds.segment.getFloat64(ds.byteOffset + byteOffset);\n}\nexports.getFloat64 = getFloat64;\n/**\n * Read an int16 value out of this segment.\n *\n * @param {number} byteOffset The offset in bytes from the start of the data section.\n * @param {Struct} s The struct to read from.\n * @param {DataView} [defaultMask] The default value as a DataView.\n * @returns {number} The value.\n */\nfunction getInt16(byteOffset, s, defaultMask) {\n    checkDataBounds(byteOffset, 2, s);\n    var ds = getDataSection(s);\n    if (defaultMask === undefined)\n        return ds.segment.getInt16(ds.byteOffset + byteOffset);\n    var v = ds.segment.getUint16(ds.byteOffset + byteOffset) ^ defaultMask.getUint16(0, true);\n    TMP_WORD.setUint16(0, v, constants_1.NATIVE_LITTLE_ENDIAN);\n    return TMP_WORD.getInt16(0, constants_1.NATIVE_LITTLE_ENDIAN);\n}\nexports.getInt16 = getInt16;\n/**\n * Read an int32 value out of this segment.\n *\n * @param {number} byteOffset The offset in bytes from the start of the data section.\n * @param {Struct} s The struct to read from.\n * @param {DataView} [defaultMask] The default value as a DataView.\n * @returns {number} The value.\n */\nfunction getInt32(byteOffset, s, defaultMask) {\n    checkDataBounds(byteOffset, 4, s);\n    var ds = getDataSection(s);\n    if (defaultMask === undefined)\n        return ds.segment.getInt32(ds.byteOffset + byteOffset);\n    var v = ds.segment.getUint32(ds.byteOffset + byteOffset) ^ defaultMask.getUint16(0, true);\n    TMP_WORD.setUint32(0, v, constants_1.NATIVE_LITTLE_ENDIAN);\n    return TMP_WORD.getInt32(0, constants_1.NATIVE_LITTLE_ENDIAN);\n}\nexports.getInt32 = getInt32;\n/**\n * Read an int64 value out of this segment.\n *\n * @param {number} byteOffset The offset in bytes from the start of the data section.\n * @param {Struct} s The struct to read from.\n * @param {DataView} [defaultMask] The default value as a DataView.\n * @returns {number} The value.\n */\nfunction getInt64(byteOffset, s, defaultMask) {\n    checkDataBounds(byteOffset, 8, s);\n    var ds = getDataSection(s);\n    if (defaultMask === undefined)\n        return ds.segment.getInt64(ds.byteOffset + byteOffset);\n    var lo = ds.segment.getUint32(ds.byteOffset + byteOffset) ^ defaultMask.getUint32(0, true);\n    var hi = ds.segment.getUint32(ds.byteOffset + byteOffset + 4) ^ defaultMask.getUint32(4, true);\n    TMP_WORD.setUint32(0, lo, constants_1.NATIVE_LITTLE_ENDIAN);\n    TMP_WORD.setUint32(4, hi, constants_1.NATIVE_LITTLE_ENDIAN);\n    return new types_1.Int64(new Uint8Array(TMP_WORD.buffer.slice(0)));\n}\nexports.getInt64 = getInt64;\n/**\n * Read an int8 value out of this segment.\n *\n * @param {number} byteOffset The offset in bytes from the start of the data section.\n * @param {Struct} s The struct to read from.\n * @param {DataView} [defaultMask] The default value as a DataView.\n * @returns {number} The value.\n */\nfunction getInt8(byteOffset, s, defaultMask) {\n    checkDataBounds(byteOffset, 1, s);\n    var ds = getDataSection(s);\n    if (defaultMask === undefined)\n        return ds.segment.getInt8(ds.byteOffset + byteOffset);\n    var v = ds.segment.getUint8(ds.byteOffset + byteOffset) ^ defaultMask.getUint8(0);\n    TMP_WORD.setUint8(0, v);\n    return TMP_WORD.getInt8(0);\n}\nexports.getInt8 = getInt8;\nfunction getList(index, ListClass, s) {\n    checkPointerBounds(index, s);\n    var ps = getPointerSection(s);\n    ps.byteOffset += index * 8;\n    var l = new ListClass(ps.segment, ps.byteOffset, s._capnp.depthLimit - 1);\n    if (pointer_1.isNull(l)) {\n        list_1.List.initList(ListClass._capnp.size, 0, l, ListClass._capnp.compositeSize);\n    }\n    else if (ListClass._capnp.compositeSize !== undefined) {\n        // If this is a composite list we need to be sure the composite elements are big enough to hold everything as\n        // specified in the schema. If the new schema has added fields we'll need to \"resize\" (shallow-copy) the list so\n        // it has room for the new fields.\n        var srcSize = pointer_1.getTargetCompositeListSize(l);\n        var dstSize = ListClass._capnp.compositeSize;\n        if (dstSize.dataByteLength > srcSize.dataByteLength || dstSize.pointerLength > srcSize.pointerLength) {\n            var srcContent = pointer_1.getContent(l);\n            var srcLength = pointer_1.getTargetListLength(l);\n            trace('resizing composite list %s due to protocol upgrade, new size: %d', l, object_size_1.getByteLength(dstSize) * srcLength);\n            // Allocate an extra 8 bytes for the tag.\n            var dstContent = l.segment.allocate(object_size_1.getByteLength(dstSize) * srcLength + 8);\n            var res = pointer_1.initPointer(dstContent.segment, dstContent.byteOffset, l);\n            pointer_1.setListPointer(res.offsetWords, ListClass._capnp.size, srcLength, res.pointer, dstSize);\n            // Write the new tag word.\n            pointer_1.setStructPointer(srcLength, dstSize, dstContent);\n            // Seek ahead past the tag word before copying the content.\n            dstContent.byteOffset += 8;\n            for (var i = 0; i < srcLength; i++) {\n                var srcElementOffset = srcContent.byteOffset + i * object_size_1.getByteLength(srcSize);\n                var dstElementOffset = dstContent.byteOffset + i * object_size_1.getByteLength(dstSize);\n                // Copy the data section.\n                dstContent.segment.copyWords(dstElementOffset, srcContent.segment, srcElementOffset, object_size_1.getWordLength(srcSize));\n                // Iterate through the pointers and update the offsets so they point to the right place.\n                for (var j = 0; j < srcSize.pointerLength; j++) {\n                    var srcPtr = new pointer_1.Pointer(srcContent.segment, srcElementOffset + srcSize.dataByteLength + j * 8);\n                    var dstPtr = new pointer_1.Pointer(dstContent.segment, dstElementOffset + dstSize.dataByteLength + j * 8);\n                    var srcPtrTarget = pointer_1.followFars(srcPtr);\n                    var srcPtrContent = pointer_1.getContent(srcPtr);\n                    if (pointer_1.getTargetPointerType(srcPtr) === pointer_type_1.PointerType.LIST &&\n                        pointer_1.getTargetListElementSize(srcPtr) === list_element_size_1.ListElementSize.COMPOSITE) {\n                        srcPtrContent.byteOffset -= 8;\n                    }\n                    var r = pointer_1.initPointer(srcPtrContent.segment, srcPtrContent.byteOffset, dstPtr);\n                    // Read the old pointer data, but discard the original offset.\n                    var a = srcPtrTarget.segment.getUint8(srcPtrTarget.byteOffset) & 0x03;\n                    var b = srcPtrTarget.segment.getUint32(srcPtrTarget.byteOffset + 4);\n                    r.pointer.segment.setUint32(r.pointer.byteOffset, a | (r.offsetWords << 2));\n                    r.pointer.segment.setUint32(r.pointer.byteOffset + 4, b);\n                }\n            }\n            // Zero out the old content.\n            srcContent.segment.fillZeroWords(srcContent.byteOffset, object_size_1.getWordLength(srcSize) * srcLength);\n        }\n    }\n    return l;\n}\nexports.getList = getList;\nfunction getPointer(index, s) {\n    checkPointerBounds(index, s);\n    var ps = getPointerSection(s);\n    ps.byteOffset += index * 8;\n    return new pointer_1.Pointer(ps.segment, ps.byteOffset, s._capnp.depthLimit - 1);\n}\nexports.getPointer = getPointer;\nfunction getPointerAs(index, PointerClass, s) {\n    checkPointerBounds(index, s);\n    var ps = getPointerSection(s);\n    ps.byteOffset += index * 8;\n    return new PointerClass(ps.segment, ps.byteOffset, s._capnp.depthLimit - 1);\n}\nexports.getPointerAs = getPointerAs;\nfunction getPointerSection(s) {\n    var ps = pointer_1.getContent(s);\n    ps.byteOffset += util_1.padToWord(getSize(s).dataByteLength);\n    return ps;\n}\nexports.getPointerSection = getPointerSection;\nfunction getSize(s) {\n    if (s._capnp.compositeIndex !== undefined) {\n        // For composite lists the object size is stored in a tag word right before the content.\n        var c = pointer_1.getContent(s, true);\n        c.byteOffset -= 8;\n        return pointer_1.getStructSize(c);\n    }\n    return pointer_1.getTargetStructSize(s);\n}\nexports.getSize = getSize;\nfunction getStruct(index, StructClass, s) {\n    var t = getPointerAs(index, StructClass, s);\n    if (pointer_1.isNull(t)) {\n        initStruct(StructClass._capnp.size, t);\n    }\n    else {\n        pointer_1.validate(pointer_type_1.PointerType.STRUCT, t);\n        var ts = pointer_1.getTargetStructSize(t);\n        // This can happen when reading a struct that was constructed with an older version of the same schema, and new\n        // fields were added to the struct. A shallow copy of the struct will be made so that there's enough room for the\n        // data and pointer sections. This will unfortunately leave a \"hole\" of zeroes in the message, but that hole will\n        // at least compress well.\n        if (ts.dataByteLength < StructClass._capnp.size.dataByteLength\n            || ts.pointerLength < StructClass._capnp.size.pointerLength) {\n            trace('need to resize child struct %s', t);\n            resize(StructClass._capnp.size, t);\n        }\n    }\n    return t;\n}\nexports.getStruct = getStruct;\nfunction getText(index, s) {\n    return text_1.Text.fromPointer(getPointer(index, s)).get(0);\n}\nexports.getText = getText;\n/**\n * Read an uint16 value out of a struct..\n *\n * @param {number} byteOffset The offset in bytes from the start of the data section.\n * @param {Struct} s The struct to read from.\n * @param {DataView} [defaultMask] The default value as a DataView.\n * @returns {number} The value.\n */\nfunction getUint16(byteOffset, s, defaultMask) {\n    checkDataBounds(byteOffset, 2, s);\n    var ds = getDataSection(s);\n    if (defaultMask === undefined)\n        return ds.segment.getUint16(ds.byteOffset + byteOffset);\n    return ds.segment.getUint16(ds.byteOffset + byteOffset) ^ defaultMask.getUint16(0, true);\n}\nexports.getUint16 = getUint16;\n/**\n * Read an uint32 value out of a struct.\n *\n * @param {number} byteOffset The offset in bytes from the start of the data section.\n * @param {Struct} s The struct to read from.\n * @param {DataView} [defaultMask] The default value as a DataView.\n * @returns {number} The value.\n */\nfunction getUint32(byteOffset, s, defaultMask) {\n    checkDataBounds(byteOffset, 4, s);\n    var ds = getDataSection(s);\n    if (defaultMask === undefined)\n        return ds.segment.getUint32(ds.byteOffset + byteOffset);\n    return ds.segment.getUint32(ds.byteOffset + byteOffset) ^ defaultMask.getUint32(0, true);\n}\nexports.getUint32 = getUint32;\n/**\n * Read an uint64 value out of a struct.\n *\n * @param {number} byteOffset The offset in bytes from the start of the data section.\n * @param {Struct} s The struct to read from.\n * @param {DataView} [defaultMask] The default value as a DataView.\n * @returns {number} The value.\n */\nfunction getUint64(byteOffset, s, defaultMask) {\n    checkDataBounds(byteOffset, 8, s);\n    var ds = getDataSection(s);\n    if (defaultMask === undefined)\n        return ds.segment.getUint64(ds.byteOffset + byteOffset);\n    var lo = ds.segment.getUint32(ds.byteOffset + byteOffset) ^ defaultMask.getUint32(0, true);\n    var hi = ds.segment.getUint32(ds.byteOffset + byteOffset + 4) ^ defaultMask.getUint32(4, true);\n    TMP_WORD.setUint32(0, lo, constants_1.NATIVE_LITTLE_ENDIAN);\n    TMP_WORD.setUint32(4, hi, constants_1.NATIVE_LITTLE_ENDIAN);\n    return new types_1.Uint64(new Uint8Array(TMP_WORD.buffer.slice(0)));\n}\nexports.getUint64 = getUint64;\n/**\n * Read an uint8 value out of a struct.\n *\n * @param {number} byteOffset The offset in bytes from the start of the data section.\n * @param {Struct} s The struct to read from.\n * @param {DataView} [defaultMask] The default value as a DataView.\n * @returns {number} The value.\n */\nfunction getUint8(byteOffset, s, defaultMask) {\n    checkDataBounds(byteOffset, 1, s);\n    var ds = getDataSection(s);\n    if (defaultMask === undefined)\n        return ds.segment.getUint8(ds.byteOffset + byteOffset);\n    return ds.segment.getUint8(ds.byteOffset + byteOffset) ^ defaultMask.getUint8(0);\n}\nexports.getUint8 = getUint8;\nfunction initData(index, length, s) {\n    checkPointerBounds(index, s);\n    var ps = getPointerSection(s);\n    ps.byteOffset += index * 8;\n    var l = new data_1.Data(ps.segment, ps.byteOffset, s._capnp.depthLimit - 1);\n    pointer_1.erase(l);\n    list_1.List.initList(list_element_size_1.ListElementSize.BYTE, length, l);\n    return l;\n}\nexports.initData = initData;\nfunction initList(index, ListClass, length, s) {\n    checkPointerBounds(index, s);\n    var ps = getPointerSection(s);\n    ps.byteOffset += index * 8;\n    var l = new ListClass(ps.segment, ps.byteOffset, s._capnp.depthLimit - 1);\n    pointer_1.erase(l);\n    list_1.List.initList(ListClass._capnp.size, length, l, ListClass._capnp.compositeSize);\n    return l;\n}\nexports.initList = initList;\n/**\n * Write a boolean (bit) value to the struct.\n *\n * @protected\n * @param {number} bitOffset The offset in **bits** from the start of the data section.\n * @param {boolean} value The value to write (writes a 0 for `false`, 1 for `true`).\n * @param {Struct} s The struct to write to.\n * @param {DataView} [defaultMask] The default value as a DataView.\n * @returns {void}\n */\nfunction setBit(bitOffset, value, s, defaultMask) {\n    var byteOffset = Math.floor(bitOffset / 8);\n    var bitMask = 1 << bitOffset % 8;\n    checkDataBounds(byteOffset, 1, s);\n    var ds = getDataSection(s);\n    var b = ds.segment.getUint8(ds.byteOffset + byteOffset);\n    // If the default mask bit is set, that means `true` values are actually written as `0`.\n    if (defaultMask !== undefined)\n        value = (defaultMask.getUint8(0) & bitMask) !== 0 ? !value : value;\n    ds.segment.setUint8(ds.byteOffset + byteOffset, value ? b | bitMask : b & ~bitMask);\n}\nexports.setBit = setBit;\n/**\n * Write a primitive float32 value to the struct.\n *\n * @protected\n * @param {number} byteOffset The offset in bytes from the start of the data section.\n * @param {number} value The value to write.\n * @param {Struct} s The struct to write to.\n * @param {DataView} [defaultMask] The default value as a DataView.\n * @returns {void}\n */\nfunction setFloat32(byteOffset, value, s, defaultMask) {\n    checkDataBounds(byteOffset, 4, s);\n    var ds = getDataSection(s);\n    if (defaultMask !== undefined) {\n        TMP_WORD.setFloat32(0, value, constants_1.NATIVE_LITTLE_ENDIAN);\n        var v = TMP_WORD.getUint32(0, constants_1.NATIVE_LITTLE_ENDIAN) ^ defaultMask.getUint32(0, true);\n        ds.segment.setUint32(ds.byteOffset + byteOffset, v);\n        return;\n    }\n    ds.segment.setFloat32(ds.byteOffset + byteOffset, value);\n}\nexports.setFloat32 = setFloat32;\n/**\n * Write a primitive float64 value to the struct.\n *\n * @protected\n * @param {number} byteOffset The offset in bytes from the start of the data section.\n * @param {number} value The value to write.\n * @param {Struct} s The struct to write to.\n * @param {DataView} [defaultMask] The default value as a DataView.\n * @returns {void}\n */\nfunction setFloat64(byteOffset, value, s, defaultMask) {\n    checkDataBounds(byteOffset, 8, s);\n    var ds = getDataSection(s);\n    if (defaultMask !== undefined) {\n        TMP_WORD.setFloat64(0, value, constants_1.NATIVE_LITTLE_ENDIAN);\n        var lo = TMP_WORD.getUint32(0, constants_1.NATIVE_LITTLE_ENDIAN) ^ defaultMask.getUint32(0, true);\n        var hi = TMP_WORD.getUint32(4, constants_1.NATIVE_LITTLE_ENDIAN) ^ defaultMask.getUint32(4, true);\n        ds.segment.setUint32(ds.byteOffset + byteOffset, lo);\n        ds.segment.setUint32(ds.byteOffset + byteOffset + 4, hi);\n        return;\n    }\n    ds.segment.setFloat64(ds.byteOffset + byteOffset, value);\n}\nexports.setFloat64 = setFloat64;\n/**\n * Write a primitive int16 value to the struct.\n *\n * @protected\n * @param {number} byteOffset The offset in bytes from the start of the data section.\n * @param {number} value The value to write.\n * @param {Struct} s The struct to write to.\n * @param {DataView} [defaultMask] The default value as a DataView.\n * @returns {void}\n */\nfunction setInt16(byteOffset, value, s, defaultMask) {\n    checkDataBounds(byteOffset, 2, s);\n    var ds = getDataSection(s);\n    if (defaultMask !== undefined) {\n        TMP_WORD.setInt16(0, value, constants_1.NATIVE_LITTLE_ENDIAN);\n        var v = TMP_WORD.getUint16(0, constants_1.NATIVE_LITTLE_ENDIAN) ^ defaultMask.getUint16(0, true);\n        ds.segment.setUint16(ds.byteOffset + byteOffset, v);\n        return;\n    }\n    ds.segment.setInt16(ds.byteOffset + byteOffset, value);\n}\nexports.setInt16 = setInt16;\n/**\n * Write a primitive int32 value to the struct.\n *\n * @protected\n * @param {number} byteOffset The offset in bytes from the start of the data section.\n * @param {number} value The value to write.\n * @param {Struct} s The struct to write to.\n * @param {DataView} [defaultMask] The default value as a DataView.\n * @returns {void}\n */\nfunction setInt32(byteOffset, value, s, defaultMask) {\n    checkDataBounds(byteOffset, 4, s);\n    var ds = getDataSection(s);\n    if (defaultMask !== undefined) {\n        TMP_WORD.setInt32(0, value, constants_1.NATIVE_LITTLE_ENDIAN);\n        var v = TMP_WORD.getUint32(0, constants_1.NATIVE_LITTLE_ENDIAN) ^ defaultMask.getUint32(0, true);\n        ds.segment.setUint32(ds.byteOffset + byteOffset, v);\n        return;\n    }\n    ds.segment.setInt32(ds.byteOffset + byteOffset, value);\n}\nexports.setInt32 = setInt32;\n/**\n * Write a primitive int64 value to the struct.\n *\n * @protected\n * @param {number} byteOffset The offset in bytes from the start of the data section.\n * @param {number} value The value to write.\n * @param {Struct} s The struct to write to.\n * @param {DataView} [defaultMask] The default value as a DataView.\n * @returns {void}\n */\nfunction setInt64(byteOffset, value, s, defaultMask) {\n    checkDataBounds(byteOffset, 8, s);\n    var ds = getDataSection(s);\n    if (defaultMask !== undefined) {\n        // PERF: We could cast the Int64 to a DataView to apply the mask using four 32-bit reads, but we already have a\n        // typed array so avoiding the object allocation turns out to be slightly faster. Int64 is guaranteed to be in\n        // little-endian format by design.\n        for (var i = 0; i < 8; i++) {\n            ds.segment.setUint8(ds.byteOffset + byteOffset + i, value.buffer[i] ^ defaultMask.getUint8(i));\n        }\n        return;\n    }\n    ds.segment.setInt64(ds.byteOffset + byteOffset, value);\n}\nexports.setInt64 = setInt64;\n/**\n * Write a primitive int8 value to the struct.\n *\n * @protected\n * @param {number} byteOffset The offset in bytes from the start of the data section.\n * @param {number} value The value to write.\n * @param {Struct} s The struct to write to.\n * @param {DataView} [defaultMask] The default value as a DataView.\n * @returns {void}\n */\nfunction setInt8(byteOffset, value, s, defaultMask) {\n    checkDataBounds(byteOffset, 1, s);\n    var ds = getDataSection(s);\n    if (defaultMask !== undefined) {\n        TMP_WORD.setInt8(0, value);\n        var v = TMP_WORD.getUint8(0) ^ defaultMask.getUint8(0);\n        ds.segment.setUint8(ds.byteOffset + byteOffset, v);\n        return;\n    }\n    ds.segment.setInt8(ds.byteOffset + byteOffset, value);\n}\nexports.setInt8 = setInt8;\nfunction setPointer(index, value, s) {\n    pointer_1.copyFrom(value, getPointer(index, s));\n}\nexports.setPointer = setPointer;\nfunction setText(index, value, s) {\n    text_1.Text.fromPointer(getPointer(index, s)).set(0, value);\n}\nexports.setText = setText;\n/**\n * Write a primitive uint16 value to the struct.\n *\n * @protected\n * @param {number} byteOffset The offset in bytes from the start of the data section.\n * @param {number} value The value to write.\n * @param {Struct} s The struct to write to.\n * @param {DataView} [defaultMask] The default value as a DataView.\n * @returns {void}\n */\nfunction setUint16(byteOffset, value, s, defaultMask) {\n    checkDataBounds(byteOffset, 2, s);\n    var ds = getDataSection(s);\n    if (defaultMask !== undefined)\n        value ^= defaultMask.getUint16(0, true);\n    ds.segment.setUint16(ds.byteOffset + byteOffset, value);\n}\nexports.setUint16 = setUint16;\n/**\n * Write a primitive uint32 value to the struct.\n *\n * @protected\n * @param {number} byteOffset The offset in bytes from the start of the data section.\n * @param {number} value The value to write.\n * @param {Struct} s The struct to write to.\n * @param {DataView} [defaultMask] The default value as a DataView.\n * @returns {void}\n */\nfunction setUint32(byteOffset, value, s, defaultMask) {\n    checkDataBounds(byteOffset, 4, s);\n    var ds = getDataSection(s);\n    if (defaultMask !== undefined)\n        value ^= defaultMask.getUint32(0, true);\n    ds.segment.setUint32(ds.byteOffset + byteOffset, value);\n}\nexports.setUint32 = setUint32;\n/**\n * Write a primitive uint64 value to the struct.\n *\n * @protected\n * @param {number} byteOffset The offset in bytes from the start of the data section.\n * @param {number} value The value to write.\n * @param {Struct} s The struct to write to.\n * @param {DataView} [defaultMask] The default value as a DataView.\n * @returns {void}\n */\nfunction setUint64(byteOffset, value, s, defaultMask) {\n    checkDataBounds(byteOffset, 8, s);\n    var ds = getDataSection(s);\n    if (defaultMask !== undefined) {\n        // PERF: We could cast the Uint64 to a DataView to apply the mask using four 32-bit reads, but we already have a\n        // typed array so avoiding the object allocation turns out to be slightly faster. Uint64 is guaranteed to be in\n        // little-endian format by design.\n        for (var i = 0; i < 8; i++) {\n            ds.segment.setUint8(ds.byteOffset + byteOffset + i, value.buffer[i] ^ defaultMask.getUint8(i));\n        }\n        return;\n    }\n    ds.segment.setUint64(ds.byteOffset + byteOffset, value);\n}\nexports.setUint64 = setUint64;\n/**\n * Write a primitive uint8 value to the struct.\n *\n * @protected\n * @param {number} byteOffset The offset in bytes from the start of the data section.\n * @param {number} value The value to write.\n * @param {Struct} s The struct to write to.\n * @param {DataView} [defaultMask] The default value as a DataView.\n * @returns {void}\n */\nfunction setUint8(byteOffset, value, s, defaultMask) {\n    checkDataBounds(byteOffset, 1, s);\n    var ds = getDataSection(s);\n    if (defaultMask !== undefined)\n        value ^= defaultMask.getUint8(0);\n    ds.segment.setUint8(ds.byteOffset + byteOffset, value);\n}\nexports.setUint8 = setUint8;\nfunction testWhich(name, found, wanted, s) {\n    if (found !== wanted)\n        throw new Error(util_1.format(errors_1.PTR_INVALID_UNION_ACCESS, s, name, found, wanted));\n}\nexports.testWhich = testWhich;\nfunction checkDataBounds(byteOffset, byteLength, s) {\n    var dataByteLength = getSize(s).dataByteLength;\n    if (byteOffset < 0 || byteLength < 0 || byteOffset + byteLength > dataByteLength) {\n        throw new Error(util_1.format(errors_1.PTR_STRUCT_DATA_OUT_OF_BOUNDS, s, byteLength, byteOffset, dataByteLength));\n    }\n}\nexports.checkDataBounds = checkDataBounds;\nfunction checkPointerBounds(index, s) {\n    var pointerLength = getSize(s).pointerLength;\n    if (index < 0 || index >= pointerLength) {\n        throw new Error(util_1.format(errors_1.PTR_STRUCT_POINTER_OUT_OF_BOUNDS, s, index, pointerLength));\n    }\n}\nexports.checkPointerBounds = checkPointerBounds;\n\n//# sourceMappingURL=struct.js.map\n"]},"metadata":{},"sourceType":"script"}