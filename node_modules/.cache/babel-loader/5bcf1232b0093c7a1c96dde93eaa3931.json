{"ast":null,"code":"\"use strict\";\n/**\n * @author jdiaz5513\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar debug_1 = require(\"debug\");\n\nvar constants_1 = require(\"../../constants\");\n\nvar errors_1 = require(\"../../errors\");\n\nvar util_1 = require(\"../../util\");\n\nvar arena_allocation_result_1 = require(\"./arena-allocation-result\");\n\nvar arena_kind_1 = require(\"./arena-kind\");\n\nvar trace = debug_1.default('capnp:arena:single');\ntrace('load');\n\nvar SingleSegmentArena =\n/** @class */\nfunction () {\n  function SingleSegmentArena(buffer) {\n    if (buffer === void 0) {\n      buffer = new ArrayBuffer(constants_1.DEFAULT_BUFFER_SIZE);\n    }\n\n    this.kind = arena_kind_1.ArenaKind.SINGLE_SEGMENT;\n    if ((buffer.byteLength & 7) !== 0) throw new Error(util_1.format(errors_1.SEG_NOT_WORD_ALIGNED, buffer.byteLength));\n    this.buffer = buffer;\n    trace('new %s', this);\n  }\n\n  SingleSegmentArena.prototype.toString = function () {\n    return util_1.format('SingleSegmentArena_len:%x', this.buffer.byteLength);\n  };\n\n  SingleSegmentArena.allocate = allocate;\n  SingleSegmentArena.getBuffer = getBuffer;\n  SingleSegmentArena.getNumSegments = getNumSegments;\n  return SingleSegmentArena;\n}();\n\nexports.SingleSegmentArena = SingleSegmentArena;\n\nfunction allocate(minSize, segments, s) {\n  trace('Allocating %x bytes for segment 0 in %s.', minSize, s);\n  var srcBuffer = segments.length > 0 ? segments[0].buffer : s.buffer;\n\n  if (minSize < constants_1.MIN_SINGLE_SEGMENT_GROWTH) {\n    minSize = constants_1.MIN_SINGLE_SEGMENT_GROWTH;\n  } else {\n    minSize = util_1.padToWord(minSize);\n  }\n\n  s.buffer = new ArrayBuffer(srcBuffer.byteLength + minSize); // PERF: Assume that the source and destination buffers are word-aligned and use Float64Array to copy them one word\n  // at a time.\n\n  new Float64Array(s.buffer).set(new Float64Array(srcBuffer));\n  return new arena_allocation_result_1.ArenaAllocationResult(0, s.buffer);\n}\n\nexports.allocate = allocate;\n\nfunction getBuffer(id, s) {\n  if (id !== 0) throw new Error(util_1.format(errors_1.SEG_GET_NON_ZERO_SINGLE, id));\n  return s.buffer;\n}\n\nexports.getBuffer = getBuffer;\n\nfunction getNumSegments() {\n  return 1;\n}\n\nexports.getNumSegments = getNumSegments;","map":{"version":3,"sources":["serialization/arena/single-segment-arena.ts"],"names":[],"mappings":"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","sourceRoot":"../../../src","sourcesContent":["\"use strict\";\n/**\n * @author jdiaz5513\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar debug_1 = require(\"debug\");\nvar constants_1 = require(\"../../constants\");\nvar errors_1 = require(\"../../errors\");\nvar util_1 = require(\"../../util\");\nvar arena_allocation_result_1 = require(\"./arena-allocation-result\");\nvar arena_kind_1 = require(\"./arena-kind\");\nvar trace = debug_1.default('capnp:arena:single');\ntrace('load');\nvar SingleSegmentArena = /** @class */ (function () {\n    function SingleSegmentArena(buffer) {\n        if (buffer === void 0) { buffer = new ArrayBuffer(constants_1.DEFAULT_BUFFER_SIZE); }\n        this.kind = arena_kind_1.ArenaKind.SINGLE_SEGMENT;\n        if ((buffer.byteLength & 7) !== 0)\n            throw new Error(util_1.format(errors_1.SEG_NOT_WORD_ALIGNED, buffer.byteLength));\n        this.buffer = buffer;\n        trace('new %s', this);\n    }\n    SingleSegmentArena.prototype.toString = function () { return util_1.format('SingleSegmentArena_len:%x', this.buffer.byteLength); };\n    SingleSegmentArena.allocate = allocate;\n    SingleSegmentArena.getBuffer = getBuffer;\n    SingleSegmentArena.getNumSegments = getNumSegments;\n    return SingleSegmentArena;\n}());\nexports.SingleSegmentArena = SingleSegmentArena;\nfunction allocate(minSize, segments, s) {\n    trace('Allocating %x bytes for segment 0 in %s.', minSize, s);\n    var srcBuffer = segments.length > 0 ? segments[0].buffer : s.buffer;\n    if (minSize < constants_1.MIN_SINGLE_SEGMENT_GROWTH) {\n        minSize = constants_1.MIN_SINGLE_SEGMENT_GROWTH;\n    }\n    else {\n        minSize = util_1.padToWord(minSize);\n    }\n    s.buffer = new ArrayBuffer(srcBuffer.byteLength + minSize);\n    // PERF: Assume that the source and destination buffers are word-aligned and use Float64Array to copy them one word\n    // at a time.\n    new Float64Array(s.buffer).set(new Float64Array(srcBuffer));\n    return new arena_allocation_result_1.ArenaAllocationResult(0, s.buffer);\n}\nexports.allocate = allocate;\nfunction getBuffer(id, s) {\n    if (id !== 0)\n        throw new Error(util_1.format(errors_1.SEG_GET_NON_ZERO_SINGLE, id));\n    return s.buffer;\n}\nexports.getBuffer = getBuffer;\nfunction getNumSegments() {\n    return 1;\n}\nexports.getNumSegments = getNumSegments;\n\n//# sourceMappingURL=single-segment-arena.js.map\n"]},"metadata":{},"sourceType":"script"}