{"ast":null,"code":"\"use strict\";\n/**\n * @author jdiaz5513\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar debug_1 = require(\"debug\");\n\nvar constants_1 = require(\"../constants\");\n\nvar errors_1 = require(\"../errors\");\n\nvar util_1 = require(\"../util\");\n\nvar trace = debug_1.default('capnp:uint64');\ntrace('load');\n/**\n * Represents an unsigned 64-bit integer stored using a Uint8Array in little-endian format. It's a little bit faster\n * than int64 because we don't need to keep track of the sign bit or perform two's compliment operations on set.\n *\n * You may convert this to a primitive number by calling `toNumber()` but be wary of precision loss!\n *\n * Note that overflow is not implemented, so negative numbers passed into `setValue()` will be negated first.\n *\n * The value passed in as the source buffer is expected to be in little-endian format.\n */\n\nvar Uint64 =\n/** @class */\nfunction () {\n  /**\n   * Creates a new instance; this is a no-frills constructor for speed. Use the factory methods if you need to convert\n   * from other types or use a different offset into the buffer.\n   *\n   * Will throw if the buffer is not at least 8 bytes long.\n   *\n   * @constructor\n   * @param {Uint8Array} buffer The buffer to use for this 64-bit word; the bytes must be in little-endian order.\n   */\n  function Uint64(buffer) {\n    if (buffer.byteLength < 8) throw new RangeError(errors_1.RANGE_INT64_UNDERFLOW);\n    this.buffer = buffer;\n  }\n\n  Uint64.fromArrayBuffer = function (source, offset, noCopy) {\n    if (offset === void 0) {\n      offset = 0;\n    }\n\n    if (noCopy === void 0) {\n      noCopy = false;\n    }\n\n    if (noCopy) return new this(new Uint8Array(source, offset, 8));\n    return new this(new Uint8Array(source.slice(offset, offset + 8)));\n  };\n\n  Uint64.fromDataView = function (source, offset, noCopy) {\n    if (offset === void 0) {\n      offset = 0;\n    }\n\n    if (noCopy === void 0) {\n      noCopy = false;\n    }\n\n    if (noCopy) return new this(new Uint8Array(source.buffer, source.byteOffset + offset, 8));\n    return new this(new Uint8Array(source.buffer.slice(source.byteOffset + offset, source.byteLength + offset + 8)));\n  };\n  /**\n   * Parse a hexadecimal string in **big endian format** as a Uint64 value.\n   *\n   * @static\n   * @param {string} source The source string.\n   * @returns {Uint64} The string parsed as a 64-bit unsigned integer.\n   */\n\n\n  Uint64.fromHexString = function (source) {\n    if (source.substr(0, 2) === '0x') source = source.substr(2);\n    if (source.length < 1) return Uint64.fromNumber(0);\n    if (source[0] === '-') throw new RangeError('Source must not be negative.');\n    source = util_1.pad(source, 16);\n    if (source.length !== 16) throw new RangeError('Source string must contain at most 16 hexadecimal digits.');\n    var bytes = source.toLowerCase().replace(/[^\\da-f]/g, '');\n    var buf = new Uint8Array(new ArrayBuffer(8));\n\n    for (var i = 0; i < 8; i++) buf[7 - i] = parseInt(bytes.substr(i * 2, 2), 16);\n\n    return new Uint64(buf);\n  };\n\n  Uint64.fromNumber = function (source) {\n    var ret = new this(new Uint8Array(8));\n    ret.setValue(source);\n    return ret;\n  };\n\n  Uint64.fromUint8Array = function (source, offset, noCopy) {\n    if (offset === void 0) {\n      offset = 0;\n    }\n\n    if (noCopy === void 0) {\n      noCopy = false;\n    }\n\n    if (noCopy) return new this(source.subarray(offset, offset + 8));\n    return new this(new Uint8Array(source.buffer.slice(source.byteOffset + offset, source.byteOffset + offset + 8)));\n  };\n\n  Uint64.prototype.equals = function (other) {\n    for (var i = 0; i < 8; i++) {\n      if (this.buffer[i] !== other.buffer[i]) return false;\n    }\n\n    return true;\n  };\n\n  Uint64.prototype.inspect = function () {\n    return \"[Uint64 \" + this.toString(10) + \" 0x\" + this.toHexString() + \"]\";\n  };\n  /**\n   * Faster way to check for zero values without converting to a number first.\n   *\n   * @returns {boolean} `true` if the contained value is zero.\n   * @memberOf Uint64\n   */\n\n\n  Uint64.prototype.isZero = function () {\n    for (var i = 0; i < 8; i++) {\n      if (this.buffer[i] !== 0) return false;\n    }\n\n    return true;\n  };\n\n  Uint64.prototype.setValue = function (loWord, hiWord) {\n    var lo = loWord;\n    var hi = hiWord;\n\n    if (hi === undefined) {\n      hi = lo;\n      hi = Math.abs(hi);\n      lo = hi % constants_1.VAL32;\n      hi = hi / constants_1.VAL32;\n      if (hi > constants_1.VAL32) throw new RangeError(loWord + \" is outside Uint64 range\");\n      hi = hi >>> 0;\n    }\n\n    for (var i = 0; i < 8; i++) {\n      this.buffer[i] = lo & 0xff;\n      lo = i === 3 ? hi : lo >>> 8;\n    }\n  };\n  /**\n   * Convert to a native javascript number.\n   *\n   * WARNING: do not expect this number to be accurate to integer precision for large (positive or negative) numbers!\n   *\n   * @param {boolean} allowImprecise If `true`, no check is performed to verify the returned value is accurate;\n   * otherwise out-of-range values are clamped to +Infinity.\n   * @returns {number} A numeric representation of this integer.\n   */\n\n\n  Uint64.prototype.toNumber = function (allowImprecise) {\n    var b = this.buffer;\n    var x = 0;\n    var i = 0;\n    var m = 1;\n\n    while (i < 8) {\n      var v = b[i];\n      x += v * m;\n      m *= 256;\n      i++;\n    }\n\n    if (!allowImprecise && x >= constants_1.MAX_SAFE_INTEGER) {\n      trace('Coercing out of range value %d to Infinity.', x);\n      return Infinity;\n    }\n\n    return x;\n  };\n\n  Uint64.prototype.valueOf = function () {\n    return this.toNumber(false);\n  };\n\n  Uint64.prototype.toArrayBuffer = function () {\n    return this.buffer.buffer;\n  };\n\n  Uint64.prototype.toDataView = function () {\n    return new DataView(this.buffer.buffer);\n  };\n\n  Uint64.prototype.toHexString = function () {\n    var hex = '';\n\n    for (var i = 7; i >= 0; i--) {\n      var v = this.buffer[i].toString(16);\n      if (v.length === 1) v = '0' + v;\n      hex += v;\n    }\n\n    return hex;\n  };\n\n  Uint64.prototype.toString = function (radix) {\n    return this.toNumber(true).toString(radix);\n  };\n\n  Uint64.prototype.toUint8Array = function () {\n    return this.buffer;\n  };\n\n  return Uint64;\n}();\n\nexports.Uint64 = Uint64;","map":{"version":3,"sources":["types/uint64.ts"],"names":[],"mappings":"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","sourceRoot":"../../src","sourcesContent":["\"use strict\";\n/**\n * @author jdiaz5513\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar debug_1 = require(\"debug\");\nvar constants_1 = require(\"../constants\");\nvar errors_1 = require(\"../errors\");\nvar util_1 = require(\"../util\");\nvar trace = debug_1.default('capnp:uint64');\ntrace('load');\n/**\n * Represents an unsigned 64-bit integer stored using a Uint8Array in little-endian format. It's a little bit faster\n * than int64 because we don't need to keep track of the sign bit or perform two's compliment operations on set.\n *\n * You may convert this to a primitive number by calling `toNumber()` but be wary of precision loss!\n *\n * Note that overflow is not implemented, so negative numbers passed into `setValue()` will be negated first.\n *\n * The value passed in as the source buffer is expected to be in little-endian format.\n */\nvar Uint64 = /** @class */ (function () {\n    /**\n     * Creates a new instance; this is a no-frills constructor for speed. Use the factory methods if you need to convert\n     * from other types or use a different offset into the buffer.\n     *\n     * Will throw if the buffer is not at least 8 bytes long.\n     *\n     * @constructor\n     * @param {Uint8Array} buffer The buffer to use for this 64-bit word; the bytes must be in little-endian order.\n     */\n    function Uint64(buffer) {\n        if (buffer.byteLength < 8)\n            throw new RangeError(errors_1.RANGE_INT64_UNDERFLOW);\n        this.buffer = buffer;\n    }\n    Uint64.fromArrayBuffer = function (source, offset, noCopy) {\n        if (offset === void 0) { offset = 0; }\n        if (noCopy === void 0) { noCopy = false; }\n        if (noCopy)\n            return new this(new Uint8Array(source, offset, 8));\n        return new this(new Uint8Array(source.slice(offset, offset + 8)));\n    };\n    Uint64.fromDataView = function (source, offset, noCopy) {\n        if (offset === void 0) { offset = 0; }\n        if (noCopy === void 0) { noCopy = false; }\n        if (noCopy)\n            return new this(new Uint8Array(source.buffer, source.byteOffset + offset, 8));\n        return new this(new Uint8Array(source.buffer.slice(source.byteOffset + offset, source.byteLength + offset + 8)));\n    };\n    /**\n     * Parse a hexadecimal string in **big endian format** as a Uint64 value.\n     *\n     * @static\n     * @param {string} source The source string.\n     * @returns {Uint64} The string parsed as a 64-bit unsigned integer.\n     */\n    Uint64.fromHexString = function (source) {\n        if (source.substr(0, 2) === '0x')\n            source = source.substr(2);\n        if (source.length < 1)\n            return Uint64.fromNumber(0);\n        if (source[0] === '-')\n            throw new RangeError('Source must not be negative.');\n        source = util_1.pad(source, 16);\n        if (source.length !== 16)\n            throw new RangeError('Source string must contain at most 16 hexadecimal digits.');\n        var bytes = source.toLowerCase().replace(/[^\\da-f]/g, '');\n        var buf = new Uint8Array(new ArrayBuffer(8));\n        for (var i = 0; i < 8; i++)\n            buf[7 - i] = parseInt(bytes.substr(i * 2, 2), 16);\n        return new Uint64(buf);\n    };\n    Uint64.fromNumber = function (source) {\n        var ret = new this(new Uint8Array(8));\n        ret.setValue(source);\n        return ret;\n    };\n    Uint64.fromUint8Array = function (source, offset, noCopy) {\n        if (offset === void 0) { offset = 0; }\n        if (noCopy === void 0) { noCopy = false; }\n        if (noCopy)\n            return new this(source.subarray(offset, offset + 8));\n        return new this(new Uint8Array(source.buffer.slice(source.byteOffset + offset, source.byteOffset + offset + 8)));\n    };\n    Uint64.prototype.equals = function (other) {\n        for (var i = 0; i < 8; i++) {\n            if (this.buffer[i] !== other.buffer[i])\n                return false;\n        }\n        return true;\n    };\n    Uint64.prototype.inspect = function () {\n        return \"[Uint64 \" + this.toString(10) + \" 0x\" + this.toHexString() + \"]\";\n    };\n    /**\n     * Faster way to check for zero values without converting to a number first.\n     *\n     * @returns {boolean} `true` if the contained value is zero.\n     * @memberOf Uint64\n     */\n    Uint64.prototype.isZero = function () {\n        for (var i = 0; i < 8; i++) {\n            if (this.buffer[i] !== 0)\n                return false;\n        }\n        return true;\n    };\n    Uint64.prototype.setValue = function (loWord, hiWord) {\n        var lo = loWord;\n        var hi = hiWord;\n        if (hi === undefined) {\n            hi = lo;\n            hi = Math.abs(hi);\n            lo = hi % constants_1.VAL32;\n            hi = hi / constants_1.VAL32;\n            if (hi > constants_1.VAL32)\n                throw new RangeError(loWord + \" is outside Uint64 range\");\n            hi = hi >>> 0;\n        }\n        for (var i = 0; i < 8; i++) {\n            this.buffer[i] = lo & 0xff;\n            lo = i === 3 ? hi : lo >>> 8;\n        }\n    };\n    /**\n     * Convert to a native javascript number.\n     *\n     * WARNING: do not expect this number to be accurate to integer precision for large (positive or negative) numbers!\n     *\n     * @param {boolean} allowImprecise If `true`, no check is performed to verify the returned value is accurate;\n     * otherwise out-of-range values are clamped to +Infinity.\n     * @returns {number} A numeric representation of this integer.\n     */\n    Uint64.prototype.toNumber = function (allowImprecise) {\n        var b = this.buffer;\n        var x = 0;\n        var i = 0;\n        var m = 1;\n        while (i < 8) {\n            var v = b[i];\n            x += v * m;\n            m *= 256;\n            i++;\n        }\n        if (!allowImprecise && x >= constants_1.MAX_SAFE_INTEGER) {\n            trace('Coercing out of range value %d to Infinity.', x);\n            return Infinity;\n        }\n        return x;\n    };\n    Uint64.prototype.valueOf = function () {\n        return this.toNumber(false);\n    };\n    Uint64.prototype.toArrayBuffer = function () {\n        return this.buffer.buffer;\n    };\n    Uint64.prototype.toDataView = function () {\n        return new DataView(this.buffer.buffer);\n    };\n    Uint64.prototype.toHexString = function () {\n        var hex = '';\n        for (var i = 7; i >= 0; i--) {\n            var v = this.buffer[i].toString(16);\n            if (v.length === 1)\n                v = '0' + v;\n            hex += v;\n        }\n        return hex;\n    };\n    Uint64.prototype.toString = function (radix) {\n        return this.toNumber(true).toString(radix);\n    };\n    Uint64.prototype.toUint8Array = function () {\n        return this.buffer;\n    };\n    return Uint64;\n}());\nexports.Uint64 = Uint64;\n\n//# sourceMappingURL=uint64.js.map\n"]},"metadata":{},"sourceType":"script"}