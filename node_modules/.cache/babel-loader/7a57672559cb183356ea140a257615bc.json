{"ast":null,"code":"\"use strict\";\n/**\n * @author jdiaz5513\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar debug_1 = require(\"debug\");\n\nvar constants_1 = require(\"../../constants\");\n\nvar util_1 = require(\"../../util\");\n\nvar list_element_size_1 = require(\"../list-element-size\");\n\nvar object_size_1 = require(\"../object-size\");\n\nvar orphan_1 = require(\"./orphan\");\n\nvar pointer_allocation_result_1 = require(\"./pointer-allocation-result\");\n\nvar pointer_type_1 = require(\"./pointer-type\");\n\nvar errors_1 = require(\"../../errors\");\n\nvar trace = debug_1.default('capnp:pointer');\ntrace('load');\n/**\n * A pointer referencing a single byte location in a segment. This is typically used for Cap'n Proto pointers, but is\n * also sometimes used to reference an offset to a pointer's content or tag words.\n *\n * @export\n * @class Pointer\n */\n\nvar Pointer =\n/** @class */\nfunction () {\n  function Pointer(segment, byteOffset, depthLimit) {\n    if (depthLimit === void 0) {\n      depthLimit = constants_1.MAX_DEPTH;\n    }\n\n    if (depthLimit === 0) throw new Error(util_1.format(errors_1.PTR_DEPTH_LIMIT_EXCEEDED, this)); // Make sure we keep track of all pointer allocations; there's a limit per message (prevent DoS).\n\n    trackPointerAllocation(segment.message, this); // NOTE: It's okay to have a pointer to the end of the segment; you'll see this when creating pointers to the\n    // beginning of the content of a newly-allocated composite list with zero elements. Unlike other language\n    // implementations buffer over/underflows are not a big issue since all buffer access is bounds checked in native\n    // code anyway.\n\n    if (byteOffset < 0 || byteOffset > segment.byteLength) {\n      throw new Error(util_1.format(errors_1.PTR_OFFSET_OUT_OF_BOUNDS, byteOffset));\n    }\n\n    this._capnp = {\n      compositeList: false,\n      depthLimit: depthLimit\n    };\n    this.segment = segment;\n    this.byteOffset = byteOffset;\n    trace('new %s', this);\n  }\n\n  Pointer.prototype.toString = function () {\n    return util_1.format('Pointer_%d@%a,%s,limit:%x', this.segment.id, this.byteOffset, dump(this), this._capnp.depthLimit);\n  };\n\n  Pointer.adopt = adopt;\n  Pointer.copyFrom = copyFrom;\n  Pointer.disown = disown;\n  Pointer.dump = dump;\n  Pointer.isNull = isNull;\n  Pointer._capnp = {\n    displayName: 'Pointer'\n  };\n  return Pointer;\n}();\n\nexports.Pointer = Pointer;\n/**\n * Adopt an orphaned pointer, making the pointer point to the orphaned content without copying it.\n *\n * @param {Orphan<Pointer>} src The orphan to adopt.\n * @param {Pointer} p The the pointer to adopt into.\n * @returns {void}\n */\n\nfunction adopt(src, p) {\n  src._moveTo(p);\n}\n\nexports.adopt = adopt;\n/**\n * Convert a pointer to an Orphan, zeroing out the pointer and leaving its content untouched. If the content is no\n * longer needed, call `disown()` on the orphaned pointer to erase the contents as well.\n *\n * Call `adopt()` on the orphan with the new target pointer location to move it back into the message; the orphan\n * object is then invalidated after adoption (can only adopt once!).\n *\n * @param {T} p The pointer to turn into an Orphan.\n * @returns {Orphan<T>} An orphaned pointer.\n */\n\nfunction disown(p) {\n  return new orphan_1.Orphan(p);\n}\n\nexports.disown = disown;\n\nfunction dump(p) {\n  return util_1.bufferToHex(p.segment.buffer.slice(p.byteOffset, p.byteOffset + 8));\n}\n\nexports.dump = dump;\n/**\n * Get the total number of bytes required to hold a list of the provided size with the given length, rounded up to the\n * nearest word.\n *\n * @param {ListElementSize} elementSize A number describing the size of the list elements.\n * @param {number} length The length of the list.\n * @param {ObjectSize} [compositeSize] The size of each element in a composite list; required if\n * `elementSize === ListElementSize.COMPOSITE`.\n * @returns {number} The number of bytes required to hold an element of that size, or `NaN` if that is undefined.\n */\n\nfunction getListByteLength(elementSize, length, compositeSize) {\n  switch (elementSize) {\n    case list_element_size_1.ListElementSize.BIT:\n      return util_1.padToWord(length + 7 >>> 3);\n\n    case list_element_size_1.ListElementSize.BYTE:\n    case list_element_size_1.ListElementSize.BYTE_2:\n    case list_element_size_1.ListElementSize.BYTE_4:\n    case list_element_size_1.ListElementSize.BYTE_8:\n    case list_element_size_1.ListElementSize.POINTER:\n    case list_element_size_1.ListElementSize.VOID:\n      return util_1.padToWord(getListElementByteLength(elementSize) * length);\n\n    /* istanbul ignore next */\n\n    case list_element_size_1.ListElementSize.COMPOSITE:\n      if (compositeSize === undefined) throw new Error(util_1.format(errors_1.PTR_INVALID_LIST_SIZE, NaN));\n      return length * util_1.padToWord(object_size_1.getByteLength(compositeSize));\n\n    /* istanbul ignore next */\n\n    default:\n      throw new Error(errors_1.PTR_INVALID_LIST_SIZE);\n  }\n}\n\nexports.getListByteLength = getListByteLength;\n/**\n * Get the number of bytes required to hold a list element of the provided size. `COMPOSITE` elements do not have a\n * fixed size, and `BIT` elements are packed into exactly a single bit, so these both return `NaN`.\n *\n * @param {ListElementSize} elementSize A number describing the size of the list elements.\n * @returns {number} The number of bytes required to hold an element of that size, or `NaN` if that is undefined.\n */\n\nfunction getListElementByteLength(elementSize) {\n  switch (elementSize) {\n    /* istanbul ignore next */\n    case list_element_size_1.ListElementSize.BIT:\n      return NaN;\n\n    case list_element_size_1.ListElementSize.BYTE:\n      return 1;\n\n    case list_element_size_1.ListElementSize.BYTE_2:\n      return 2;\n\n    case list_element_size_1.ListElementSize.BYTE_4:\n      return 4;\n\n    case list_element_size_1.ListElementSize.BYTE_8:\n    case list_element_size_1.ListElementSize.POINTER:\n      return 8;\n\n    /* istanbul ignore next */\n\n    case list_element_size_1.ListElementSize.COMPOSITE:\n      // Caller has to figure it out based on the tag word.\n      return NaN;\n\n    /* istanbul ignore next */\n\n    case list_element_size_1.ListElementSize.VOID:\n      return 0;\n\n    /* istanbul ignore next */\n\n    default:\n      throw new Error(util_1.format(errors_1.PTR_INVALID_LIST_SIZE, elementSize));\n  }\n}\n\nexports.getListElementByteLength = getListElementByteLength;\n/**\n * Add an offset to the pointer's offset and return a new Pointer for that address.\n *\n * @param {number} offset The number of bytes to add to the offset.\n * @param {Pointer} p The pointer to add from.\n * @returns {Pointer} A new pointer to the address.\n */\n\nfunction add(offset, p) {\n  return new Pointer(p.segment, p.byteOffset + offset, p._capnp.depthLimit);\n}\n\nexports.add = add;\n/**\n * Replace a pointer with a deep copy of the pointer at `src` and all of its contents.\n *\n * @param {Pointer} src The pointer to copy.\n * @param {Pointer} p The pointer to copy into.\n * @returns {void}\n */\n\nfunction copyFrom(src, p) {\n  // If the pointer is the same then this is a noop.\n  if (p.segment === src.segment && p.byteOffset === src.byteOffset) {\n    trace('ignoring copy operation from identical pointer %s', src);\n    return;\n  } // Make sure we erase this pointer's contents before moving on. If src is null, that's all we do.\n\n\n  erase(p); // noop if null\n\n  if (isNull(src)) return;\n\n  switch (getTargetPointerType(src)) {\n    case pointer_type_1.PointerType.STRUCT:\n      copyFromStruct(src, p);\n      break;\n\n    case pointer_type_1.PointerType.LIST:\n      copyFromList(src, p);\n      break;\n\n    /* istanbul ignore next */\n\n    default:\n      throw new Error(util_1.format(errors_1.PTR_INVALID_POINTER_TYPE, getTargetPointerType(p)));\n  }\n}\n\nexports.copyFrom = copyFrom;\n/**\n * Recursively erase a pointer, any far pointers/landing pads/tag words, and the content it points to.\n *\n * Note that this will leave \"holes\" of zeroes in the message, since the space cannot be reclaimed. With packing this\n * will have a negligible effect on the final message size.\n *\n * FIXME: This may need protection against infinite recursion...\n *\n * @param {Pointer} p The pointer to erase.\n * @returns {void}\n */\n\nfunction erase(p) {\n  if (isNull(p)) return; // First deal with the contents.\n\n  var c;\n\n  switch (getTargetPointerType(p)) {\n    case pointer_type_1.PointerType.STRUCT:\n      var size = getTargetStructSize(p);\n      c = getContent(p); // Wipe the data section.\n\n      c.segment.fillZeroWords(c.byteOffset, size.dataByteLength / 8); // Iterate over all the pointers and nuke them.\n\n      for (var i = 0; i < size.pointerLength; i++) {\n        erase(add(i * 8, c));\n      }\n\n      break;\n\n    case pointer_type_1.PointerType.LIST:\n      var elementSize = getTargetListElementSize(p);\n      var length = getTargetListLength(p);\n      var contentWords = util_1.padToWord(length * getListElementByteLength(elementSize));\n      c = getContent(p);\n\n      if (elementSize === list_element_size_1.ListElementSize.POINTER) {\n        for (var i = 0; i < length; i++) {\n          erase(new Pointer(c.segment, c.byteOffset + i * 8, p._capnp.depthLimit - 1));\n        } // Calling erase on each pointer takes care of the content, nothing left to do here.\n\n\n        break;\n      } else if (elementSize === list_element_size_1.ListElementSize.COMPOSITE) {\n        // Read some stuff from the tag word.\n        var tag = add(-8, c);\n        var compositeSize = getStructSize(tag);\n        var compositeByteLength = object_size_1.getByteLength(compositeSize);\n        contentWords = getOffsetWords(tag); // Kill the tag word.\n\n        c.segment.setWordZero(c.byteOffset - 8); // Recursively erase each pointer.\n\n        for (var i = 0; i < length; i++) {\n          for (var j = 0; j < compositeSize.pointerLength; j++) {\n            erase(new Pointer(c.segment, c.byteOffset + i * compositeByteLength + j * 8, p._capnp.depthLimit - 1));\n          }\n        }\n      }\n\n      c.segment.fillZeroWords(c.byteOffset, contentWords);\n      break;\n\n    case pointer_type_1.PointerType.OTHER:\n      // No content.\n      break;\n\n    default:\n      throw new Error(util_1.format(errors_1.PTR_INVALID_POINTER_TYPE, getTargetPointerType(p)));\n  }\n\n  erasePointer(p);\n}\n\nexports.erase = erase;\n/**\n * Set the pointer (and far pointer landing pads, if applicable) to zero. Does not touch the pointer's content.\n *\n * @param {Pointer} p The pointer to erase.\n * @returns {void}\n */\n\nfunction erasePointer(p) {\n  if (getPointerType(p) === pointer_type_1.PointerType.FAR) {\n    var landingPad = followFar(p);\n\n    if (isDoubleFar(p)) {\n      // Kill the double-far tag word.\n      landingPad.segment.setWordZero(landingPad.byteOffset + 8);\n    } // Kill the landing pad.\n\n\n    landingPad.segment.setWordZero(landingPad.byteOffset);\n  } // Finally! Kill the pointer itself...\n\n\n  p.segment.setWordZero(p.byteOffset);\n}\n\nexports.erasePointer = erasePointer;\n/**\n * Interpret the pointer as a far pointer, returning its target segment and offset.\n *\n * @param {Pointer} p The pointer to read from.\n * @returns {Pointer} A pointer to the far target.\n */\n\nfunction followFar(p) {\n  var targetSegment = p.segment.message.getSegment(p.segment.getUint32(p.byteOffset + 4));\n  var targetWordOffset = p.segment.getUint32(p.byteOffset) >>> 3;\n  return new Pointer(targetSegment, targetWordOffset * 8, p._capnp.depthLimit - 1);\n}\n\nexports.followFar = followFar;\n/**\n * If the pointer address references a far pointer, follow it to the location where the actual pointer data is written.\n * Otherwise, returns the pointer unmodified.\n *\n * @param {Pointer} p The pointer to read from.\n * @returns {Pointer} A new pointer representing the target location, or `p` if it is not a far pointer.\n */\n\nfunction followFars(p) {\n  if (getPointerType(p) === pointer_type_1.PointerType.FAR) {\n    var landingPad = followFar(p);\n    if (isDoubleFar(p)) landingPad.byteOffset += 8;\n    return landingPad;\n  }\n\n  return p;\n}\n\nexports.followFars = followFars;\n\nfunction getCapabilityId(p) {\n  return p.segment.getUint32(p.byteOffset + 4);\n}\n\nexports.getCapabilityId = getCapabilityId;\n\nfunction isCompositeList(p) {\n  return getTargetPointerType(p) === pointer_type_1.PointerType.LIST && getTargetListElementSize(p) === list_element_size_1.ListElementSize.COMPOSITE;\n}\n/**\n * Obtain the location of the pointer's content, following far pointers as needed.\n * If the pointer is a struct pointer and `compositeIndex` is set, it will be offset by a multiple of the struct's size.\n *\n * @param {Pointer} p The pointer to read from.\n * @param {boolean} [ignoreCompositeIndex] If true, will not follow the composite struct pointer's composite index and\n * instead return a pointer to the parent list's contents (also the beginning of the first struct).\n * @returns {Pointer} A pointer to the beginning of the pointer's content.\n */\n\n\nfunction getContent(p, ignoreCompositeIndex) {\n  var c;\n\n  if (isDoubleFar(p)) {\n    var landingPad = followFar(p);\n    c = new Pointer(p.segment.message.getSegment(getFarSegmentId(landingPad)), getOffsetWords(landingPad) * 8);\n  } else {\n    var target = followFars(p);\n    c = new Pointer(target.segment, target.byteOffset + 8 + getOffsetWords(target) * 8);\n  }\n\n  if (isCompositeList(p)) c.byteOffset += 8;\n\n  if (!ignoreCompositeIndex && p._capnp.compositeIndex !== undefined) {\n    // Seek backwards by one word so we can read the struct size off the tag word.\n    c.byteOffset -= 8; // Seek ahead by `compositeIndex` multiples of the struct's total size.\n\n    c.byteOffset += 8 + p._capnp.compositeIndex * object_size_1.getByteLength(object_size_1.padToWord(getStructSize(c)));\n  }\n\n  return c;\n}\n\nexports.getContent = getContent;\n/**\n * Read the target segment ID from a far pointer.\n *\n * @param {Pointer} p The pointer to read from.\n * @returns {number} The target segment ID.\n */\n\nfunction getFarSegmentId(p) {\n  return p.segment.getUint32(p.byteOffset + 4);\n}\n\nexports.getFarSegmentId = getFarSegmentId;\n/**\n * Get a number indicating the size of the list's elements.\n *\n * @param {Pointer} p The pointer to read from.\n * @returns {ListElementSize} The size of the list's elements.\n */\n\nfunction getListElementSize(p) {\n  return p.segment.getUint32(p.byteOffset + 4) & constants_1.LIST_SIZE_MASK;\n}\n\nexports.getListElementSize = getListElementSize;\n/**\n * Get the number of elements in a list pointer. For composite lists, it instead represents the total number of words in\n * the list (not counting the tag word).\n *\n * This method does **not** attempt to distinguish between composite and non-composite lists. To get the correct\n * length for composite lists use `getTargetListLength()` instead.\n *\n * @param {Pointer} p The pointer to read from.\n * @returns {number} The length of the list, or total number of words for composite lists.\n */\n\nfunction getListLength(p) {\n  return p.segment.getUint32(p.byteOffset + 4) >>> 3;\n}\n\nexports.getListLength = getListLength;\n/**\n * Get the offset (in words) from the end of a pointer to the start of its content. For struct pointers, this is the\n * beginning of the data section, and for list pointers it is the location of the first element. The value should\n * always be zero for interface pointers.\n *\n * @param {Pointer} p The pointer to read from.\n * @returns {number} The offset, in words, from the end of the pointer to the start of the data section.\n */\n\nfunction getOffsetWords(p) {\n  var o = p.segment.getInt32(p.byteOffset); // Far pointers only have 29 offset bits.\n\n  return o & 2 ? o >> 3 : o >> 2;\n}\n\nexports.getOffsetWords = getOffsetWords;\n/**\n * Look up the pointer's type.\n *\n * @param {Pointer} p The pointer to read from.\n * @returns {PointerType} The type of pointer.\n */\n\nfunction getPointerType(p) {\n  return p.segment.getUint32(p.byteOffset) & constants_1.POINTER_TYPE_MASK;\n}\n\nexports.getPointerType = getPointerType;\n/**\n * Read the number of data words from this struct pointer.\n *\n * @param {Pointer} p The pointer to read from.\n * @returns {number} The number of data words in the struct.\n */\n\nfunction getStructDataWords(p) {\n  return p.segment.getUint16(p.byteOffset + 4);\n}\n\nexports.getStructDataWords = getStructDataWords;\n/**\n * Read the number of pointers contained in this struct pointer.\n *\n * @param {Pointer} p The pointer to read from.\n * @returns {number} The number of pointers in this struct.\n */\n\nfunction getStructPointerLength(p) {\n  return p.segment.getUint16(p.byteOffset + 6);\n}\n\nexports.getStructPointerLength = getStructPointerLength;\n/**\n * Get an object describing this struct pointer's size.\n *\n * @param {Pointer} p The pointer to read from.\n * @returns {ObjectSize} The size of the struct.\n */\n\nfunction getStructSize(p) {\n  return new object_size_1.ObjectSize(getStructDataWords(p) * 8, getStructPointerLength(p));\n}\n\nexports.getStructSize = getStructSize;\n/**\n * Get a pointer to this pointer's composite list tag word, following far pointers as needed.\n *\n * @param {Pointer} p The pointer to read from.\n * @returns {Pointer} A pointer to the list's composite tag word.\n */\n\nfunction getTargetCompositeListTag(p) {\n  var c = getContent(p); // The composite list tag is always one word before the content.\n\n  c.byteOffset -= 8;\n  return c;\n}\n\nexports.getTargetCompositeListTag = getTargetCompositeListTag;\n/**\n * Get the object size for the target composite list, following far pointers as needed.\n *\n * @param {Pointer} p The pointer to read from.\n * @returns {ObjectSize} An object describing the size of each struct in the list.\n */\n\nfunction getTargetCompositeListSize(p) {\n  return getStructSize(getTargetCompositeListTag(p));\n}\n\nexports.getTargetCompositeListSize = getTargetCompositeListSize;\n/**\n * Get the size of the list elements referenced by this pointer, following far pointers if necessary.\n *\n * @param {Pointer} p The pointer to read from.\n * @returns {ListElementSize} The size of the elements in the list.\n */\n\nfunction getTargetListElementSize(p) {\n  return getListElementSize(followFars(p));\n}\n\nexports.getTargetListElementSize = getTargetListElementSize;\n/**\n * Get the length of the list referenced by this pointer, following far pointers if necessary. If the list is a\n * composite list, it will look up the tag word and read the length from there.\n *\n * @param {Pointer} p The pointer to read from.\n * @returns {number} The number of elements in the list.\n */\n\nfunction getTargetListLength(p) {\n  var t = followFars(p);\n\n  if (getListElementSize(t) === list_element_size_1.ListElementSize.COMPOSITE) {\n    // The content is prefixed by a tag word; it's a struct pointer whose offset contains the list's length.\n    return getOffsetWords(getTargetCompositeListTag(p));\n  }\n\n  return getListLength(t);\n}\n\nexports.getTargetListLength = getTargetListLength;\n/**\n * Get the type of a pointer, following far pointers if necessary. For non-far pointers this is equivalent to calling\n * `getPointerType()`.\n *\n * The target of a far pointer can never be another far pointer, and this method will throw if such a situation is\n * encountered.\n *\n * @param {Pointer} p The pointer to read from.\n * @returns {PointerType} The type of pointer referenced by this pointer.\n */\n\nfunction getTargetPointerType(p) {\n  var t = getPointerType(followFars(p));\n  if (t === pointer_type_1.PointerType.FAR) throw new Error(util_1.format(errors_1.PTR_INVALID_FAR_TARGET, p));\n  return t;\n}\n\nexports.getTargetPointerType = getTargetPointerType;\n/**\n * Get the size of the struct referenced by a pointer, following far pointers if necessary.\n *\n * @param {Pointer} p The poiner to read from.\n * @returns {ObjectSize} The size of the struct referenced by this pointer.\n */\n\nfunction getTargetStructSize(p) {\n  return getStructSize(followFars(p));\n}\n\nexports.getTargetStructSize = getTargetStructSize;\n/**\n * Initialize a pointer to point at the data in the content segment. If the content segment is not the same as the\n * pointer's segment, this will allocate and write far pointers as needed. Nothing is written otherwise.\n *\n * The return value includes a pointer to write the pointer's actual data to (the eventual far target), and the offset\n * value (in words) to use for that pointer. In the case of double-far pointers this offset will always be zero.\n *\n * @param {Segment} contentSegment The segment containing this pointer's content.\n * @param {number} contentOffset The offset within the content segment for the beginning of this pointer's content.\n * @param {Pointer} p The pointer to initialize.\n * @returns {PointerAllocationResult} An object containing a pointer (where the pointer data should be written), and\n * the value to use as the offset for that pointer.\n */\n\nfunction initPointer(contentSegment, contentOffset, p) {\n  if (p.segment !== contentSegment) {\n    // Need a far pointer.\n    trace('Initializing far pointer %s -> %s.', p, contentSegment);\n\n    if (!contentSegment.hasCapacity(8)) {\n      // GAH! Not enough space in the content segment for a landing pad so we need a double far pointer.\n      var landingPad_1 = p.segment.allocate(16);\n      trace('GAH! Initializing double-far pointer in %s from %s -> %s.', p, contentSegment, landingPad_1);\n      setFarPointer(true, landingPad_1.byteOffset / 8, landingPad_1.segment.id, p);\n      setFarPointer(false, contentOffset / 8, contentSegment.id, landingPad_1);\n      landingPad_1.byteOffset += 8;\n      return new pointer_allocation_result_1.PointerAllocationResult(landingPad_1, 0);\n    } // Allocate a far pointer landing pad in the target segment.\n\n\n    var landingPad = contentSegment.allocate(8);\n\n    if (landingPad.segment.id !== contentSegment.id) {\n      throw new Error(errors_1.INVARIANT_UNREACHABLE_CODE);\n    }\n\n    setFarPointer(false, landingPad.byteOffset / 8, landingPad.segment.id, p);\n    return new pointer_allocation_result_1.PointerAllocationResult(landingPad, (contentOffset - landingPad.byteOffset - 8) / 8);\n  }\n\n  trace('Initializing intra-segment pointer %s -> %a.', p, contentOffset);\n  return new pointer_allocation_result_1.PointerAllocationResult(p, (contentOffset - p.byteOffset - 8) / 8);\n}\n\nexports.initPointer = initPointer;\n/**\n * Check if the pointer is a double-far pointer.\n *\n * @param {Pointer} p The pointer to read from.\n * @returns {boolean} `true` if it is a double-far pointer, `false` otherwise.\n */\n\nfunction isDoubleFar(p) {\n  return getPointerType(p) === pointer_type_1.PointerType.FAR && (p.segment.getUint32(p.byteOffset) & constants_1.POINTER_DOUBLE_FAR_MASK) !== 0;\n}\n\nexports.isDoubleFar = isDoubleFar;\n/**\n * Quickly check to see if the pointer is \"null\". A \"null\" pointer is a zero word, equivalent to an empty struct\n * pointer.\n *\n * @param {Pointer} p The pointer to read from.\n * @returns {boolean} `true` if the pointer is \"null\".\n */\n\nfunction isNull(p) {\n  return p.segment.isWordZero(p.byteOffset);\n}\n\nexports.isNull = isNull;\n/**\n * Relocate a pointer to the given destination, ensuring that it points to the same content. This will create far\n * pointers as needed if the content is in a different segment than the destination. After the relocation the source\n * pointer will be erased and is no longer valid.\n *\n * @param {Pointer} dst The desired location for the `src` pointer. Any existing contents will be erased before\n * relocating!\n * @param {Pointer} src The pointer to relocate.\n * @returns {void}\n */\n\nfunction relocateTo(dst, src) {\n  var t = followFars(src);\n  var lo = t.segment.getUint8(t.byteOffset) & 0x03; // discard the offset\n\n  var hi = t.segment.getUint32(t.byteOffset + 4); // Make sure anything dst was pointing to is wiped out.\n\n  erase(dst);\n  var res = initPointer(t.segment, t.byteOffset + 8 + getOffsetWords(t) * 8, dst); // Keep the low 2 bits and write the new offset.\n\n  res.pointer.segment.setUint32(res.pointer.byteOffset, lo | res.offsetWords << 2); // Keep the high 32 bits intact.\n\n  res.pointer.segment.setUint32(res.pointer.byteOffset + 4, hi);\n  erasePointer(src);\n}\n\nexports.relocateTo = relocateTo;\n/**\n * Write a far pointer.\n *\n * @param {boolean} doubleFar Set to `true` if this is a double far pointer.\n * @param {number} offsetWords The offset, in words, to the target pointer.\n * @param {number} segmentId The segment the target pointer is located in.\n * @param {Pointer} p The pointer to write to.\n * @returns {void}\n */\n\nfunction setFarPointer(doubleFar, offsetWords, segmentId, p) {\n  var A = pointer_type_1.PointerType.FAR;\n  var B = doubleFar ? 1 : 0;\n  var C = offsetWords;\n  var D = segmentId;\n  p.segment.setUint32(p.byteOffset, A | B << 2 | C << 3);\n  p.segment.setUint32(p.byteOffset + 4, D);\n}\n\nexports.setFarPointer = setFarPointer;\n/**\n * Write a raw interface pointer.\n *\n * @param {number} capId The capability ID.\n * @param {Pointer} p The pointer to write to.\n * @returns {void}\n */\n\nfunction setInterfacePointer(capId, p) {\n  p.segment.setUint32(p.byteOffset, pointer_type_1.PointerType.OTHER);\n  p.segment.setUint32(p.byteOffset + 4, capId);\n}\n\nexports.setInterfacePointer = setInterfacePointer;\n/**\n * Write a raw list pointer.\n *\n * @param {number} offsetWords The number of words from the end of this pointer to the beginning of the list content.\n * @param {ListElementSize} size The size of each element in the list.\n * @param {number} length The number of elements in the list.\n * @param {Pointer} p The pointer to write to.\n * @param {ObjectSize} [compositeSize] For composite lists this describes the size of each element in this list. This\n * is required for composite lists.\n * @returns {void}\n */\n\nfunction setListPointer(offsetWords, size, length, p, compositeSize) {\n  if (p === undefined) throw new Error(errors_1.INVARIANT_UNREACHABLE_CODE);\n  var A = pointer_type_1.PointerType.LIST;\n  var B = offsetWords;\n  var C = size;\n  var D = length;\n\n  if (size === list_element_size_1.ListElementSize.COMPOSITE) {\n    if (compositeSize === undefined) throw new TypeError(errors_1.TYPE_COMPOSITE_SIZE_UNDEFINED);\n    D *= object_size_1.getWordLength(compositeSize);\n  }\n\n  p.segment.setUint32(p.byteOffset, A | B << 2);\n  p.segment.setUint32(p.byteOffset + 4, C | D << 3);\n}\n\nexports.setListPointer = setListPointer;\n/**\n * Write a raw struct pointer.\n *\n * @param {number} offsetWords The number of words from the end of this pointer to the beginning of the struct's data\n * section.\n * @param {ObjectSize} size An object describing the size of the struct.\n * @param {Pointer} p The pointer to write to.\n * @returns {void}\n */\n\nfunction setStructPointer(offsetWords, size, p) {\n  var A = pointer_type_1.PointerType.STRUCT;\n  var B = offsetWords;\n  var C = object_size_1.getDataWordLength(size);\n  var D = size.pointerLength;\n  p.segment.setUint32(p.byteOffset, A | B << 2);\n  p.segment.setUint16(p.byteOffset + 4, C);\n  p.segment.setUint16(p.byteOffset + 6, D);\n}\n\nexports.setStructPointer = setStructPointer;\n/**\n * Read some bits off a pointer to make sure it has the right pointer data.\n *\n * @param {PointerType} pointerType The expected pointer type.\n * @param {Pointer} p The pointer to validate.\n * @param {ListElementSize} [elementSize] For list pointers, the expected element size. Leave this\n * undefined for struct pointers.\n * @returns {void}\n */\n\nfunction validate(pointerType, p, elementSize) {\n  if (isNull(p)) return;\n  var t = followFars(p); // Check the pointer type.\n\n  var A = t.segment.getUint32(t.byteOffset) & constants_1.POINTER_TYPE_MASK;\n  if (A !== pointerType) throw new Error(util_1.format(errors_1.PTR_WRONG_POINTER_TYPE, p, pointerType)); // Check the list element size, if provided.\n\n  if (elementSize !== undefined) {\n    var C = t.segment.getUint32(t.byteOffset + 4) & constants_1.LIST_SIZE_MASK;\n    if (C !== elementSize) throw new Error(util_1.format(errors_1.PTR_WRONG_LIST_TYPE, p, list_element_size_1.ListElementSize[elementSize]));\n  }\n}\n\nexports.validate = validate;\n\nfunction copyFromList(src, dst) {\n  if (dst._capnp.depthLimit <= 0) throw new Error(errors_1.PTR_DEPTH_LIMIT_EXCEEDED);\n  var srcContent = getContent(src);\n  var srcElementSize = getTargetListElementSize(src);\n  var srcLength = getTargetListLength(src);\n  var srcCompositeSize;\n  var srcStructByteLength;\n  var dstContent;\n\n  if (srcElementSize === list_element_size_1.ListElementSize.POINTER) {\n    dstContent = dst.segment.allocate(object_size_1.getByteLength(getTargetCompositeListSize(src)) * srcLength); // Recursively copy each pointer in the list.\n\n    for (var i = 0; i < srcLength; i++) {\n      var srcPtr = new Pointer(srcContent.segment, srcContent.byteOffset + (i << 3), src._capnp.depthLimit - 1);\n      var dstPtr = new Pointer(dstContent.segment, dstContent.byteOffset + (i << 3), dst._capnp.depthLimit - 1);\n      copyFrom(srcPtr, dstPtr);\n    }\n  } else if (srcElementSize === list_element_size_1.ListElementSize.COMPOSITE) {\n    srcCompositeSize = object_size_1.padToWord(getTargetCompositeListSize(src));\n    srcStructByteLength = object_size_1.getByteLength(srcCompositeSize);\n    dstContent = dst.segment.allocate(object_size_1.getByteLength(srcCompositeSize) * srcLength + 8); // Copy the tag word.\n\n    dstContent.segment.copyWord(dstContent.byteOffset, srcContent.segment, srcContent.byteOffset - 8); // Copy the entire contents, including all pointers. This should be more efficient than making `srcLength`\n    // copies to skip the pointer sections, and we're about to rewrite all those pointers anyway.\n    // PERF: Skip this step if the composite struct only contains pointers.\n\n    if (srcCompositeSize.dataByteLength > 0) {\n      var wordLength = object_size_1.getWordLength(srcCompositeSize) * srcLength;\n      dstContent.segment.copyWords(dstContent.byteOffset + 8, srcContent.segment, srcContent.byteOffset, wordLength);\n    } // Recursively copy all the pointers in each struct.\n\n\n    for (var i = 0; i < srcLength; i++) {\n      for (var j = 0; j < srcCompositeSize.pointerLength; j++) {\n        var offset = i * srcStructByteLength + srcCompositeSize.dataByteLength + (j << 3);\n        var srcPtr = new Pointer(srcContent.segment, srcContent.byteOffset + offset, src._capnp.depthLimit - 1);\n        var dstPtr = new Pointer(dstContent.segment, dstContent.byteOffset + offset + 8, dst._capnp.depthLimit - 1);\n        copyFrom(srcPtr, dstPtr);\n      }\n    }\n  } else {\n    var byteLength = util_1.padToWord(srcElementSize === list_element_size_1.ListElementSize.BIT ? srcLength + 7 >>> 3 : getListElementByteLength(srcElementSize) * srcLength);\n    var wordLength = byteLength >>> 3;\n    dstContent = dst.segment.allocate(byteLength); // Copy all of the list contents word-by-word.\n\n    dstContent.segment.copyWords(dstContent.byteOffset, srcContent.segment, srcContent.byteOffset, wordLength);\n  } // Initialize the list pointer.\n\n\n  var res = initPointer(dstContent.segment, dstContent.byteOffset, dst);\n  setListPointer(res.offsetWords, srcElementSize, srcLength, res.pointer, srcCompositeSize);\n}\n\nexports.copyFromList = copyFromList;\n\nfunction copyFromStruct(src, dst) {\n  if (dst._capnp.depthLimit <= 0) throw new Error(errors_1.PTR_DEPTH_LIMIT_EXCEEDED);\n  var srcContent = getContent(src);\n  var srcSize = getTargetStructSize(src);\n  var srcDataWordLength = object_size_1.getDataWordLength(srcSize); // Allocate space for the destination content.\n\n  var dstContent = dst.segment.allocate(object_size_1.getByteLength(srcSize)); // Copy the data section.\n\n  dstContent.segment.copyWords(dstContent.byteOffset, srcContent.segment, srcContent.byteOffset, srcDataWordLength); // Copy the pointer section.\n\n  for (var i = 0; i < srcSize.pointerLength; i++) {\n    var offset = srcSize.dataByteLength + i * 8;\n    var srcPtr = new Pointer(srcContent.segment, srcContent.byteOffset + offset, src._capnp.depthLimit - 1);\n    var dstPtr = new Pointer(dstContent.segment, dstContent.byteOffset + offset, dst._capnp.depthLimit - 1);\n    copyFrom(srcPtr, dstPtr);\n  } // Don't touch dst if it's already initialized as a composite list pointer. With composite struct pointers there's\n  // no pointer to copy here and we've already copied the contents.\n\n\n  if (dst._capnp.compositeList) return; // Initialize the struct pointer.\n\n  var res = initPointer(dstContent.segment, dstContent.byteOffset, dst);\n  setStructPointer(res.offsetWords, srcSize, res.pointer);\n}\n\nexports.copyFromStruct = copyFromStruct;\n/**\n * Track the allocation of a new Pointer object.\n *\n * This will decrement an internal counter tracking how many bytes have been traversed in the message so far. After\n * a certain limit, this method will throw an error in order to prevent a certain class of DoS attacks.\n *\n * @param {Message} message The message the pointer belongs to.\n * @param {Pointer} p The pointer being allocated.\n * @returns {void}\n */\n\nfunction trackPointerAllocation(message, p) {\n  message._capnp.traversalLimit -= 8;\n\n  if (message._capnp.traversalLimit <= 0) {\n    throw new Error(util_1.format(errors_1.PTR_TRAVERSAL_LIMIT_EXCEEDED, p));\n  }\n}\n\nexports.trackPointerAllocation = trackPointerAllocation;","map":{"version":3,"sources":["serialization/pointers/pointer.ts"],"names":[],"mappings":"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","sourceRoot":"../../../src","sourcesContent":["\"use strict\";\n/**\n * @author jdiaz5513\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar debug_1 = require(\"debug\");\nvar constants_1 = require(\"../../constants\");\nvar util_1 = require(\"../../util\");\nvar list_element_size_1 = require(\"../list-element-size\");\nvar object_size_1 = require(\"../object-size\");\nvar orphan_1 = require(\"./orphan\");\nvar pointer_allocation_result_1 = require(\"./pointer-allocation-result\");\nvar pointer_type_1 = require(\"./pointer-type\");\nvar errors_1 = require(\"../../errors\");\nvar trace = debug_1.default('capnp:pointer');\ntrace('load');\n/**\n * A pointer referencing a single byte location in a segment. This is typically used for Cap'n Proto pointers, but is\n * also sometimes used to reference an offset to a pointer's content or tag words.\n *\n * @export\n * @class Pointer\n */\nvar Pointer = /** @class */ (function () {\n    function Pointer(segment, byteOffset, depthLimit) {\n        if (depthLimit === void 0) { depthLimit = constants_1.MAX_DEPTH; }\n        if (depthLimit === 0)\n            throw new Error(util_1.format(errors_1.PTR_DEPTH_LIMIT_EXCEEDED, this));\n        // Make sure we keep track of all pointer allocations; there's a limit per message (prevent DoS).\n        trackPointerAllocation(segment.message, this);\n        // NOTE: It's okay to have a pointer to the end of the segment; you'll see this when creating pointers to the\n        // beginning of the content of a newly-allocated composite list with zero elements. Unlike other language\n        // implementations buffer over/underflows are not a big issue since all buffer access is bounds checked in native\n        // code anyway.\n        if (byteOffset < 0 || byteOffset > segment.byteLength) {\n            throw new Error(util_1.format(errors_1.PTR_OFFSET_OUT_OF_BOUNDS, byteOffset));\n        }\n        this._capnp = { compositeList: false, depthLimit: depthLimit };\n        this.segment = segment;\n        this.byteOffset = byteOffset;\n        trace('new %s', this);\n    }\n    Pointer.prototype.toString = function () {\n        return util_1.format('Pointer_%d@%a,%s,limit:%x', this.segment.id, this.byteOffset, dump(this), this._capnp.depthLimit);\n    };\n    Pointer.adopt = adopt;\n    Pointer.copyFrom = copyFrom;\n    Pointer.disown = disown;\n    Pointer.dump = dump;\n    Pointer.isNull = isNull;\n    Pointer._capnp = {\n        displayName: 'Pointer',\n    };\n    return Pointer;\n}());\nexports.Pointer = Pointer;\n/**\n * Adopt an orphaned pointer, making the pointer point to the orphaned content without copying it.\n *\n * @param {Orphan<Pointer>} src The orphan to adopt.\n * @param {Pointer} p The the pointer to adopt into.\n * @returns {void}\n */\nfunction adopt(src, p) {\n    src._moveTo(p);\n}\nexports.adopt = adopt;\n/**\n * Convert a pointer to an Orphan, zeroing out the pointer and leaving its content untouched. If the content is no\n * longer needed, call `disown()` on the orphaned pointer to erase the contents as well.\n *\n * Call `adopt()` on the orphan with the new target pointer location to move it back into the message; the orphan\n * object is then invalidated after adoption (can only adopt once!).\n *\n * @param {T} p The pointer to turn into an Orphan.\n * @returns {Orphan<T>} An orphaned pointer.\n */\nfunction disown(p) {\n    return new orphan_1.Orphan(p);\n}\nexports.disown = disown;\nfunction dump(p) {\n    return util_1.bufferToHex(p.segment.buffer.slice(p.byteOffset, p.byteOffset + 8));\n}\nexports.dump = dump;\n/**\n * Get the total number of bytes required to hold a list of the provided size with the given length, rounded up to the\n * nearest word.\n *\n * @param {ListElementSize} elementSize A number describing the size of the list elements.\n * @param {number} length The length of the list.\n * @param {ObjectSize} [compositeSize] The size of each element in a composite list; required if\n * `elementSize === ListElementSize.COMPOSITE`.\n * @returns {number} The number of bytes required to hold an element of that size, or `NaN` if that is undefined.\n */\nfunction getListByteLength(elementSize, length, compositeSize) {\n    switch (elementSize) {\n        case list_element_size_1.ListElementSize.BIT:\n            return util_1.padToWord(length + 7 >>> 3);\n        case list_element_size_1.ListElementSize.BYTE:\n        case list_element_size_1.ListElementSize.BYTE_2:\n        case list_element_size_1.ListElementSize.BYTE_4:\n        case list_element_size_1.ListElementSize.BYTE_8:\n        case list_element_size_1.ListElementSize.POINTER:\n        case list_element_size_1.ListElementSize.VOID:\n            return util_1.padToWord(getListElementByteLength(elementSize) * length);\n        /* istanbul ignore next */\n        case list_element_size_1.ListElementSize.COMPOSITE:\n            if (compositeSize === undefined)\n                throw new Error(util_1.format(errors_1.PTR_INVALID_LIST_SIZE, NaN));\n            return length * util_1.padToWord(object_size_1.getByteLength(compositeSize));\n        /* istanbul ignore next */\n        default:\n            throw new Error(errors_1.PTR_INVALID_LIST_SIZE);\n    }\n}\nexports.getListByteLength = getListByteLength;\n/**\n * Get the number of bytes required to hold a list element of the provided size. `COMPOSITE` elements do not have a\n * fixed size, and `BIT` elements are packed into exactly a single bit, so these both return `NaN`.\n *\n * @param {ListElementSize} elementSize A number describing the size of the list elements.\n * @returns {number} The number of bytes required to hold an element of that size, or `NaN` if that is undefined.\n */\nfunction getListElementByteLength(elementSize) {\n    switch (elementSize) {\n        /* istanbul ignore next */\n        case list_element_size_1.ListElementSize.BIT:\n            return NaN;\n        case list_element_size_1.ListElementSize.BYTE:\n            return 1;\n        case list_element_size_1.ListElementSize.BYTE_2:\n            return 2;\n        case list_element_size_1.ListElementSize.BYTE_4:\n            return 4;\n        case list_element_size_1.ListElementSize.BYTE_8:\n        case list_element_size_1.ListElementSize.POINTER:\n            return 8;\n        /* istanbul ignore next */\n        case list_element_size_1.ListElementSize.COMPOSITE:\n            // Caller has to figure it out based on the tag word.\n            return NaN;\n        /* istanbul ignore next */\n        case list_element_size_1.ListElementSize.VOID:\n            return 0;\n        /* istanbul ignore next */\n        default:\n            throw new Error(util_1.format(errors_1.PTR_INVALID_LIST_SIZE, elementSize));\n    }\n}\nexports.getListElementByteLength = getListElementByteLength;\n/**\n * Add an offset to the pointer's offset and return a new Pointer for that address.\n *\n * @param {number} offset The number of bytes to add to the offset.\n * @param {Pointer} p The pointer to add from.\n * @returns {Pointer} A new pointer to the address.\n */\nfunction add(offset, p) {\n    return new Pointer(p.segment, p.byteOffset + offset, p._capnp.depthLimit);\n}\nexports.add = add;\n/**\n * Replace a pointer with a deep copy of the pointer at `src` and all of its contents.\n *\n * @param {Pointer} src The pointer to copy.\n * @param {Pointer} p The pointer to copy into.\n * @returns {void}\n */\nfunction copyFrom(src, p) {\n    // If the pointer is the same then this is a noop.\n    if (p.segment === src.segment && p.byteOffset === src.byteOffset) {\n        trace('ignoring copy operation from identical pointer %s', src);\n        return;\n    }\n    // Make sure we erase this pointer's contents before moving on. If src is null, that's all we do.\n    erase(p); // noop if null\n    if (isNull(src))\n        return;\n    switch (getTargetPointerType(src)) {\n        case pointer_type_1.PointerType.STRUCT:\n            copyFromStruct(src, p);\n            break;\n        case pointer_type_1.PointerType.LIST:\n            copyFromList(src, p);\n            break;\n        /* istanbul ignore next */\n        default:\n            throw new Error(util_1.format(errors_1.PTR_INVALID_POINTER_TYPE, getTargetPointerType(p)));\n    }\n}\nexports.copyFrom = copyFrom;\n/**\n * Recursively erase a pointer, any far pointers/landing pads/tag words, and the content it points to.\n *\n * Note that this will leave \"holes\" of zeroes in the message, since the space cannot be reclaimed. With packing this\n * will have a negligible effect on the final message size.\n *\n * FIXME: This may need protection against infinite recursion...\n *\n * @param {Pointer} p The pointer to erase.\n * @returns {void}\n */\nfunction erase(p) {\n    if (isNull(p))\n        return;\n    // First deal with the contents.\n    var c;\n    switch (getTargetPointerType(p)) {\n        case pointer_type_1.PointerType.STRUCT:\n            var size = getTargetStructSize(p);\n            c = getContent(p);\n            // Wipe the data section.\n            c.segment.fillZeroWords(c.byteOffset, size.dataByteLength / 8);\n            // Iterate over all the pointers and nuke them.\n            for (var i = 0; i < size.pointerLength; i++) {\n                erase(add(i * 8, c));\n            }\n            break;\n        case pointer_type_1.PointerType.LIST:\n            var elementSize = getTargetListElementSize(p);\n            var length = getTargetListLength(p);\n            var contentWords = util_1.padToWord(length * getListElementByteLength(elementSize));\n            c = getContent(p);\n            if (elementSize === list_element_size_1.ListElementSize.POINTER) {\n                for (var i = 0; i < length; i++) {\n                    erase(new Pointer(c.segment, c.byteOffset + i * 8, p._capnp.depthLimit - 1));\n                }\n                // Calling erase on each pointer takes care of the content, nothing left to do here.\n                break;\n            }\n            else if (elementSize === list_element_size_1.ListElementSize.COMPOSITE) {\n                // Read some stuff from the tag word.\n                var tag = add(-8, c);\n                var compositeSize = getStructSize(tag);\n                var compositeByteLength = object_size_1.getByteLength(compositeSize);\n                contentWords = getOffsetWords(tag);\n                // Kill the tag word.\n                c.segment.setWordZero(c.byteOffset - 8);\n                // Recursively erase each pointer.\n                for (var i = 0; i < length; i++) {\n                    for (var j = 0; j < compositeSize.pointerLength; j++) {\n                        erase(new Pointer(c.segment, c.byteOffset + i * compositeByteLength + j * 8, p._capnp.depthLimit - 1));\n                    }\n                }\n            }\n            c.segment.fillZeroWords(c.byteOffset, contentWords);\n            break;\n        case pointer_type_1.PointerType.OTHER:\n            // No content.\n            break;\n        default:\n            throw new Error(util_1.format(errors_1.PTR_INVALID_POINTER_TYPE, getTargetPointerType(p)));\n    }\n    erasePointer(p);\n}\nexports.erase = erase;\n/**\n * Set the pointer (and far pointer landing pads, if applicable) to zero. Does not touch the pointer's content.\n *\n * @param {Pointer} p The pointer to erase.\n * @returns {void}\n */\nfunction erasePointer(p) {\n    if (getPointerType(p) === pointer_type_1.PointerType.FAR) {\n        var landingPad = followFar(p);\n        if (isDoubleFar(p)) {\n            // Kill the double-far tag word.\n            landingPad.segment.setWordZero(landingPad.byteOffset + 8);\n        }\n        // Kill the landing pad.\n        landingPad.segment.setWordZero(landingPad.byteOffset);\n    }\n    // Finally! Kill the pointer itself...\n    p.segment.setWordZero(p.byteOffset);\n}\nexports.erasePointer = erasePointer;\n/**\n * Interpret the pointer as a far pointer, returning its target segment and offset.\n *\n * @param {Pointer} p The pointer to read from.\n * @returns {Pointer} A pointer to the far target.\n */\nfunction followFar(p) {\n    var targetSegment = p.segment.message.getSegment(p.segment.getUint32(p.byteOffset + 4));\n    var targetWordOffset = p.segment.getUint32(p.byteOffset) >>> 3;\n    return new Pointer(targetSegment, targetWordOffset * 8, p._capnp.depthLimit - 1);\n}\nexports.followFar = followFar;\n/**\n * If the pointer address references a far pointer, follow it to the location where the actual pointer data is written.\n * Otherwise, returns the pointer unmodified.\n *\n * @param {Pointer} p The pointer to read from.\n * @returns {Pointer} A new pointer representing the target location, or `p` if it is not a far pointer.\n */\nfunction followFars(p) {\n    if (getPointerType(p) === pointer_type_1.PointerType.FAR) {\n        var landingPad = followFar(p);\n        if (isDoubleFar(p))\n            landingPad.byteOffset += 8;\n        return landingPad;\n    }\n    return p;\n}\nexports.followFars = followFars;\nfunction getCapabilityId(p) {\n    return p.segment.getUint32(p.byteOffset + 4);\n}\nexports.getCapabilityId = getCapabilityId;\nfunction isCompositeList(p) {\n    return getTargetPointerType(p) === pointer_type_1.PointerType.LIST && getTargetListElementSize(p) === list_element_size_1.ListElementSize.COMPOSITE;\n}\n/**\n * Obtain the location of the pointer's content, following far pointers as needed.\n * If the pointer is a struct pointer and `compositeIndex` is set, it will be offset by a multiple of the struct's size.\n *\n * @param {Pointer} p The pointer to read from.\n * @param {boolean} [ignoreCompositeIndex] If true, will not follow the composite struct pointer's composite index and\n * instead return a pointer to the parent list's contents (also the beginning of the first struct).\n * @returns {Pointer} A pointer to the beginning of the pointer's content.\n */\nfunction getContent(p, ignoreCompositeIndex) {\n    var c;\n    if (isDoubleFar(p)) {\n        var landingPad = followFar(p);\n        c = new Pointer(p.segment.message.getSegment(getFarSegmentId(landingPad)), getOffsetWords(landingPad) * 8);\n    }\n    else {\n        var target = followFars(p);\n        c = new Pointer(target.segment, target.byteOffset + 8 + getOffsetWords(target) * 8);\n    }\n    if (isCompositeList(p))\n        c.byteOffset += 8;\n    if (!ignoreCompositeIndex && p._capnp.compositeIndex !== undefined) {\n        // Seek backwards by one word so we can read the struct size off the tag word.\n        c.byteOffset -= 8;\n        // Seek ahead by `compositeIndex` multiples of the struct's total size.\n        c.byteOffset += 8 + p._capnp.compositeIndex * object_size_1.getByteLength(object_size_1.padToWord(getStructSize(c)));\n    }\n    return c;\n}\nexports.getContent = getContent;\n/**\n * Read the target segment ID from a far pointer.\n *\n * @param {Pointer} p The pointer to read from.\n * @returns {number} The target segment ID.\n */\nfunction getFarSegmentId(p) {\n    return p.segment.getUint32(p.byteOffset + 4);\n}\nexports.getFarSegmentId = getFarSegmentId;\n/**\n * Get a number indicating the size of the list's elements.\n *\n * @param {Pointer} p The pointer to read from.\n * @returns {ListElementSize} The size of the list's elements.\n */\nfunction getListElementSize(p) {\n    return p.segment.getUint32(p.byteOffset + 4) & constants_1.LIST_SIZE_MASK;\n}\nexports.getListElementSize = getListElementSize;\n/**\n * Get the number of elements in a list pointer. For composite lists, it instead represents the total number of words in\n * the list (not counting the tag word).\n *\n * This method does **not** attempt to distinguish between composite and non-composite lists. To get the correct\n * length for composite lists use `getTargetListLength()` instead.\n *\n * @param {Pointer} p The pointer to read from.\n * @returns {number} The length of the list, or total number of words for composite lists.\n */\nfunction getListLength(p) {\n    return p.segment.getUint32(p.byteOffset + 4) >>> 3;\n}\nexports.getListLength = getListLength;\n/**\n * Get the offset (in words) from the end of a pointer to the start of its content. For struct pointers, this is the\n * beginning of the data section, and for list pointers it is the location of the first element. The value should\n * always be zero for interface pointers.\n *\n * @param {Pointer} p The pointer to read from.\n * @returns {number} The offset, in words, from the end of the pointer to the start of the data section.\n */\nfunction getOffsetWords(p) {\n    var o = p.segment.getInt32(p.byteOffset);\n    // Far pointers only have 29 offset bits.\n    return o & 2 ? o >> 3 : o >> 2;\n}\nexports.getOffsetWords = getOffsetWords;\n/**\n * Look up the pointer's type.\n *\n * @param {Pointer} p The pointer to read from.\n * @returns {PointerType} The type of pointer.\n */\nfunction getPointerType(p) {\n    return p.segment.getUint32(p.byteOffset) & constants_1.POINTER_TYPE_MASK;\n}\nexports.getPointerType = getPointerType;\n/**\n * Read the number of data words from this struct pointer.\n *\n * @param {Pointer} p The pointer to read from.\n * @returns {number} The number of data words in the struct.\n */\nfunction getStructDataWords(p) {\n    return p.segment.getUint16(p.byteOffset + 4);\n}\nexports.getStructDataWords = getStructDataWords;\n/**\n * Read the number of pointers contained in this struct pointer.\n *\n * @param {Pointer} p The pointer to read from.\n * @returns {number} The number of pointers in this struct.\n */\nfunction getStructPointerLength(p) {\n    return p.segment.getUint16(p.byteOffset + 6);\n}\nexports.getStructPointerLength = getStructPointerLength;\n/**\n * Get an object describing this struct pointer's size.\n *\n * @param {Pointer} p The pointer to read from.\n * @returns {ObjectSize} The size of the struct.\n */\nfunction getStructSize(p) {\n    return new object_size_1.ObjectSize(getStructDataWords(p) * 8, getStructPointerLength(p));\n}\nexports.getStructSize = getStructSize;\n/**\n * Get a pointer to this pointer's composite list tag word, following far pointers as needed.\n *\n * @param {Pointer} p The pointer to read from.\n * @returns {Pointer} A pointer to the list's composite tag word.\n */\nfunction getTargetCompositeListTag(p) {\n    var c = getContent(p);\n    // The composite list tag is always one word before the content.\n    c.byteOffset -= 8;\n    return c;\n}\nexports.getTargetCompositeListTag = getTargetCompositeListTag;\n/**\n * Get the object size for the target composite list, following far pointers as needed.\n *\n * @param {Pointer} p The pointer to read from.\n * @returns {ObjectSize} An object describing the size of each struct in the list.\n */\nfunction getTargetCompositeListSize(p) {\n    return getStructSize(getTargetCompositeListTag(p));\n}\nexports.getTargetCompositeListSize = getTargetCompositeListSize;\n/**\n * Get the size of the list elements referenced by this pointer, following far pointers if necessary.\n *\n * @param {Pointer} p The pointer to read from.\n * @returns {ListElementSize} The size of the elements in the list.\n */\nfunction getTargetListElementSize(p) {\n    return getListElementSize(followFars(p));\n}\nexports.getTargetListElementSize = getTargetListElementSize;\n/**\n * Get the length of the list referenced by this pointer, following far pointers if necessary. If the list is a\n * composite list, it will look up the tag word and read the length from there.\n *\n * @param {Pointer} p The pointer to read from.\n * @returns {number} The number of elements in the list.\n */\nfunction getTargetListLength(p) {\n    var t = followFars(p);\n    if (getListElementSize(t) === list_element_size_1.ListElementSize.COMPOSITE) {\n        // The content is prefixed by a tag word; it's a struct pointer whose offset contains the list's length.\n        return getOffsetWords(getTargetCompositeListTag(p));\n    }\n    return getListLength(t);\n}\nexports.getTargetListLength = getTargetListLength;\n/**\n * Get the type of a pointer, following far pointers if necessary. For non-far pointers this is equivalent to calling\n * `getPointerType()`.\n *\n * The target of a far pointer can never be another far pointer, and this method will throw if such a situation is\n * encountered.\n *\n * @param {Pointer} p The pointer to read from.\n * @returns {PointerType} The type of pointer referenced by this pointer.\n */\nfunction getTargetPointerType(p) {\n    var t = getPointerType(followFars(p));\n    if (t === pointer_type_1.PointerType.FAR)\n        throw new Error(util_1.format(errors_1.PTR_INVALID_FAR_TARGET, p));\n    return t;\n}\nexports.getTargetPointerType = getTargetPointerType;\n/**\n * Get the size of the struct referenced by a pointer, following far pointers if necessary.\n *\n * @param {Pointer} p The poiner to read from.\n * @returns {ObjectSize} The size of the struct referenced by this pointer.\n */\nfunction getTargetStructSize(p) {\n    return getStructSize(followFars(p));\n}\nexports.getTargetStructSize = getTargetStructSize;\n/**\n * Initialize a pointer to point at the data in the content segment. If the content segment is not the same as the\n * pointer's segment, this will allocate and write far pointers as needed. Nothing is written otherwise.\n *\n * The return value includes a pointer to write the pointer's actual data to (the eventual far target), and the offset\n * value (in words) to use for that pointer. In the case of double-far pointers this offset will always be zero.\n *\n * @param {Segment} contentSegment The segment containing this pointer's content.\n * @param {number} contentOffset The offset within the content segment for the beginning of this pointer's content.\n * @param {Pointer} p The pointer to initialize.\n * @returns {PointerAllocationResult} An object containing a pointer (where the pointer data should be written), and\n * the value to use as the offset for that pointer.\n */\nfunction initPointer(contentSegment, contentOffset, p) {\n    if (p.segment !== contentSegment) {\n        // Need a far pointer.\n        trace('Initializing far pointer %s -> %s.', p, contentSegment);\n        if (!contentSegment.hasCapacity(8)) {\n            // GAH! Not enough space in the content segment for a landing pad so we need a double far pointer.\n            var landingPad_1 = p.segment.allocate(16);\n            trace('GAH! Initializing double-far pointer in %s from %s -> %s.', p, contentSegment, landingPad_1);\n            setFarPointer(true, landingPad_1.byteOffset / 8, landingPad_1.segment.id, p);\n            setFarPointer(false, contentOffset / 8, contentSegment.id, landingPad_1);\n            landingPad_1.byteOffset += 8;\n            return new pointer_allocation_result_1.PointerAllocationResult(landingPad_1, 0);\n        }\n        // Allocate a far pointer landing pad in the target segment.\n        var landingPad = contentSegment.allocate(8);\n        if (landingPad.segment.id !== contentSegment.id) {\n            throw new Error(errors_1.INVARIANT_UNREACHABLE_CODE);\n        }\n        setFarPointer(false, landingPad.byteOffset / 8, landingPad.segment.id, p);\n        return new pointer_allocation_result_1.PointerAllocationResult(landingPad, (contentOffset - landingPad.byteOffset - 8) / 8);\n    }\n    trace('Initializing intra-segment pointer %s -> %a.', p, contentOffset);\n    return new pointer_allocation_result_1.PointerAllocationResult(p, (contentOffset - p.byteOffset - 8) / 8);\n}\nexports.initPointer = initPointer;\n/**\n * Check if the pointer is a double-far pointer.\n *\n * @param {Pointer} p The pointer to read from.\n * @returns {boolean} `true` if it is a double-far pointer, `false` otherwise.\n */\nfunction isDoubleFar(p) {\n    return getPointerType(p) === pointer_type_1.PointerType.FAR && (p.segment.getUint32(p.byteOffset) & constants_1.POINTER_DOUBLE_FAR_MASK) !== 0;\n}\nexports.isDoubleFar = isDoubleFar;\n/**\n * Quickly check to see if the pointer is \"null\". A \"null\" pointer is a zero word, equivalent to an empty struct\n * pointer.\n *\n * @param {Pointer} p The pointer to read from.\n * @returns {boolean} `true` if the pointer is \"null\".\n */\nfunction isNull(p) {\n    return p.segment.isWordZero(p.byteOffset);\n}\nexports.isNull = isNull;\n/**\n * Relocate a pointer to the given destination, ensuring that it points to the same content. This will create far\n * pointers as needed if the content is in a different segment than the destination. After the relocation the source\n * pointer will be erased and is no longer valid.\n *\n * @param {Pointer} dst The desired location for the `src` pointer. Any existing contents will be erased before\n * relocating!\n * @param {Pointer} src The pointer to relocate.\n * @returns {void}\n */\nfunction relocateTo(dst, src) {\n    var t = followFars(src);\n    var lo = t.segment.getUint8(t.byteOffset) & 0x03; // discard the offset\n    var hi = t.segment.getUint32(t.byteOffset + 4);\n    // Make sure anything dst was pointing to is wiped out.\n    erase(dst);\n    var res = initPointer(t.segment, t.byteOffset + 8 + getOffsetWords(t) * 8, dst);\n    // Keep the low 2 bits and write the new offset.\n    res.pointer.segment.setUint32(res.pointer.byteOffset, lo | (res.offsetWords << 2));\n    // Keep the high 32 bits intact.\n    res.pointer.segment.setUint32(res.pointer.byteOffset + 4, hi);\n    erasePointer(src);\n}\nexports.relocateTo = relocateTo;\n/**\n * Write a far pointer.\n *\n * @param {boolean} doubleFar Set to `true` if this is a double far pointer.\n * @param {number} offsetWords The offset, in words, to the target pointer.\n * @param {number} segmentId The segment the target pointer is located in.\n * @param {Pointer} p The pointer to write to.\n * @returns {void}\n */\nfunction setFarPointer(doubleFar, offsetWords, segmentId, p) {\n    var A = pointer_type_1.PointerType.FAR;\n    var B = doubleFar ? 1 : 0;\n    var C = offsetWords;\n    var D = segmentId;\n    p.segment.setUint32(p.byteOffset, A | B << 2 | C << 3);\n    p.segment.setUint32(p.byteOffset + 4, D);\n}\nexports.setFarPointer = setFarPointer;\n/**\n * Write a raw interface pointer.\n *\n * @param {number} capId The capability ID.\n * @param {Pointer} p The pointer to write to.\n * @returns {void}\n */\nfunction setInterfacePointer(capId, p) {\n    p.segment.setUint32(p.byteOffset, pointer_type_1.PointerType.OTHER);\n    p.segment.setUint32(p.byteOffset + 4, capId);\n}\nexports.setInterfacePointer = setInterfacePointer;\n/**\n * Write a raw list pointer.\n *\n * @param {number} offsetWords The number of words from the end of this pointer to the beginning of the list content.\n * @param {ListElementSize} size The size of each element in the list.\n * @param {number} length The number of elements in the list.\n * @param {Pointer} p The pointer to write to.\n * @param {ObjectSize} [compositeSize] For composite lists this describes the size of each element in this list. This\n * is required for composite lists.\n * @returns {void}\n */\nfunction setListPointer(offsetWords, size, length, p, compositeSize) {\n    if (p === undefined)\n        throw new Error(errors_1.INVARIANT_UNREACHABLE_CODE);\n    var A = pointer_type_1.PointerType.LIST;\n    var B = offsetWords;\n    var C = size;\n    var D = length;\n    if (size === list_element_size_1.ListElementSize.COMPOSITE) {\n        if (compositeSize === undefined)\n            throw new TypeError(errors_1.TYPE_COMPOSITE_SIZE_UNDEFINED);\n        D *= object_size_1.getWordLength(compositeSize);\n    }\n    p.segment.setUint32(p.byteOffset, A | B << 2);\n    p.segment.setUint32(p.byteOffset + 4, C | D << 3);\n}\nexports.setListPointer = setListPointer;\n/**\n * Write a raw struct pointer.\n *\n * @param {number} offsetWords The number of words from the end of this pointer to the beginning of the struct's data\n * section.\n * @param {ObjectSize} size An object describing the size of the struct.\n * @param {Pointer} p The pointer to write to.\n * @returns {void}\n */\nfunction setStructPointer(offsetWords, size, p) {\n    var A = pointer_type_1.PointerType.STRUCT;\n    var B = offsetWords;\n    var C = object_size_1.getDataWordLength(size);\n    var D = size.pointerLength;\n    p.segment.setUint32(p.byteOffset, A | B << 2);\n    p.segment.setUint16(p.byteOffset + 4, C);\n    p.segment.setUint16(p.byteOffset + 6, D);\n}\nexports.setStructPointer = setStructPointer;\n/**\n * Read some bits off a pointer to make sure it has the right pointer data.\n *\n * @param {PointerType} pointerType The expected pointer type.\n * @param {Pointer} p The pointer to validate.\n * @param {ListElementSize} [elementSize] For list pointers, the expected element size. Leave this\n * undefined for struct pointers.\n * @returns {void}\n */\nfunction validate(pointerType, p, elementSize) {\n    if (isNull(p))\n        return;\n    var t = followFars(p);\n    // Check the pointer type.\n    var A = t.segment.getUint32(t.byteOffset) & constants_1.POINTER_TYPE_MASK;\n    if (A !== pointerType)\n        throw new Error(util_1.format(errors_1.PTR_WRONG_POINTER_TYPE, p, pointerType));\n    // Check the list element size, if provided.\n    if (elementSize !== undefined) {\n        var C = t.segment.getUint32(t.byteOffset + 4) & constants_1.LIST_SIZE_MASK;\n        if (C !== elementSize)\n            throw new Error(util_1.format(errors_1.PTR_WRONG_LIST_TYPE, p, list_element_size_1.ListElementSize[elementSize]));\n    }\n}\nexports.validate = validate;\nfunction copyFromList(src, dst) {\n    if (dst._capnp.depthLimit <= 0)\n        throw new Error(errors_1.PTR_DEPTH_LIMIT_EXCEEDED);\n    var srcContent = getContent(src);\n    var srcElementSize = getTargetListElementSize(src);\n    var srcLength = getTargetListLength(src);\n    var srcCompositeSize;\n    var srcStructByteLength;\n    var dstContent;\n    if (srcElementSize === list_element_size_1.ListElementSize.POINTER) {\n        dstContent = dst.segment.allocate(object_size_1.getByteLength(getTargetCompositeListSize(src)) * srcLength);\n        // Recursively copy each pointer in the list.\n        for (var i = 0; i < srcLength; i++) {\n            var srcPtr = new Pointer(srcContent.segment, srcContent.byteOffset + (i << 3), src._capnp.depthLimit - 1);\n            var dstPtr = new Pointer(dstContent.segment, dstContent.byteOffset + (i << 3), dst._capnp.depthLimit - 1);\n            copyFrom(srcPtr, dstPtr);\n        }\n    }\n    else if (srcElementSize === list_element_size_1.ListElementSize.COMPOSITE) {\n        srcCompositeSize = object_size_1.padToWord(getTargetCompositeListSize(src));\n        srcStructByteLength = object_size_1.getByteLength(srcCompositeSize);\n        dstContent = dst.segment.allocate(object_size_1.getByteLength(srcCompositeSize) * srcLength + 8);\n        // Copy the tag word.\n        dstContent.segment.copyWord(dstContent.byteOffset, srcContent.segment, srcContent.byteOffset - 8);\n        // Copy the entire contents, including all pointers. This should be more efficient than making `srcLength`\n        // copies to skip the pointer sections, and we're about to rewrite all those pointers anyway.\n        // PERF: Skip this step if the composite struct only contains pointers.\n        if (srcCompositeSize.dataByteLength > 0) {\n            var wordLength = object_size_1.getWordLength(srcCompositeSize) * srcLength;\n            dstContent.segment.copyWords(dstContent.byteOffset + 8, srcContent.segment, srcContent.byteOffset, wordLength);\n        }\n        // Recursively copy all the pointers in each struct.\n        for (var i = 0; i < srcLength; i++) {\n            for (var j = 0; j < srcCompositeSize.pointerLength; j++) {\n                var offset = i * srcStructByteLength + srcCompositeSize.dataByteLength + (j << 3);\n                var srcPtr = new Pointer(srcContent.segment, srcContent.byteOffset + offset, src._capnp.depthLimit - 1);\n                var dstPtr = new Pointer(dstContent.segment, dstContent.byteOffset + offset + 8, dst._capnp.depthLimit - 1);\n                copyFrom(srcPtr, dstPtr);\n            }\n        }\n    }\n    else {\n        var byteLength = util_1.padToWord(srcElementSize === list_element_size_1.ListElementSize.BIT\n            ? srcLength + 7 >>> 3\n            : getListElementByteLength(srcElementSize) * srcLength);\n        var wordLength = byteLength >>> 3;\n        dstContent = dst.segment.allocate(byteLength);\n        // Copy all of the list contents word-by-word.\n        dstContent.segment.copyWords(dstContent.byteOffset, srcContent.segment, srcContent.byteOffset, wordLength);\n    }\n    // Initialize the list pointer.\n    var res = initPointer(dstContent.segment, dstContent.byteOffset, dst);\n    setListPointer(res.offsetWords, srcElementSize, srcLength, res.pointer, srcCompositeSize);\n}\nexports.copyFromList = copyFromList;\nfunction copyFromStruct(src, dst) {\n    if (dst._capnp.depthLimit <= 0)\n        throw new Error(errors_1.PTR_DEPTH_LIMIT_EXCEEDED);\n    var srcContent = getContent(src);\n    var srcSize = getTargetStructSize(src);\n    var srcDataWordLength = object_size_1.getDataWordLength(srcSize);\n    // Allocate space for the destination content.\n    var dstContent = dst.segment.allocate(object_size_1.getByteLength(srcSize));\n    // Copy the data section.\n    dstContent.segment.copyWords(dstContent.byteOffset, srcContent.segment, srcContent.byteOffset, srcDataWordLength);\n    // Copy the pointer section.\n    for (var i = 0; i < srcSize.pointerLength; i++) {\n        var offset = srcSize.dataByteLength + i * 8;\n        var srcPtr = new Pointer(srcContent.segment, srcContent.byteOffset + offset, src._capnp.depthLimit - 1);\n        var dstPtr = new Pointer(dstContent.segment, dstContent.byteOffset + offset, dst._capnp.depthLimit - 1);\n        copyFrom(srcPtr, dstPtr);\n    }\n    // Don't touch dst if it's already initialized as a composite list pointer. With composite struct pointers there's\n    // no pointer to copy here and we've already copied the contents.\n    if (dst._capnp.compositeList)\n        return;\n    // Initialize the struct pointer.\n    var res = initPointer(dstContent.segment, dstContent.byteOffset, dst);\n    setStructPointer(res.offsetWords, srcSize, res.pointer);\n}\nexports.copyFromStruct = copyFromStruct;\n/**\n * Track the allocation of a new Pointer object.\n *\n * This will decrement an internal counter tracking how many bytes have been traversed in the message so far. After\n * a certain limit, this method will throw an error in order to prevent a certain class of DoS attacks.\n *\n * @param {Message} message The message the pointer belongs to.\n * @param {Pointer} p The pointer being allocated.\n * @returns {void}\n */\nfunction trackPointerAllocation(message, p) {\n    message._capnp.traversalLimit -= 8;\n    if (message._capnp.traversalLimit <= 0) {\n        throw new Error(util_1.format(errors_1.PTR_TRAVERSAL_LIMIT_EXCEEDED, p));\n    }\n}\nexports.trackPointerAllocation = trackPointerAllocation;\n\n//# sourceMappingURL=pointer.js.map\n"]},"metadata":{},"sourceType":"script"}