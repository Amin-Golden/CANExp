{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.fetchRoutes = undefined;\n\nvar _toConsumableArray2 = require('babel-runtime/helpers/toConsumableArray');\n\nvar _toConsumableArray3 = _interopRequireDefault(_toConsumableArray2);\n\nvar _isFinite = require('babel-runtime/core-js/number/is-finite');\n\nvar _isFinite2 = _interopRequireDefault(_isFinite);\n\nvar _regenerator = require('babel-runtime/regenerator');\n\nvar _regenerator2 = _interopRequireDefault(_regenerator);\n\nvar _asyncToGenerator2 = require('babel-runtime/helpers/asyncToGenerator');\n\nvar _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);\n\nvar fetchRoutes = exports.fetchRoutes = function () {\n  var _ref = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee(dongleId, start, end) {\n    var segments;\n    return _regenerator2.default.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            _context.next = 2;\n            return getSegmentMetadata(start, end, dongleId);\n\n          case 2:\n            segments = _context.sent;\n            segments = parseSegmentMetadata(start, end, segments);\n            return _context.abrupt('return', segmentsFromMetadata(segments).reverse());\n\n          case 5:\n          case 'end':\n            return _context.stop();\n        }\n      }\n    }, _callee, this);\n  }));\n\n  return function fetchRoutes(_x, _x2, _x3) {\n    return _ref.apply(this, arguments);\n  };\n}();\n\nexports.getSegmentMetadata = getSegmentMetadata;\nexports.getRoutesSegments = getRoutesSegments;\nexports.getRouteInfo = getRouteInfo;\nexports.setRouteRating = setRouteRating;\nexports.getShareSignature = getShareSignature;\nexports.getRouteSegments = getRouteSegments;\nexports.listRoutes = listRoutes;\n\nvar _request = require('./request');\n\nvar request = _interopRequireWildcard(_request);\n\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  } else {\n    var newObj = {};\n\n    if (obj != null) {\n      for (var key in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];\n      }\n    }\n\n    newObj.default = obj;\n    return newObj;\n  }\n}\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nvar SEGMENT_LENGTH = 1000 * 60; // Drives api\n// ~~~~~~~~~~\n\nfunction getSegmentMetadata(start, end, dongleId) {\n  return request.get('v1/devices/' + dongleId + '/segments', {\n    from: start,\n    to: end\n  });\n}\n\nfunction getRoutesSegments(dongleId, start, end) {\n  return request.get('v1/devices/' + dongleId + '/routes_segments', {\n    start: start,\n    end: end\n  });\n}\n\nfunction getRouteInfo(routeName) {\n  return request.get('v1/route/' + routeName + '/');\n}\n\nfunction setRouteRating(routeName, rating) {\n  return request.patch('v1/route/' + routeName + '/', {\n    rating: rating\n  });\n}\n\nfunction getShareSignature(routeName) {\n  return request.get('v1/route/' + routeName + '/share_signature');\n}\n\nfunction getRouteSegments(routeName) {\n  return request.get('v1/route/' + routeName + '/segments');\n}\n\nfunction listRoutes(dongleId, limit, createdAfter) {\n  var params = {\n    limit: limit\n  };\n\n  if (typeof createdAfter !== 'undefined') {\n    params.createdAfter = createdAfter;\n  }\n\n  return request.get('v1/devices/' + dongleId + '/routes', params);\n}\n\nfunction parseSegmentMetadata(start, end, segments) {\n  var lastSegmentTime = 0;\n  var routeStartTimes = {};\n  return segments.map(function (segment) {\n    segment.offset = Math.round(segment.start_time_utc_millis) - start;\n\n    if (!routeStartTimes[segment.canonical_route_name]) {\n      var segmentNum = Number(segment.canonical_name.split('--')[2]);\n      segment.segment = segmentNum;\n\n      if (segmentNum > 0) {\n        routeStartTimes[segment.canonical_route_name] = segment.offset - SEGMENT_LENGTH * segmentNum;\n      } else {\n        routeStartTimes[segment.canonical_route_name] = segment.offset;\n      }\n\n      segment.routeOffset = routeStartTimes[segment.canonical_route_name];\n    } else {\n      segment.routeOffset = routeStartTimes[segment.canonical_route_name];\n    }\n\n    lastSegmentTime = segment.offset;\n    segment.duration = Math.round(segment.end_time_utc_millis - segment.start_time_utc_millis);\n    return segment;\n  });\n}\n\nfunction segmentsFromMetadata(segmentsData) {\n  var curSegment = null;\n  var curStopTime = null;\n  var curVideoStartOffset = null;\n  var segments = [];\n  segmentsData.forEach(function (segment) {\n    if (!segment.url) {\n      return;\n    }\n\n    if (!(segment.proc_log === 40 || segment.proc_qlog === 40)) {\n      return;\n    }\n\n    var segmentHasDriverCamera = segment.proc_dcamera >= 0;\n    var segmentHasDriverCameraStream = segment.proc_dcamera === 40;\n    var segmentHasVideo = segment.proc_camera === 40;\n\n    if (segmentHasVideo && curVideoStartOffset === null) {\n      curVideoStartOffset = segment.offset;\n    }\n\n    curStopTime = segment.start_time_utc_millis;\n\n    if (!curSegment || curSegment.route !== segment.canonical_route_name) {\n      if (curSegment) {\n        finishSegment(curSegment);\n      }\n\n      var url = segment.url;\n      var parts = url.split('/');\n\n      if ((0, _isFinite2.default)(Number(parts.pop()))) {\n        // url has a number at the end\n        url = parts.join('/');\n      }\n\n      curSegment = {\n        dongleId: segment.dongle_id,\n        offset: segment.offset - segment.segment * SEGMENT_LENGTH,\n        route: segment.canonical_route_name,\n        startTime: segment.start_time_utc_millis,\n        startCoord: [segment.start_lng, segment.start_lat],\n        duration: 0,\n        segments: 0,\n        url: url.replace('chffrprivate.blob.core.windows.net', 'chffrprivate.azureedge.net'),\n        events: [],\n        videoAvailableBetweenOffsets: [],\n        hasVideo: segmentHasVideo,\n        deviceType: segment.devicetype,\n        hpgps: segment.hpgps,\n        hasDriverCamera: segmentHasDriverCamera,\n        hasDriverCameraStream: segmentHasDriverCameraStream,\n        locStart: '',\n        locEnd: '',\n        distanceMiles: 0.0,\n        cameraStreamSegCount: 0,\n        driverCameraStreamSegCount: 0\n      };\n      segments.push(curSegment);\n    }\n\n    if (!segmentHasVideo && curVideoStartOffset !== null) {\n      curSegment.videoAvailableBetweenOffsets.push([curVideoStartOffset, segment.offset]);\n      curVideoStartOffset = null;\n    }\n\n    curSegment.hasVideo = curSegment.hasVideo || segmentHasVideo;\n    curSegment.hasDriverCamera = curSegment.hasDriverCamera || segmentHasDriverCamera;\n    curSegment.hasDriverCameraStream = curSegment.hasDriverCameraStream || segmentHasDriverCameraStream;\n    curSegment.hpgps = curSegment.hpgps || segment.hpgps;\n    curSegment.duration = segment.offset - curSegment.offset + segment.duration;\n    curSegment.segments = Math.max(curSegment.segments, Number(segment.canonical_name.split('--').pop()) + 1);\n    curSegment.events = curSegment.events.concat(segment.events);\n    curSegment.endCoord = [segment.end_lng, segment.end_lat];\n    curSegment.distanceMiles += segment.length;\n    curSegment.cameraStreamSegCount += Math.floor(segmentHasVideo);\n    curSegment.driverCameraStreamSegCount += Math.floor(segmentHasDriverCameraStream);\n  });\n\n  if (curSegment) {\n    finishSegment(curSegment);\n  }\n\n  return segments;\n\n  function finishSegment(segment) {\n    var lastEngage = null;\n\n    if (segment.hasVideo) {\n      var lastVideoRange = segment.videoAvailableBetweenOffsets[segment.videoAvailableBetweenOffsets.length - 1] || [segment.offset, segment.offset + segment.duration];\n      segment.videoAvailableBetweenOffsets = [].concat((0, _toConsumableArray3.default)(segment.videoAvailableBetweenOffsets.slice(0, segment.videoAvailableBetweenOffsets.length - 1)), [[lastVideoRange[0], segment.offset + segment.duration]]);\n    }\n  }\n}\n\nfunction hasSegmentMetadata(state) {\n  if (!state.segmentData) {\n    console.log('No segment data at all');\n    return false;\n  }\n\n  if (!state.segmentData.segments) {\n    console.log('Still loading...');\n    return false;\n  }\n\n  if (state.dongleId !== state.segmentData.dongleId) {\n    console.log('Bad dongle id');\n    ;\n    return false;\n  }\n\n  if (state.start < state.segmentData.start) {\n    console.log('Bad start offset');\n    return false;\n  }\n\n  if (state.end > state.segmentData.end) {\n    console.log('Bad end offset');\n    return false;\n  }\n\n  if (state.end > state.segmentData.end) {\n    console.log('Bad end offset');\n    return false;\n  }\n\n  return state.start >= state.segmentData.start && state.end <= state.segmentData.end;\n}","map":{"version":3,"sources":["/home/amax/Autoro/cabana/node_modules/@commaai/comma-api/dist/drives.js"],"names":["Object","defineProperty","exports","value","fetchRoutes","undefined","_toConsumableArray2","require","_toConsumableArray3","_interopRequireDefault","_isFinite","_isFinite2","_regenerator","_regenerator2","_asyncToGenerator2","_asyncToGenerator3","_ref","default","mark","_callee","dongleId","start","end","segments","wrap","_callee$","_context","prev","next","getSegmentMetadata","sent","parseSegmentMetadata","abrupt","segmentsFromMetadata","reverse","stop","_x","_x2","_x3","apply","arguments","getRoutesSegments","getRouteInfo","setRouteRating","getShareSignature","getRouteSegments","listRoutes","_request","request","_interopRequireWildcard","obj","__esModule","newObj","key","prototype","hasOwnProperty","call","SEGMENT_LENGTH","get","from","to","routeName","rating","patch","limit","createdAfter","params","lastSegmentTime","routeStartTimes","map","segment","offset","Math","round","start_time_utc_millis","canonical_route_name","segmentNum","Number","canonical_name","split","routeOffset","duration","end_time_utc_millis","segmentsData","curSegment","curStopTime","curVideoStartOffset","forEach","url","proc_log","proc_qlog","segmentHasDriverCamera","proc_dcamera","segmentHasDriverCameraStream","segmentHasVideo","proc_camera","route","finishSegment","parts","pop","join","dongle_id","startTime","startCoord","start_lng","start_lat","replace","events","videoAvailableBetweenOffsets","hasVideo","deviceType","devicetype","hpgps","hasDriverCamera","hasDriverCameraStream","locStart","locEnd","distanceMiles","cameraStreamSegCount","driverCameraStreamSegCount","push","max","concat","endCoord","end_lng","end_lat","length","floor","lastEngage","lastVideoRange","slice","hasSegmentMetadata","state","segmentData","console","log"],"mappings":"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","sourcesContent":["'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.fetchRoutes = undefined;\n\nvar _toConsumableArray2 = require('babel-runtime/helpers/toConsumableArray');\n\nvar _toConsumableArray3 = _interopRequireDefault(_toConsumableArray2);\n\nvar _isFinite = require('babel-runtime/core-js/number/is-finite');\n\nvar _isFinite2 = _interopRequireDefault(_isFinite);\n\nvar _regenerator = require('babel-runtime/regenerator');\n\nvar _regenerator2 = _interopRequireDefault(_regenerator);\n\nvar _asyncToGenerator2 = require('babel-runtime/helpers/asyncToGenerator');\n\nvar _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);\n\nvar fetchRoutes = exports.fetchRoutes = function () {\n  var _ref = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee(dongleId, start, end) {\n    var segments;\n    return _regenerator2.default.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            _context.next = 2;\n            return getSegmentMetadata(start, end, dongleId);\n\n          case 2:\n            segments = _context.sent;\n\n            segments = parseSegmentMetadata(start, end, segments);\n            return _context.abrupt('return', segmentsFromMetadata(segments).reverse());\n\n          case 5:\n          case 'end':\n            return _context.stop();\n        }\n      }\n    }, _callee, this);\n  }));\n\n  return function fetchRoutes(_x, _x2, _x3) {\n    return _ref.apply(this, arguments);\n  };\n}();\n\nexports.getSegmentMetadata = getSegmentMetadata;\nexports.getRoutesSegments = getRoutesSegments;\nexports.getRouteInfo = getRouteInfo;\nexports.setRouteRating = setRouteRating;\nexports.getShareSignature = getShareSignature;\nexports.getRouteSegments = getRouteSegments;\nexports.listRoutes = listRoutes;\n\nvar _request = require('./request');\n\nvar request = _interopRequireWildcard(_request);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar SEGMENT_LENGTH = 1000 * 60; // Drives api\n// ~~~~~~~~~~\nfunction getSegmentMetadata(start, end, dongleId) {\n  return request.get('v1/devices/' + dongleId + '/segments', {\n    from: start,\n    to: end\n  });\n}\n\nfunction getRoutesSegments(dongleId, start, end) {\n  return request.get('v1/devices/' + dongleId + '/routes_segments', {\n    start: start,\n    end: end\n  });\n}\n\nfunction getRouteInfo(routeName) {\n  return request.get('v1/route/' + routeName + '/');\n}\n\nfunction setRouteRating(routeName, rating) {\n  return request.patch('v1/route/' + routeName + '/', { rating: rating });\n}\n\nfunction getShareSignature(routeName) {\n  return request.get('v1/route/' + routeName + '/share_signature');\n}\n\nfunction getRouteSegments(routeName) {\n  return request.get('v1/route/' + routeName + '/segments');\n}\n\nfunction listRoutes(dongleId, limit, createdAfter) {\n  var params = { limit: limit };\n  if (typeof createdAfter !== 'undefined') {\n    params.createdAfter = createdAfter;\n  }\n  return request.get('v1/devices/' + dongleId + '/routes', params);\n}\nfunction parseSegmentMetadata(start, end, segments) {\n  var lastSegmentTime = 0;\n  var routeStartTimes = {};\n  return segments.map(function (segment) {\n    segment.offset = Math.round(segment.start_time_utc_millis) - start;\n    if (!routeStartTimes[segment.canonical_route_name]) {\n      var segmentNum = Number(segment.canonical_name.split('--')[2]);\n      segment.segment = segmentNum;\n      if (segmentNum > 0) {\n        routeStartTimes[segment.canonical_route_name] = segment.offset - SEGMENT_LENGTH * segmentNum;\n      } else {\n        routeStartTimes[segment.canonical_route_name] = segment.offset;\n      }\n      segment.routeOffset = routeStartTimes[segment.canonical_route_name];\n    } else {\n      segment.routeOffset = routeStartTimes[segment.canonical_route_name];\n    }\n\n    lastSegmentTime = segment.offset;\n    segment.duration = Math.round(segment.end_time_utc_millis - segment.start_time_utc_millis);\n\n    return segment;\n  });\n}\nfunction segmentsFromMetadata(segmentsData) {\n  var curSegment = null;\n  var curStopTime = null;\n  var curVideoStartOffset = null;\n  var segments = [];\n  segmentsData.forEach(function (segment) {\n    if (!segment.url) {\n      return;\n    }\n    if (!(segment.proc_log === 40 || segment.proc_qlog === 40)) {\n      return;\n    }\n    var segmentHasDriverCamera = segment.proc_dcamera >= 0;\n    var segmentHasDriverCameraStream = segment.proc_dcamera === 40;\n    var segmentHasVideo = segment.proc_camera === 40;\n    if (segmentHasVideo && curVideoStartOffset === null) {\n      curVideoStartOffset = segment.offset;\n    }\n\n    curStopTime = segment.start_time_utc_millis;\n    if (!curSegment || curSegment.route !== segment.canonical_route_name) {\n      if (curSegment) {\n        finishSegment(curSegment);\n      }\n      var url = segment.url;\n      var parts = url.split('/');\n\n      if ((0, _isFinite2.default)(Number(parts.pop()))) {\n        // url has a number at the end\n        url = parts.join('/');\n      }\n      curSegment = {\n        dongleId: segment.dongle_id,\n        offset: segment.offset - segment.segment * SEGMENT_LENGTH,\n        route: segment.canonical_route_name,\n        startTime: segment.start_time_utc_millis,\n        startCoord: [segment.start_lng, segment.start_lat],\n        duration: 0,\n        segments: 0,\n        url: url.replace('chffrprivate.blob.core.windows.net', 'chffrprivate.azureedge.net'),\n        events: [],\n        videoAvailableBetweenOffsets: [],\n        hasVideo: segmentHasVideo,\n        deviceType: segment.devicetype,\n        hpgps: segment.hpgps,\n        hasDriverCamera: segmentHasDriverCamera,\n        hasDriverCameraStream: segmentHasDriverCameraStream,\n        locStart: '',\n        locEnd: '',\n        distanceMiles: 0.0,\n        cameraStreamSegCount: 0,\n        driverCameraStreamSegCount: 0\n      };\n      segments.push(curSegment);\n    }\n    if (!segmentHasVideo && curVideoStartOffset !== null) {\n      curSegment.videoAvailableBetweenOffsets.push([curVideoStartOffset, segment.offset]);\n      curVideoStartOffset = null;\n    }\n    curSegment.hasVideo = curSegment.hasVideo || segmentHasVideo;\n    curSegment.hasDriverCamera = curSegment.hasDriverCamera || segmentHasDriverCamera;\n    curSegment.hasDriverCameraStream = curSegment.hasDriverCameraStream || segmentHasDriverCameraStream;\n    curSegment.hpgps = curSegment.hpgps || segment.hpgps;\n    curSegment.duration = segment.offset - curSegment.offset + segment.duration;\n    curSegment.segments = Math.max(curSegment.segments, Number(segment.canonical_name.split('--').pop()) + 1);\n    curSegment.events = curSegment.events.concat(segment.events);\n    curSegment.endCoord = [segment.end_lng, segment.end_lat];\n    curSegment.distanceMiles += segment.length;\n    curSegment.cameraStreamSegCount += Math.floor(segmentHasVideo);\n    curSegment.driverCameraStreamSegCount += Math.floor(segmentHasDriverCameraStream);\n  });\n\n  if (curSegment) {\n    finishSegment(curSegment);\n  }\n\n  return segments;\n\n  function finishSegment(segment) {\n    var lastEngage = null;\n\n    if (segment.hasVideo) {\n      var lastVideoRange = segment.videoAvailableBetweenOffsets[segment.videoAvailableBetweenOffsets.length - 1] || [segment.offset, segment.offset + segment.duration];\n      segment.videoAvailableBetweenOffsets = [].concat((0, _toConsumableArray3.default)(segment.videoAvailableBetweenOffsets.slice(0, segment.videoAvailableBetweenOffsets.length - 1)), [[lastVideoRange[0], segment.offset + segment.duration]]);\n    }\n  }\n}\n\nfunction hasSegmentMetadata(state) {\n  if (!state.segmentData) {\n    console.log('No segment data at all');\n    return false;\n  }\n  if (!state.segmentData.segments) {\n    console.log('Still loading...');\n    return false;\n  }\n  if (state.dongleId !== state.segmentData.dongleId) {\n    console.log('Bad dongle id');;\n    return false;\n  }\n  if (state.start < state.segmentData.start) {\n    console.log('Bad start offset');\n    return false;\n  }\n  if (state.end > state.segmentData.end) {\n    console.log('Bad end offset');\n    return false;\n  }\n  if (state.end > state.segmentData.end) {\n    console.log('Bad end offset');\n    return false;\n  }\n\n  return state.start >= state.segmentData.start && state.end <= state.segmentData.end;\n}"]},"metadata":{},"sourceType":"script"}