{"ast":null,"code":"import DbcUtils from '../../utils/dbc';\n\nconst unsignedTransformation = field => (value, signal) => {\n  if (value !== '') {\n    value = Number(value) || 0;\n\n    if (value < 0) {\n      value = 0;\n    }\n  }\n\n  signal[field] = value;\n  return signal;\n};\n\nexport default [{\n  field: 'name',\n  title: 'Name',\n  type: 'string'\n}, {\n  field: 'size',\n  title: 'Size',\n  type: 'number',\n  transform: unsignedTransformation('size')\n}, {\n  field: 'startBit',\n  title: signal => signal.isLittleEndian ? 'Least significant bit' : 'Most significant bit',\n  type: 'number',\n  transform: unsignedTransformation('startBit')\n}, {\n  field: 'isLittleEndian',\n  title: 'Endianness',\n  type: 'option',\n  options: {\n    options: ['Little', 'Big'],\n    optionValues: {\n      Little: true,\n      Big: false\n    }\n  },\n  transform: (isLittleEndian, signal) => {\n    if (signal.isLittleEndian !== isLittleEndian) {\n      const {\n        startBit\n      } = signal;\n\n      if (isLittleEndian) {\n        // big endian -> little endian\n        const startByte = Math.floor(signal.startBit / 8);\n        const endByte = Math.floor((signal.startBit - signal.size + 1) / 8);\n\n        if (startByte === endByte) {\n          signal.startBit = signal.startBit - signal.size + 1;\n        } else {\n          signal.startBit = DbcUtils.matrixBitNumber(startBit);\n        }\n      } else {\n        // little endian -> big endian\n        const startByte = Math.floor(signal.startBit / 8);\n        const endByte = Math.floor((signal.startBit + signal.size - 1) / 8);\n\n        if (startByte === endByte) {\n          signal.startBit = signal.startBit + signal.size - 1;\n        } else {\n          signal.startBit = DbcUtils.bigEndianBitIndex(startBit);\n        }\n      }\n\n      signal.isLittleEndian = isLittleEndian;\n    }\n\n    return signal;\n  }\n}, {\n  field: 'isSigned',\n  title: 'Sign',\n  type: 'option',\n  options: {\n    options: ['Signed', 'Unsigned'],\n    optionValues: {\n      Signed: true,\n      Unsigned: false\n    }\n  }\n}, {\n  field: 'factor',\n  title: 'Factor',\n  type: 'number'\n}, {\n  field: 'offset',\n  title: 'Offset',\n  type: 'number'\n}, {\n  field: 'unit',\n  title: 'Unit',\n  type: 'string'\n}, {\n  field: 'comment',\n  title: 'Comment',\n  type: 'string'\n}, {\n  field: 'min',\n  title: 'Minimum value',\n  type: 'number'\n}, {\n  field: 'max',\n  title: 'Maximum value',\n  type: 'number'\n}, {\n  field: 'valueDescriptions',\n  title: 'Value descriptions',\n  type: 'map'\n}];","map":{"version":3,"sources":["/home/amax/Autoro/cabana/src/components/SignalLegendEntry/FIELDS.js"],"names":["DbcUtils","unsignedTransformation","field","value","signal","Number","title","type","transform","isLittleEndian","options","optionValues","Little","Big","startBit","startByte","Math","floor","endByte","size","matrixBitNumber","bigEndianBitIndex","Signed","Unsigned"],"mappings":"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","sourcesContent":["import DbcUtils from '../../utils/dbc';\n\nconst unsignedTransformation = (field) => (value, signal) => {\n  if (value !== '') {\n    value = Number(value) || 0;\n\n    if (value < 0) {\n      value = 0;\n    }\n  }\n  signal[field] = value;\n  return signal;\n};\n\nexport default [\n  {\n    field: 'name',\n    title: 'Name',\n    type: 'string'\n  },\n  {\n    field: 'size',\n    title: 'Size',\n    type: 'number',\n    transform: unsignedTransformation('size')\n  },\n  {\n    field: 'startBit',\n    title: (signal) => (signal.isLittleEndian ? 'Least significant bit' : 'Most significant bit'),\n    type: 'number',\n    transform: unsignedTransformation('startBit')\n  },\n  {\n    field: 'isLittleEndian',\n    title: 'Endianness',\n    type: 'option',\n    options: {\n      options: ['Little', 'Big'],\n      optionValues: { Little: true, Big: false }\n    },\n    transform: (isLittleEndian, signal) => {\n      if (signal.isLittleEndian !== isLittleEndian) {\n        const { startBit } = signal;\n\n        if (isLittleEndian) {\n          // big endian -> little endian\n          const startByte = Math.floor(signal.startBit / 8);\n          const endByte = Math.floor((signal.startBit - signal.size + 1) / 8);\n\n          if (startByte === endByte) {\n            signal.startBit = signal.startBit - signal.size + 1;\n          } else {\n            signal.startBit = DbcUtils.matrixBitNumber(startBit);\n          }\n        } else {\n          // little endian -> big endian\n          const startByte = Math.floor(signal.startBit / 8);\n          const endByte = Math.floor((signal.startBit + signal.size - 1) / 8);\n\n          if (startByte === endByte) {\n            signal.startBit = signal.startBit + signal.size - 1;\n          } else {\n            signal.startBit = DbcUtils.bigEndianBitIndex(startBit);\n          }\n        }\n        signal.isLittleEndian = isLittleEndian;\n      }\n      return signal;\n    }\n  },\n  {\n    field: 'isSigned',\n    title: 'Sign',\n    type: 'option',\n    options: {\n      options: ['Signed', 'Unsigned'],\n      optionValues: { Signed: true, Unsigned: false }\n    }\n  },\n  {\n    field: 'factor',\n    title: 'Factor',\n    type: 'number'\n  },\n  {\n    field: 'offset',\n    title: 'Offset',\n    type: 'number'\n  },\n  {\n    field: 'unit',\n    title: 'Unit',\n    type: 'string'\n  },\n  {\n    field: 'comment',\n    title: 'Comment',\n    type: 'string'\n  },\n  {\n    field: 'min',\n    title: 'Minimum value',\n    type: 'number'\n  },\n  {\n    field: 'max',\n    title: 'Maximum value',\n    type: 'number'\n  },\n  {\n    field: 'valueDescriptions',\n    title: 'Value descriptions',\n    type: 'map'\n  }\n];\n"]},"metadata":{},"sourceType":"module"}